\section{Introduction}
\label{s:intro}
%
In many cases, establishing the correctness of a program can be
formulated as proving that the program has a particular dependent
type.
%
Different classes of dependent types provide trade-offs in terms of
program properties that they can express versus the degree to which
checking that a program has a given type, or inferring its type, can
be automated.

% refinement types: context:
Previous work has demonstrated that the class of \emph{refinement
  types} often occupy a sweet spot: they can often express program
properties of interest, but can also by inferred with some degree of
optimization.
%
In particular, various engines for inferring refinement types have
also been proposed that themselves provide tradeoffs between
expressiveness and automation.
% HORS model checking:
Engines based on model checking \emph{higher-order recursion schemes
  (HORS)} are completely automatic when applied to programs that
operate on only scalar data~\cite{kobayashi09}.
%
Other approaches for inferring dependent types from
counterexamples~\cite{kobayashi11} can only infer a restricted class
of predicates over recursive datatypes, such as length functions.
% Liquid Types:
Engines that infer \emph{liquid types} require a user to provide
predicates from which the refinement types of expressions are
constructed, but are complete for inferring such
types~\cite{kawaguchi09,rondon08,vazou14}.
% heavyweight stuff:
Other techniques attempt to infer refinement types completely
automatically, using either techniques for solving constraint-logic
programs (such as interpolation) or inference problems in machine
learning~\cite{terauchi10}.

% problem: all refinement types have to be given:
While multiple approaches have been proposed that address
refinement-type inference, all such approaches, to some extent,
require a programmer to provide definitions of refinement types of
interest.
%
I.e., many existing type inference engines synthesize refinements of
base and function types, and infer that program expressions have such
types.
%
However, even the most automated approaches~\cite{unno09} require that
a programmer provide complete definitions of recursive types, such as
lists or trees, which are chosen using conventional type-inference
heuristics~\cite{pierce98}.
%
While a programmer typically must provide at least a few such types
explicitly as components of the program's specification, requiring the
programmer to provide complete definitions of types of values
constructed during intermediate steps of a computation is an
unfortunate burden.

% our contribution: can synthesize refinement types
In this paper, we propose a type-inference engine, named \sys, that
both synthesizes complete definitions of recursive refinement types
and infers the types of program expressions.
%
\sys does not place any restriction on the interaction of core
features of a language: it can potentially infer types for programs
that make arbitrary use of higher-order functions and recursive data
types.
%
\sys can synthesize recursive types that are abstracted over both
base, function, and recursive values;
%
such types are particularly useful because they can be applied to
variables in the context of an expression to be typed.

% key feature: reduction to logic programming
The key feature of \sys is that, given program $P$ and expected type
$\tau$, it performs a syntax-directed translation to a system of
\emph{Constrained Horn Clauses (CHCs)} $\mathcal{C}$, such that each
valid typing $P$ as having $\tau$ corresponds to a solution to
$\mathcal{C}$.
%
In particular, each solution of $\mathcal{C}$ defines, for each
subexpression $e$ of $P$, both recursive refinement types that express
requirements of all recursive values bound in a context of $e$, and,
if all requirements are satisfied, a guaranteed recursive refinement
type of the value of $e$.
%
In principle, $\mathcal{C}$ can be solved by any solver for recursive
CHCs that finds solutions in combinations of theories used to model
program base values (i.e., linear arithmetic) and uninterpreted
functions with equality~\cite{bjorner13}.
%
In practice, \BH{??}

% discuss as framework that can be tuned to give liquid types
A key feature of our translation is that it can serve as a framework
that can be instantiated to simulate several previously-developed
type-inference engines, depending on desired trade-offs between
effectiveness and automation.
%
In particular, an engine that satisfies the convergence properties of
Liquid Types, but can potentially infer a strictly richer class of
refinement types, can be simulated by rewriting clauses generated by
the syntax-directed translation to use given predicates.

% outline rest of paper
The rest of this paper is organized as follows.
%
\autoref{s:overview} introduces \sys by example.
%
\autoref{s:background} reviews technical foundations on which \sys is
built.
%
\autoref{s:approach} describes \sys in technical detail.
%
\autoref{s:eval} describes our evaluation of \sys.
%
\autoref{s:relwk} compares \sys to related work, and %
\autoref{s:conclusion} concludes.
