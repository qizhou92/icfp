\section{Technical Approach}
\label{s:approach}
%
In this section, we describe our technical approach in detail.

\subsection{A syntax-directed reduction}
\label{s:reduction}
%
\sys, given $P \in \rtlc$ in $\tau \in \types$, attempts to determine
$P \hastype \tau$ by generating a CHC system $\mathcal{C}$ such that
each valid typing of the sub-expressions of $P$ that proves $P
\hastype \tau$ corresponds to a solution of $\mathcal{C}$.
%
$\mathcal{C}$ is generated by a syntax-directed translation over $P$.
%
For the rest of this section, $P$ and $\tau$ are fixed.

% define the space of relational predicates:
\subsubsection{Relational Predicates}
\label{s:rel-preds}
The relational predicates of $\mathcal{C}$ are defined as follows.
%
For each $e \in \subexps(P)$, there is a collection of relational
predicates that correspond to required types of all free variables of
$e$ and the guaranteed type of $e$ itself.
%
The relational predicates that model correct typings of $e$ are as
follows.
%
Let $\freevars(e)' = \add{\freevars(e)}{\nu}$.
%
For each $x \in \freevars(e)'$ and $\tau \in \basetypes$,
%
\BH{define}
%
let the relational predicates of $\tau$ in $e$, denoted
$\relpredsof{e}{x}{\tau}$, be defined inductively as the structure of
$\tau$:
% define relational predicates by case splitting on \tau:
\begin{itemize}
\item
  % case: type is Bool:
  If $\tau$ is $\setformer{\nu : \bools}{ \true }$, then
  $\typerelpredsof{ e }{ x }{ \tau } = \elts{ \relpredof{ e }{ x }{
      \bools } }$.
\item
  % case: type is Int:
  If $\tau$ is $\setformer{\nu : \ints}{ \true }$, then
  $\typerelpredsof{ e }{ x }{ \tau } = \elts{ \relpredof{ e }{ x }{
      \ints } }$.
\item
  % case: type is type var:
  If $\tau$ is $X \in \typevars$, then $\typerelpredsof{ e }{ x }{
    \tau } = \elts{ \relpredof{ e }{ x }{ X } }$.
\item
  % case: type is function type:
  If $\tau$ is $\tau_0 \to \tau_1$ for $\tau_0, \tau_1 \in
  \basetypes$, then $\typerelpredsof{ e }{ x }{ \tau } =
  \setformer{ \paramrelcons(R) }{ R \in \typerelpredsof{ e }{ x }{
      \tau_0 } } %
  \union \setformer{ \resrelcons(R) }{ R \in
    \typerelpredsof{e}{x}{\tau_1} }$.
  %
  \BH{add relational symbol for the top-level function}
\item 
  % case: type is recursive type:
  If $\tau$ is $\mu X. C_0(y_0^0 : \tau_0^0, \ldots, y_0^{|C_0|} :
  \tau_0^{|C_0|}, \ldots, C_n(y_n^0 : \tau_n^{|C_n|})$, then
  $\relpredsof{ e }{ x }{ \tau } = $
  %
  \BH{add a relational symbol for each component of each
    constructor}
\end{itemize}
%
Then $\sympreds{ e }{ x } = \typerelpredsof{ e }{ x }{ \basetype{ e }{
    x } }$.
%
\BH{define arguments of each relational predicate}

% define the constraint clauses generated:
\subsubsection{Constraint Clauses}
\label{s:clauses}
The clauses of $\mathcal{C}$ are defined as follows.

%
\BH{define subtype constraint over symbol}

%
\subsection{Liquid Type Synthesis}
\label{s:liquid-type-syn}
