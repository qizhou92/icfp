Consider the following expression:
`(\a.a 1)(\b.b+1) : Int`

The expression is an application. Therefore, we:
  + generate a fresh relational predicate `R0(Int)`
  + expand the arguments
  + constrain the argument's type by the applicand's argument type
    That is, `R3(x, y) => R1(x, y)`, where these predicates are generated below



The applicand is:
`\a.a 1 : (Int -> Int) -> Int`

The expression has a *higher order type*. Therefore, we generate two fresh
relational predicates to represent its parts:

  `R1(Int, Int)`
  `R2(Int)`

The result of calling the higher order function with an appropriate argument
must be of a type as constrained by `R0`. Therefore, the type described by `R2`
must be a subtype of `R0`:

`R2(x) => R0(x)`

The argument is:
`\b.b+1` : Int -> Int

We generate a fresh predicate `R3(Int, Int) to represent the type.



Next, we will expand `\a.a 1 : (Int -> Int) -> Int`. This expression is a
lambda abstraction, so we must generate a context before expanding its body.
We generate a fresh predicate `C0(Int, Int)` to represent the context of this
abstraction.

The body of the lambda expression is `a 1: Int`. Since expression is an
application, we:
  + generate a fresh relational predicate `R4(Int)`
  + expand the arguments
  + constrain the arguments' type by the applicand's argument type
    That is `R6(x) => R5(x, y)`



The applicand is `a : Int -> Int`. We generate a fresh relational predicate to
represent its type: `R5(Int, Int)`.

The argument is `1 : Int`. We generate a fresh relational predicate to
represent its type: `R6(Int)`.



Next we will expand `a : Int -> Int`. `a` is a variable, so we constrain the
relation of its type by the context: `C0(x, y) => R5(x, y)`

Next we will expand `1 : Int`. `1` is a constant, so we apply a fixed
constraint to the relation of its type:
  `x = 1 => R6(x)`.
