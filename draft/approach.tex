% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-types}, we define a type system for proving
equivalence of programs.
%
In \autoref{sec:verifier}, we present an algorithm for inferring such
types.

\subsection{Equivalence proofs as relational types}
\label{sec:rel-types}
%
In this section, we describe a space of types over collections of
expressions, which can represent proofs of equivalence of functional
programs.
%
In \autoref{sec:rel-type-space}, we give key instances of such types,
and operators for constructing such types.
%
In \autoref{sec:rel-type-sys}, we give a type system for relational
types.

\subsubsection{A space of relational types}
\label{sec:rel-type-space}
%
\sys, given programs $P_0$ and $P_1$, attempts to verify that $P_0
\equiv P_1$ by synthesizing a proof that $(P_0, P_1)$ has a relational
type of equivalent programs.

% define relational types:
Relational types describe sets of tuples of values, each of which may
be a higher-order values.
%
\BH{define type positions (in background?)}
%
\begin{defn}
  \label{defn:rel-type}
  For $T \in \types^{*}$, $P_0, P_1 \subseteq ?? \times \typepos$, the
  space of relational types of $P_0$ in $T$ over $P_1$, denoted
  $\reltypes{ T }{ P_0 }{ P_1 }$, is the smallest space that satisfies
  the following conditions:
  % case: nil type is a relational type
  \textbf{(1)} $\nilrel \in \reltypes{ T }{ P_0 }{ P_1 }$;
  % case: constructed relational types from relational types:
  \textbf{(2)} for $P_B, P_F \subseteq \typepos{ T }$ the extensions
  of $P_0$ that are positions of base and function types, %
  $\tau \in \reltypes{ T }{ P_F }{ P_1 \union P_B }$, and %
  $\varphi \in \formulas{ P_1 \union P_B \union P_F }$, it holds that
  $(\tau, \varphi) \in \reltypespos{ T }{ P_0 }{ P_1 }$.
\end{defn}
%
For $T \in \types^{*}$, the relational types over $T$ are denoted
$\reltypestypes{ T } = \reltypespos{ T }{ ?? \times \epsilon }{
  \emptyset }$.
%
\BH{clean up so that type position only points into a type that
  actually has the position}
%
The space of relational types over all sequences of types is denoted
$\reltypes = \bigunion_{T \in \types^{*} } \reltypestypes{T}$.

\BH{give relational type of higher-order expressions from running
  example}

\BH{define the equivalence for any pair of base types}
%
For each $\tau \in \types$, there is a relational type $\tau_{\equiv}
\in \reltypestypes{ [ \tau, \tau] }$ such that for all $e_0, e_1 \in
\stlc$, if $e_0 \equiv e_1$, then $e_0$ paired with $e_1$ have type
$\tau_{\equiv}$.
%
\BH{define the equivalence type for each type}

% 
The definition of when a collection of expressions has a relational
type, and the connection between equivalence the each base type's
equivalence type, is given in \autoref{sec:rel-type-sys}.

\BH{define intersection of relational types}

\subsubsection{A system for relational types}
\label{sec:rel-type-sys}
% rules for determining if expression sequences have a relational type:
\begin{figure}
  \centering
  \begin{gather*}
    % rule: expressions are all atomic (constants or variables):
    \inference[ ATOMICS ]{ %
      E \subseteq \atomics %
    }{ \Gamma \judges E : \Gamma } \\
    % rule: expression is an op:
    \inference[ OP ]{ 
      \Gamma \judges %
      \elts{ (e_0, i_0), (e_1, i_1) } \disjunion E : \tau }{ %
      \Gamma \judges \disjadd{ (e_0 \oplus e_1, i) }{ E } : %
      \replace{ \tau }{ (e_0, i_0) \oplus (e_1, i_1) }{ %
        (e_0 \oplus e_1, i) } } \\
    % rule: expression is an if-then-else:
    \inference[ ITE ]{ %
      \Gamma, (e_0, i_0) = \true \judges %
      \elts{ (e_0, i_0), (e_1, i_1) } \disjunion E : %
      \tau_1 &
      \Gamma, (e_0, i_0) = \false \judges %
      \elts{ (e_0, i_0), (e_2, i_2) } \disjunion E : %
      \tau_2 }{ %
      \Gamma \judges \disjadd{ \ite{ e_0 }{ e_1 }{ e_2 } }{ E } : %
      \tau_1 \lor \tau_2 } \\
    % rule: multiset contains an expression that is an abstraction
    \inference[ ABS ]{ \Gamma, \tau \judges \disjadd{ (e, i) }{ E } : \tau' &
    }{ %
      \Gamma \judges \disjadd{ (\lambda x.\ e, i') }{ E } : %
      \replace{ \tau \rightarrow \tau' }{ x }{ \alpha_0 } } 
    % rule: expression is a fixpoint:
    \inference[ FIX ]{ %
      \Gamma, \tau \judges \disjadd{ (e, i'') }{ E } : \tau }{ %
      \Gamma \judges \disjadd{ ( \fix{ f }{ e }, i ) }{ E } : %
      \replace{ \tau }{ (f, i') }{ ( \fix{ f }{ e }, i ) }
    } \\
    % rule: expression is an application:
    \inference[ APP ]{ %
      \Gamma \disjadd{ (e_0, i_0) }{ E } : \tau_0 \rightarrow \tau_0' & 
      \Gamma \disjadd{ (e_1, i_1) }{ E } : %
      \replace{ \tau_0 }{ \alpha_0 }{ (e_1, i_1) }
    }{ \Gamma \disjadd{ (e_0\ e_1, i) }{ E } \judges \tau } \\
    % rule: subtyping:
    \inference[ SUB ]{ %
      \Gamma \judges E : \tau & \tau \subtype \tau'
    }{ \Gamma \judges E : \tau' } 
    % rule: split multiset of expressions:
    \inference[ UNION ]{ 
      \Gamma \judges E_0 : \tau_0 &
      \Gamma \judges E_1 : \tau_1 } %
    { \Gamma \judges E_0 \union E_1 : \tau_0 \land \tau_1 } 
  \end{gather*}
  \caption{A proof system for relational types.}
  \label{fig:reltypes-rules}
\end{figure}
%
\BH{atomics: fix to equate constants to copies in multisets}
% introduce the has-type relation
\BH{define the True relational type}
%
\BH{define subtyping rules}
%
Relational types are associated with multisets of program expressions
to prove that the expressions satisfy relational properties, such as
functional equivalence.
%
\autoref{fig:reltypes-rules} contains a set of inference rules that
define a proof system for establishing that a multiset of expressions
has a relational type.
%
For $\Gamma, \tau \in \reltypes$ and $E \multiset{ \expr }$, the fact
that under $\Gamma$, $E$ has type $\tau$ is denoted $\Gamma \judges E
: \tau$.

determining if sequences of expressions have
a relational type.
%
In particular, Rule~STEP0 asserts that if 
%
\BH{complete}
Rule~STEP1 asserts that if
%
\BH{complete}
% split 0: rule for splitting invariants over sequences:
Rule~SPLIT0 asserts that for all $E_0, E_0', E_0'' \in \expr^{*}$ such
that $E_0'$ and $E_0''$ tile $E_0$ and %
each $E_1 \in \expr^{*}$, if %
\textbf{(1)} under $\Gamma \in \relctxs$ restricted to $E_0'$ and
$E_1$, $(E_0', E_1)$ has type $\tau_0$ and %
\textbf{(2)} under $\Gamma$ restricted to $E_0''$ and $E_1$, $(E_0',
E_1)$ has type $\tau_1$, then under $\Gamma$, $(E_0, E_1)$ has type
as a type the conjunctive unification
%
\BH{fix in rules}
%
of $\tau_0$ and $\tau_1$.
% split 1: rule for splitting invariants over sequences:
Rule~SPLIT1 asserts that for each $E_0 \in \expr^{*}$ and %
all $E_1, E_1', E_1'' \in \subexps$ such that $E_1'$ and $E_1''$ tile
$E_1$, if %
\textbf{(1)} under $\Gamma \in \relctxs$ restricted to $E_0$ and
$E_1'$, $(E_0, E_1')$ has type $\tau_0$ and %
\textbf{(2)} under $\Gamma$ restricted to $E_0$ and $E_1''$, $(E_0,
E_1'')$ has type $\tau_1$, then under $\Gamma$, $(E_0, E_1)$ has as a
type the conjunctive unification
%
\BH{fix in rules}
%
of $\tau_0$ and $\tau_1$.

% types as proving equivalence:
\BH{state main soundness result}
% 
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0 \equiv P_1$ as a proof that $\elts{ P_0, P_1 } :
\tau_{\equiv}$.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% structures maintained by inference algorithm. Unfoldings:
\sys attempts to extract a proof that $P_0, P_1 : \tau_{\equiv}$ from
a map from multisets of \emph{unfoldings} of sub-expressions of $P_0$
and $P_1$ to candidate relational types.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $f \in \vars$ and $e \in \expr$, the \emph{unfoldings} of
  $\fix{f}{e}$, denoted $\unfoldings{ \fix{f}{e} }$

 are the smallest set of expressions such that:
  %
  \begin{enumerate}
  \item $f \in \unfoldings{ \fix{f}{e} }$;
  \item For each $e' \in \unfoldings{ \fix{f}{e} }$, $\replace{
      \fix{f}{e} }{ f }{ e' } \in \unfoldings{ \fix{f}{e} }$.
  \end{enumerate}
\end{defn}
%
\BH{fix defn of unfoldings above to allow the unfolded expressions to
  occur as subexpressions of the main expressions}
%
\BH{give examples}

% invariant structure:
Partial relational invariants are a map from multisets of unfoldings
to relational types.
%
\begin{defn}
  \label{defn:inferred-invs}
  Let
  \begin{itemize}
  \item 
    % subexpressions of unfoldings:
    $\mathcal{E} \subseteq \pset{ \subexps{ \unfoldings{P_0} } \union
      \subexps{\unfoldings{P_1} } }$;
  \item
    % context types:
    $\Gamma : \mathcal{E} \to \reltypes$;
  \item
    % relational types of subexpressions:
    $T : \mathcal{E} \to \reltypes$
  \end{itemize}
  %
  be such that 
  \begin{itemize}
  \item 
    % multiset of programs has the equivalence type:
    $T( \elts{ P_0, P_1 } ) \entails \tau_{ \equiv }$; 
  \item 
    % type of set is subtype of type of extension with fixpoint
    % symbol
    For all $E \in \mathcal{E}$ and each $f \in \vars$, $T(E) \subtype
    T(\disjadd{ f }{ E })$.
  \item 
    % relational types are consistent under tiling:
    For each $E \in \mathcal{E}$ and $E_0, E_1 \subseteq E$ such that
    $E = E_0 \union E_1$, it holds that $T(E_0) \land T(E_1) \subtype
    T(E)$.
  \item 
    % relational types are consistent under subtypes:
    For all $e \in \expr$, $E \subseteq \expr$ such that
    $\disjadd{e}{E} \in \mathcal{E}$, $\Gamma(\subexps{e} \union E)
    \judges \subexps{ e } \union E : T( \subexps{e} \union E)$
    supports that $\Gamma(\disjadd{e}{E}) \judges \disjadd{e}{E} :
    T(\disjadd{e}{E})$.
  \end{itemize}
\end{defn}
%
\BH{patch to account for how predecessors actually work in typing
  rules}
%
\BH{add choice conditions that make invariants evidence}

% define when invariants are inductive:
Unfolded invariants are inductive if they define a proof of the fact
that $P_0$ and $P_1$ have type $\tau_{\equiv}$.
% 
\begin{defn}
  \label{defn:ind-unfolded}
  \BH{complete}
\end{defn}

% evidence is a valid proof of partial equivalence:
If $P_0$ and $P_1$ have relational invariants, then $P_0 \equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are $R \in \relinvs{P_0}{P_1}$, then $P_0 \equiv P_1$.
\end{lemma}
%
\sys, given programs $P_0$ and $P_1$, attempts to determine their
partial equivalence by synthesizing inductive unfolded relational
types.

\subsection{Verification algorithm}
\label{sec:verifier}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(\cc{P}_0' \in \unfoldings{ \cc{P}_0 }, %
      \cc{P}_1' \in \unfoldings{ \cc{P}_1 })$}{ %
      % try to verify the unfoldings:
      \Switch{$\verifyunfoldings(\cc{P}_0, \cc{P}_1)$}{
        % if the verifier returns that the unfoldings aren't equivalent
        \lCase{$\nonequiv$}{ 
          % then the top-level returns that the programs aren't
          % equivalent
          \Return{$\false$} }
        % if the verifier returns relational types of the unfoldings:
        \lCase{$T \in \reltypes{ P_0 }{ P_1 }$}{ %
          % then check if they're inductive:
          \Switch{$\chkinductive(T)$}{ 
            \lCase{$\isind$}{ \Return{$\true$} }
            \lCase{ %
              $\cc{P}_0'' \in \unfoldings{ \cc{P}_0 }, %
              \cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$}{
              \Return{$\verifyaux(\cc{P}_0'', \cc{P}_1'')$}
            }
          }
        }
      }
    }
    \Return{$\verifyaux(\onestep(\cc{P}_0), \onestep(\cc{P}_1))$ %
      \label{line:core-base} }
  }
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier, which uses procedures
    \chkinductive (\autoref{sec:chk-ind}), \verifyunfoldings
    (\autoref{sec:verify-ders}), and %
    \mergeinvs (\autoref{sec:merge}).  }
  \label{alg:verify}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:verify}.
%
\BH{update}
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given $T \in
\unfoldreltypes{P_0}{P_1}$, attempts to determine if $P_0 \equiv P_1$ by
finding inductive derivation relational invariants built from $T$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the empty map of derivation relational
invariants and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given $T \in \unfoldreltypes{P_0}{P_1}$, runs procedure
\chkinductive on $T$ (\autoref{line:core-chkind};
%
\chkinductive is given in \autoref{sec:chk-ind}).
%
If \chkinductive determines that some restriction of $T$ are
inductive, then \chkinductive returns the value $\isind$, and
\verifyaux returns that $P_0 \equiv P_1$
(\autoref{line:core-ret-equiv}).

% case: no inductive restriction found:
Otherwise, \chkinductive returns $d_0 \in \evalders{ P_0 }$ and $d_1
\in \evalders{ P_1 }$ that do not have derivation relational
invariants in $T$ (\autoref{line:core-case-cex}).
%
\verifyaux then runs a procedure \verifyunfoldings on $d_0$ and $d_1$
(\autoref{line:core-vders}; \verifyunfoldings is given in
\autoref{sec:verify-ders}).
%
If \verifyunfoldings returns the value $\nonequiv$ to denote that $d_0
\not\equiv d_1$ (\autoref{line:core-subcase-non-equiv}), then
\verifyaux returns that $P_0 \not\equiv P_1$
(\autoref{line:core-ret-non-equiv}).

% subcase: finds path-pair invariants:
Otherwise, \verifyunfoldings returns $T' \in \unfoldreltypes{d_0}{d_1}$
(\autoref{line:core-subcase-invs}).
%
\verifyaux runs a procedure \mergeinvs on $T$ and $T'$, which
generates derivation relational invariants of all pairs of derivations
with relational invariants in $T$ or $T'$;
%
\mergeinvs is given in \autoref{sec:merge}.
%
\verifyaux recurses on the generated invariants and returns the result
(\autoref{line:core-recurse}).

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to \reltypes)$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $\replace{ E }{ f }{ \fix{ f }{ \fixexpr{ f } } }$ 
        } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$\fix{ f }{ e } \in E$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...

\subsubsection{Verifying equivalence of unfoldings}
\label{sec:verify-ders}
%
\verifyunfoldings, given $d_0 \in \progders{ P_0 }$ and %
$d_1 \in \progders{ P_1 }$, returns either \textbf{(1)} derivation
relational invariants of the derivation contexts of $d_0$ and $d_1$
or %
\textbf{(2)} the value $\nonequiv$ to denote that $d_0 \not\equiv
d_1$.
%
\verifyunfoldings reduces the problem of determining $d_0 \equiv d_1$ to
solving a recursion-free system of Constrained Horn Clauses
(\autoref{sec:chcs}).

% give construction:
\verifyunfoldings constructs a system $\mathcal{S}$, defined as follows.
% define relational predicates:
Each relational predicate of $\mathcal{S}$ is an element of $\derctxs{
d_0 } \times \derctxs{d_1}$.
%
Let the \emph{cuts} of $d_0$, denoted $\cuts{d_0} \subseteq \derctxs{
  d_0 }^{*}$, be the smallest set such that %
\textbf{(1)} $[ \epsilon ] \in \cuts{ d_0 }$; %
\textbf{(2)} for all $\gamma_0' \in \derctxs{ d_0 }$, and %
$\Gamma_0'' \in \derctxs{ d_0 }^{*}$ such that $\gamma_0' \cons
\Gamma_0'' \in \cuts{ d_0 }$, %
it holds that $\derexts{ d_0 }(\gamma_0) \concat \Gamma_0'' \in
\cuts{d_0}$.
%
The cuts of $d_1$, denoted $\cuts{d_1}$, are defined symmetrically.
% define relational predicates per tiling:
The relational predicates of $\mathcal{S}$ are $\cuts{d_0} \times
\cuts{d_1}$.
%
For each $\gamma \in \derctxs{d_0}$, let there be a distinct copy of
the symbolic variables for the expression of $\gamma$, denoted
$\symvars{ \gamma }$.
%
For each $\Gamma \subseteq \derctxs{d_0}^{*}$, let 
$\symvars{ \Gamma } = \bigunion_{ \gamma \in \Gamma} \symvars{\gamma}$.
%
For each $C_0 \in \cuts{ d_0 }$ and $C_1 \in \cuts{ d_1 }$, relational
predicate $(C_0, C_1)$ has symbolic variables $\symvars{C_0},
\symvars{C_1}$.
%
In each application of relational predicate $(C_0, C_1)$, the
predicate is applied to these variables;
%
as a result, such variables are not shown explicitly below.

% give clauses for steps of P0:
The clauses of $\mathcal{S}$ are defined as follows.
%
Each evaluation rule applied in $d_0$ corresponds to a clause in
$\mathcal{S}$.
% 
In particular, for each $\gamma_0 \in \derctxs{ d_0 }$ with $\Gamma_0
= \derexts{ d_0 }( \gamma_0 )$, %
$\Gamma_0' \in \derctxs{ d_0 }^{*}$ such that $\gamma_0 \cons
\Gamma_0' \in \cuts{ d_0 }$, and %
$\Gamma_1 \in \cuts{ d_1 }$, there is a clause %
\[ (\Gamma_0 \concat C_0, C_1), %
\symstep{ \prevrule{ d_0 }( \gamma_0 ) }[ %
\symvars{ \Gamma_0 }, \gamma_0 ] \entails %
(\gamma_0 \cons C_0, C_1) \]

% give clauses for steps of P1:
Each evaluation rule applied in $d_1$ corresponds to a clause in
$\mathcal{S}$.
%
In particular, for each $C_0 \in \cuts{ d_0 }$, %
each $\gamma_1 \in \derctxs{ d_1 }$ with $\Gamma_1 = \derexts{d_1}(
\gamma_1 )$, and %
$\Gamma_1' \in \derctxs{ d_1 }^{*}$ such that $\gamma_1 \cons
\Gamma_1' \in \cuts{ d_1 }$, there is a clause
\[ ( \Gamma_0, \Gamma_1 \concat C_1), %
\symstep{ \prevrule{ d_1 }( \gamma_1 ) }[ %
\symvars{ \Gamma_1 }, \gamma_1 ] \entails %
(C_0, \gamma_1 \cons C_1) 
\]

% split into P0 and P1 tilings
For all $C_0, C_0', C_0'' \in \cuts{d_0}$ such that $C_0'$ and $C_0''$
are a tiling of $C_0$, and %
each $C_1 \in \cuts{d_1}$, $\mathcal{S}$ contains a clause
\[ (C_0', C_1), (C_0'', C_1) \entails (C_0, C_1) \]
%
Symmetrically, for each $C_0 \in \cuts{d_0}$ and %
for all $C_0, C_1', C_1'' \in \cuts{d_1}$ such that $C_1'$ and $C_1''$
are a tiling of $C_1$, %
$\mathcal{S}$ contains a clause
\[ (C_0, C_1'), (C_0, C_1'') \entails (C_0, C_1)
\]

% point out which relational predicate is the query:
The query relational predicate of $\mathcal{S}$ is, by the above
construction, the empty derivation context of $d_0$ paired with the
empty derivation context of $d_1$: $( [ \epsilon ], [ \epsilon ])$.

% talk about how interpretation for S is translated to derivation
% relational invariants:
\verifyunfoldings runs the CHC solver \solvechc on $\mathcal{S}$.
%
If \solvechc returns that $\mathcal{S}$ has no solution, then
\verifyunfoldings returns $\nonequiv$, to denote that $d_0 \not\equiv d_1$.
%
Otherwise, if \solvechc returns some $\sigma \in \solutions{
  \mathcal{S} }$, then \verifyunfoldings returns $I \in
\unfoldreltypes{P_0}{P_1}$, where for each $\Gamma_0 \in \derctxs{ P_0
}$ and $\Gamma_1 \in \derctxs{ P_1 }$,
\[ I(\Gamma_0, \Gamma_1) = %
\subs{ \sigma(\Gamma_0, \Gamma_1) }{ %
  \symvars{ \headexps( \Gamma_0 ) }, %
  \symvars{ \headexps( \Gamma_1 ) } } \]

\subsubsection{Merging Derivation Relational Invariants}
\label{sec:merge}
% mergeinvs: give components of invariants 0:
$\mergeinvs$, given $I_0, I_1 \in \unfoldreltypes{P_0}{P_1}$, returns $I'
\in \unfoldreltypes{P_0}{P_1}$ such that
% case: domain is only P0:
\textbf{(1)} for $C_0 = \domain(I_0) \setminus \domain(I_1)$,
$\restrict{I'}{C_0} = \restrict{I_0}{C_0}$; 
% case: domain is only P1:
\textbf{(2)} for $C_1 = \domain(I_1) \setminus \domain(I_0)$,
$\restrict{I'}{C_1} = \restrict{I_1}{C_1}$;
% case: domain is intersection:
\textbf{(3)} for all $\Gamma \in \domain(I_0) \intersection
\domain(I_1)$, $I'(\Gamma) = I_0(\Gamma) \lor I_1(\Gamma)$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
