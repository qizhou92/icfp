% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-invs}, we define the class of proof
structures synthesized by \sys.
%
In \autoref{sec:verifier}, we present the verification algorithm used
by \sys to synthesize such structures.

\subsection{Relational invariants as equivalence proofs}
\label{sec:rel-invs}
%
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0$ is equivalent to $P_1$ that is represented as set of
subexpressions of $P_0$ and $P_1$, each mapped to relational
invariants that relate all evaluations of the subexpressions.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% define symbolic relations:
For each $i \in \elts{0, 1}$ and $n \in nats$, let $\symvarsidx{i}{n}$
denote a distinct set of symbolic variables.
%
Let $\subexpseqs = \subexps(P_0)^{*} \times \subexps(P_1)^{*}$.
%
\begin{defn}
  \label{defn:sym-rels}
  Let $R: \subexpseqs \partto \formulas{ \bigunion_{i \in \elts{0 ,
        1}, n \in \nats } \symvarsidx{i}{n} }$ be such that %
  for all $E_0 \in \subexps{P_0}^{*}$ and $E_1 \in \subexps{P_1}^{*}$,
  $R(E_0, E_1) \in \formulas{ %
    \bigunion_{ 0 \leq i < |P_0|} \symvarsidx{0}{i} \union %
    \bigunion_{0 \leq j < |P_1|} \symvarsidx{1}{j} }$.
  %
  Then $R$ are \emph{symbolic relations}.
\end{defn}
%
The space of symbolic relations of $P_0$ and $P_1$ is denoted
$\symrels{P_0}{P_1}$.

% relational invariants
% define relational invariants
Relational invariants of $P_0$ and $P_1$ are a map from sets of
subexpressions of $P_0$ and $P_1$, with each set $S$ mapped to a
formula that relates the evaluations of all expressions in $S$.
%
Relational invariants soundly describe all steps of evaluation that
can be taken by $P_0$ and $P_1$.
%
\begin{defn}
  \label{defn:rel-invs}
  Let $R_0, R_1 \in \symrels{P_0}{P_1}$ be such that %
  % condition: relation of empty sequences is entailed by true:
  \textbf{(1) \& (2)} $\true \entails R_0(\epsilon, \epsilon)$ and
  $\true \entails R_1(\epsilon, \epsilon)$;
  % steps in P0 are valid:
  \textbf{(2)} for all $E_0 \in \subexps{P_0}^{*}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \instrules{P_0}$, %
  there are some $E_0', E_0'' \in \subexps{P_0}^{*}$ such that
  $\rulepreds{r} \concat E_0 = E_0' \concat E_0''$ and
  \[ R_0(E_0' \concat E_0'', E_1), %
  R_1(E_0' \concat E_0'', E_1), %
  \symstep{ P_0 }{ r } \entails R_0(\rulesucc{r} \cons E_0, E_1) \]
  % symmetric condition for P1:
  \textbf{(3)} for all $E_0 \in \subexps{P_0}^{*}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \instrules{P_1}$, %
  there are some $E_1', E_1'' \in \subexps{P_1}^{*}$ such that
  $\rulepreds{r} \concat E_1 = E_1' \concat E_1''$ and
  \[ R_0(E_0, E_1' \concat E_0''), %
  R_1(E_0, E_1' \concat E_0''), %
  \symstep{P_1}{ r } \entails R_1(E_0, \rulesucc{r} \cons E_1) \]
  %
  Then $R_0$ and $R_1$ are \emph{relational invariants} of $P_0$ and
  $P_1$.
\end{defn}
%
The space of relational invariants of $P_0$ and $P_1$ is denoted
$\relinvs{P_0}{P_1}$.

% strengthen relational invariants to evidence of equivalence:
If relational invariants $R$ are such that the invariant for $\elts{
  P_0, P_1 }$, combined with the assumption that $P_0$ and $P_1$ are
given equal values, entails that $P_0$ and $P_1$ evaluate to equal
values, then $R$ is evidence of the partial equivalence of $P_0$ and
$P_1$.
%
\begin{defn}
  \label{defn:eq-pf}
  Let $R \in \relinvs{P_0}{P_1}$ be such that $R(P_0, P_1), \alpha^0_0
  = \alpha^1_0 \entails \nu^0 = \nu^1$.
  %
  Then $R$ is \emph{evidence} of $P_0 \equiv P_1$.
\end{defn}

% example of relational invariants:
\begin{ex}
  \label{ex:rel-invs}
  \BH{give example relational invariants}
\end{ex}

% evidence is a valid proof of partial equivalence:
If there is evidence of the equivalence of $P_0$ and $P_1$, then $P_0
\equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are some $R \in \relinvs{P_0}{P_1}$ such that $R$ is
  evidence of $P_0 \equiv P_1$, then $P_0 \equiv P_1$.
\end{lemma}

% define class of invariants that are actually maintained
\sys, given programs $P_0$ and $P_1$ attempts to determine if $P_0
\equiv P_1$ by synthesizing evidence of $P_0 \equiv P_1$ from a map
pairs of sequences of derivations of subexpressions of $P_0$ and $P_1$
to relational invariants.
% define tilings:
For each space $X$, $s, s_0, s_1 \in X^{*}$ if there are some $s_0',
s_1', s_2' \in X^{*}$ such that $s = s_0' \concat s_1' \concat s_2'$,
$s_0 = s_0' \concat s_2'$, and $s_1 = s_2' \concat s_1'$, then $s_0$
and $s_1$ are a \emph{tiling} of $s$.
%
Let the space of derivation relations of $P_0$ and $P_1$ be denoted
$\dersrels{P_0}{P_1} = \derctxs{P_0}^{*} \times
\derctxs{P_1}^{*} \partto \symrels{P_0}{P_1}$.
%
\begin{defn}
  \label{defn:der-structs}
  Let $I \in \dersrels{P_0}{P_1} $ be such that
  % maps empty contexts to invariant that supports equivalence:
  \textbf{(1)} $I([ \epsilon ], [ \epsilon ]), \alpha_0 = \alpha_1
  \entails \nu_0 = \nu_1$;
  % respects semantics of evaluation rules of P0:
  \textbf{(2)} for all $\gamma_0 \in \derctxs{P_0}$, %
  $D_0 \in \derctxs{P_0}^{*}$, %
  $D_1 \in \derctxs{P_1}^{*}$, and %
  each $r \in \evalrules$ such that for all $0 \leq i < \degreeof(r)$,
  $(((r, i) \cons \gamma_0) \cons D_0, D_1) \in \domain(I)$, 
  \[ \setformer{ I(((r, i) \cons \gamma_0) \cons D_0, D_1) }{ %
    0 \leq i < \degreeof(r) }, \symstep{ ... }{ ... } \entails %
  I( d_0 \cons D_0, D_1)
  \]
  %
  \BH{complete}
  % respects semantics of evaluation rules of P1:
  \textbf{(3)} for all $D_0 \in \derctxs{P_0}^{*}$, %
  each $\gamma_1 \in \derctxs{P_1}$, %
  all $D_1 \in \derctxs{P_1}^{*}$, and %
  each $r \in \evalrules$ such that for all $0 \leq i < \degreeof(r)$,
  $(D_0, ((r, i) \cons \gamma_1) \cons D_1) \in \domain(I)$, 
  \[ \setformer{ I( D_0, ( ( (r, i) \cons \gamma_1 ) \cons D_1) )}
  \entails %
  I( D_0, \gamma_1 \cons D_1 )
  \]
  % respects tiling in P0:
  \textbf{(4)} for all $D_0, D_0', D_0'' \in \subders{P_0}^{*}$ such
  that $D_0'$ and $D_0''$ are a tiling of $D_0$ and all $D_1 \in
  \subders{P_1}^{*}$ such that $(D_0, D_1) \in \domain(I)$,
  \[ I(D_0', D_1), I(D_0'', D_1) \entails I(D_0, D_1) \]
  % respects tiling in P1:
  \textbf{(5)} for all $D_0 \in \subders{P_0}^{*}$ and all $D_1, D_1',
  D_1'' \in \subders{P_1}^{*}$ such that $D_1'$ and $D_1''$ are a
  tiling of $D_1$ and $(D_0, D_1) \in \domain(I)$,
  \[ I(D_0, D_1'), I(D_0, D_1'') \entails I(D_0, D_1) \]
\end{defn}
%
The space of all derivation relational invariants of $P_0$ and $P_1$
is denoted $\dersinvs{P_0}{P_1}$.
%
\BH{update references to defn}
%
\BH{reference running example}

% define inductive derivation relational invariants
Derivation relational invariants are inductive if they define
relational invariants.
%
In particular, for $I \in \dersinvs{P_0}{P_1}$, let $I' \in
\relinvs{P_0}{P_1}$ be such that for all $E_0 \in \subexps{P_0}^{*}$
and $E_1 \in \subexps{P_1}^{*}$,
\begin{align*}
  % the invariant of the sequences of expressions is
  \exprel{I'}(E_0, E_1) = %
  % the conjunction of invariants over all nodes:
  \bigland \setformer{ I(\headexps(\Gamma_0), \headexps(\Gamma_1)) }{ %
    \Gamma_0 \in \derctxs{ P_0 }, \Gamma_1 \in \derctxs{ P_1 } } 
\end{align*}
%
$I \in \dersinvs{P_0}{P_1}$ are inductive if they can be decomposed to
form derivation relations that define relational invariants of $P_0$
and $P_1$.
%
For all $I_0, I_1 \in \dersrels{P_0}{P_1}$, let $I_0 \union I_1$ 
be such that 
% case: domain of only I0
\textbf{(1)} $\restrict{I_0 \union I_1}{\domain(I_0) \setminus
  \domain(I_1)} = \restrict{I_0}{\domain(I_0) \setminus \domain(I_1)}$;
% case: domain of only I1
\textbf{(2)} $\restrict{I_0 \union I_1}{\domain(I_1) \setminus
  \domain(I_0)} = \restrict{I_1}{\domain(I_1) \setminus
  \domain(I_0)}$;
% case: domain of only both
\textbf{(3)} for each $\Gamma \in \domain(I_0) \intersection
\domain(I_1)$, $\restrict{I_0 \union I_1}(\Gamma) = I_0(\Gamma) \land
I_1(\Gamma)$.
%
\begin{defn}
  \label{defn:inductive-der-rels}
  For $I_0, I_1 \in \dersrels{P_0}{P_1}$, if $(\exprel{I_0},
  \exprel{I_1})$ are relational invariants of $P_0$ and $P_1$, then
  $I_0 \union I_1$ are \emph{inductive} derivation relational
  invariants.
\end{defn}
%
Derivation relational invariants are evidence of partial equivalence,
by \autoref{lemma:equiv-evidence}.
%
\sys, given programs $P_0$ and $P_1$ attempts to determine their
partial equivalence by synthesizing inductive derivation relational
invariants.

\subsection{Verification algorithm}
\label{sec:verifier}
\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(I)$ \label{line:core-aux-begin} }{ %
      % check if the solution is inductive:
      \Switch{$\chkinductive(I)$ \label{line:core-chkind} }{ %
        \lCase{$\isind$}{ %
          % case: it is. Return that P0, P1 are equivalent.
          \Return{$\true$} \label{line:core-ret-equiv} %
        } %
        \Case{$D_0 \in \dertrees{ \cc{P}_0 }{ P_0 }$, %
          $D_1 \in \dertrees{ \cc{P}_1 }{ P_1 }$ %
          \label{line:core-case-cex}}{ %
          \Switch{$\verifyders(D_0, D_1)$ \label{line:core-vders} }{ %
            \lCase{$\nonequiv$: \label{line:core-subcase-non-equiv} }{ %
              \Return{$\false$} \label{line:core-ret-non-equiv} } %
            \lCase{$I' \in \dersrels{P_0}{P_1}$: %
              \label{line:core-subcase-invs} }{ %
              \Return{ $\verifyaux(\mergeinvs(I, I'))$ } %
              \label{line:core-recurse}
            } %
          } %
        } %
      } %
    } \label{line:core-aux-end} %
    \Return{$\verifyaux(\emptyset)$} \label{line:core-base} } %
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier.
  }
  \label{alg:verify}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:verify}.
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given derivation relational
invariants $I$, attempts to determine if $P_0 \equiv P_1$ by finding
inductive derivation relational invariants built from $I$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the empty map of derivation relational
invariants and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given derivation relational invariants $I$, runs procedure
\chkinductive on $I$ (\autoref{line:core-chkind}; 
%
\chkinductive is given in \autoref{sec:chk-ind}).
%
If \chkinductive determines that some restriction of $I$ are
inductive, then \chkinductive returns the value $\isind$, and
\verifyaux returns that $P_0 \equiv P_1$
(\autoref{line:core-ret-equiv}).

% case: no inductive restriction found:
Otherwise, \chkinductive returns a derivation $D_0$ of $P_0$ and $D_1$
of $P_1$ that do not have derivation relational
invariants in $I$ (\autoref{line:core-case-cex}).
%
\verifyaux then runs a procedure \verifyders on $D_0$ and $D_1$
(\autoref{line:core-vders}; \verifyders is given in
\autoref{sec:verify-ders}).
%
If \verifyders returns the value $\nonequiv$ to denote that $D_0$ and
$D_1$ are not equivalent (\autoref{line:core-subcase-non-equiv}), then
\verifyaux returns that $P_0 \not\equiv P_1$
(\autoref{line:core-ret-non-equiv}).

% subcase: finds path-pair invariants:
Otherwise, \verifyders returns relational derivation invariants $I'$
of $D_0$ and $D_1$ (\autoref{line:core-subcase-invs}).
%
\verifyaux runs a procedure \mergeinvs on $I$ and $I'$, which
generates derivation relational invariants of all pairs of derivations
with relational invariants in both $I$ and $I'$.
%
\verifyaux recurses on the generated invariants and returns the result
(\autoref{line:core-recurse}).

\subsubsection{Determining inductiveness of derivation invariants}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$D \in \dersinvs{P_0}{P_1}$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $D$ is
    inductive, or derivations of $P_0$ and $P_1$ not defined in $D$.}
  % verify: main procedure
  \myproc{$\chkinductive(D)$ \label{line:chkind-begin}} %
  { \myproc{$\chkindaux(\Gamma_0, \Gamma_1, I)$ %
      \label{line:chkind-aux-begin} } %
    { % bind the expressions of Gamma:
      $E \assign (\headexps(\Gamma_0), \headexps(\Gamma_1))$ %
      \label{line:chkind-bind-exps} \;
      % if Gamma is not defined,
      \lIf{$(\Gamma_0, \Gamma_1) \notin \domain(D)$}{ %
        % return a sequence of derivations of the head expressions
        \Return{$\chooseder(E)$} \label{line:chkind-counters} %
      }
      % 
      \Else{ %
        $\varphi_E \assign I(E)$ \label{line:bind-exp-invs} \; %
        $\varphi_{\Gamma} \assign D(\Gamma_0, \Gamma_1)$ %
        \label{line:bind-der-invs} \; %
        \lIf{$\varphi_E \entails \varphi_{\Gamma}$}{ %
          \Return{$\isind$} \label{line:ret-isind} %
        } %
        \Else{
          % strengthen the invariants at E:
          $I' = \upd{I}{ E }{ \varphi_E \land \varphi_{\Gamma} }$ %
          \label{line:str-invs} \; %
          $\tileind_0 \assign %
          \biglor \setformer{ %
            \chkindaux(\Gamma_0', \Gamma_1, I') = %
            \chkindaux(\Gamma_0'', \Gamma_1, I') = \isind }{ %
            \Gamma_0', \Gamma_0'' \in \derctxs{P_0}, %
            \tiles(\Gamma_0, \Gamma_0', \Gamma_0'') }$ %
          \label{line:tile-isind0} \; %
          $\tileind_1 \assign %
          \biglor \setformer{ %
            \chkindaux(\Gamma_0, \Gamma_1', I') = %
            \chkindaux(\Gamma_0, \Gamma_1'', I') = \isind }{ %
            \Gamma_1', \Gamma_1'' \in \derctxs{P_1}, %
            \tiles(\Gamma_1, \Gamma_1', \Gamma_1'') }$ %
          \label{line:tile-isind1} \; %
          \lIf{$\tileind_0 \lor \tileind_1$}{ %
            \Return{$\isind$} \label{line:tile-isind} %
          } %
          \lElse{ %
            \Return{ $\chooseres( %
              \unwind{ P_0 }(\Gamma_0, \Gamma_1, I'), %
              \unwind{ P_1 }(\Gamma_0, \Gamma_1, I'))$ } %
            \label{line:ret-unwind} %
          } %
        } %
        \label{line:chkind-aux-end} 
      } %
    } 
    \Return{$\chkindaux(\epsilon, \epsilon, \lambda x.\ \true)$} %
    \label{line:chkind-base} 
  } %
  \caption{ % interface of chkinductive:
    \chkinductive: determines the inductiveness of derivation
    relational invariants. }
  \label{alg:chk-ind}
\end{algorithm}
%
\BH{update to walk through new algorithm}
%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given derivation relational invariants $D$
(\autoref{line:chkind-begin}), defines a procedure \chkindaux that
takes $\Gamma_0 \in \derctxs{P_0}^{*}$, $\Gamma_1 \in
\derctxs{P_1}^{*}$, and $I: \subexpseqs \to \symrels{P_0}{P_1}$ and
returns either %
\textbf{(1)} $\isind$ to denote that if $I$ are inductive relational
invariants, then $D(\Gamma_0, \Gamma_1)$ have inductive relational
invariants that entail $I$ or
%
\BH{clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ with relational invariants
in $D$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each pair of sequences of
sub-expressions to $\true$, and returns the result
(\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I$ (\autoref{line:bind-exp-invs}), %
collects the derivation relational invariants $\varphi_{\Gamma}$ bound
to $\Gamma_0$ and $\Gamma_1$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $D$ under $I$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I'$ over that
strengthen $I$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in $D$ under
$I$ (\autoref{line:tile-isind0}), or there is some tiling of
$\Gamma_1$ such that $\Gamma_0$ paired with each tile is inductive in
$D$ under $I$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind{P_0}$ on $\Gamma_0$,
$\Gamma_1$, and $I'$, which returns either \textbf{(1)} $\isind$ to
denote that each predecessor of $\Gamma_0$ under $P_0$
%
\BH{define predecessor function}
%
paired with $\Gamma_1$ is inductive in $D$ under $I'$ or %
\textbf{(2)} returns derivations of $E$ that do not have invariants in
$D$;
%
the implementation of $\unwind{P_0}$ is defined below.
%
\chkindaux runs a similar procedure $\unwind{P_1}$ on $\Gamma_0$,
$\Gamma_1$, and $I'$.
% chooseres:
\chkindaux runs \chooseres on the results of the two calls.
%
If either call returns $\isind$, then \chooseres returns $\isind$.
%
Otherwise, \chooseres returns either the sequence of derivations
returned by the call to $\unwind{P_0}$, or the sequence returned by
the call to $\unwind{P_1}$.

\paragraph{Implementation of \textsc{unwind}}
%
$\unwind{P_0}$, given $\Gamma_0 \in \derctxs{P_0}^{*}$, $\Gamma_1 \in
\derctxs{P_1}^{*}$, and $I : \subexpseqs \partto \symrels{P_0}{P_1}$,
first determines if $\Gamma_0 = \epsilon$.
%
If so, then $\unwind{P_0}$ returns the empty sequence of derivations.

% case: non-empty sequence of derivations:
Otherwise, let $\gamma_0 \in \derctxs{P_0}$ and $\Gamma_0' \in
\derctxs{P_0}$ be such that $\Gamma_0 = \gamma_0 \cons \Gamma_0'$.
%
For each $r \in \instrules{P_0}$ that extends $\gamma_0$ in $P_0$ and
each $0 \leq i < \degreeof(r)$, $\unwind{P_0}$ runs \chkindaux on
$(((r, i) \cons \gamma_0) \cons \Gamma_0, \Gamma_1$.
%
If for each $r$ and $i$, \chkindaux returns $\isind$, then
$\unwind{P_0}$ returns $\isind$.
%
Otherwise, if there is some $r$ and $0 \leq i < \degreeof(r)$ such
that \chkindaux returns a sequence of derivations $D \in \ders{P_0}$
for $\headexps(\rulepreds(r))$, then $\unwind{P_0}$ returns a
derivation for $\headexps(\rulesucc(r))$ constructed from $D$ and $r$,
along with derivations for $\headexps(\Gamma_0')$ and
$\headexps(\Gamma_1)$.

% handwave P1:
The implementation of $\unwind{P_1}$ is symmetric to that of
$\unwind{P_0}$.

\subsubsection{Verifying equivalence of derivations}
\label{sec:verify-ders}
%
\verifyders, given $d_0 \in \dertrees{ P_0 }{ P_0 }$ and %
$d_1 \in \dertrees{P_1}{P_1}$, returns either \textbf{(1)} derivation
relational invariants of $d_0$ and $d_1$ or %
\textbf{(2)} the value $\nonequiv$ to denote that $d_0 \not\equiv
d_1$.
%
\verifyders reduces the problem of determining $d_0 \equiv d_1$ to
solving a recursion-free system of Constrained Horn Clauses
(\autoref{sec:chcs}).

% define relational predicates:
Each relational predicate of $\mathcal{S}$ is a pair of a sequence of
adjacent sub-derivations of $d_0$, paired with a sequence of adjacent
subderivations of $d_1$.
% define cuts
\verifyders constructs a system $\mathcal{S}$, defined as follows.
%
Let the \emph{cuts} of $d_0$, denoted $\cuts{d_0} \subseteq
\subders{d_0}^{*}$, be the smallest set such that %
\textbf{(1)} $[ d_0 ] \in \cuts{d_0}$; %
\textbf{(2)} for all $d_0' \in \subders{d_0}$ and $D_0'' \in
\subders{d_0}$ such that $d_0' \cons D_0'' \in \cuts{d_0}$,
$\immsubders{d_0'} \concat D_0'' \in \cuts{d_0}$.
%
The cuts of $d_1$, denoted $\cuts{d_1}$, are defined symmetrically.
% define relational predicates per tiling:
The relational predicates of $\mathcal{S}$ are $\cuts{d_0} \times
\cuts{d_1}$.
%
For each $d \in \subders{d_0}$, let there be a distinct copy of
symbolic variables for the expression derived by $d$, denoted
$\symvars{d}$.
%
For each $D \in \subders{d_0}$, let the union of symbolic variables
for all derivations in $D$ be denoted $\symvars{D}$.
%
For each $C_0 \in \cuts{d_0}$ and $C_1 \in \cuts{d_1}$, relational
predicate $(C_0, C_1)$ has symbolic variables $\symvars{C_0},
\symvars{C_1}$.
%
Each occurrence of $(C_0, C_1)$ is implicitly applied to its symbolic
variables.

% give clauses for steps of P0:
The clauses of $\mathcal{S}$ are defined as follows.
%
Each evaluation rule applied to construct $d_0$ is modeled by a set of
clauses in $\mathcal{S}$.
% for each derivation,
In particular, for each $r \in \instrules{P_0}$ and $D_0'' \in
\subders{ d_0 }$ such that $d_0' = (D_0'', r) \in \subders{ d_0 }$, %
each $C_0 \in \cuts{d_0}$ such that $d_0' \cons C_0 \in \cuts{ d_0 }$,
and %
$C_1 \in \cuts{ d_1 }$, there is a clause %
\[ (D_0'' \concat C_0, C_1), %
\symstep{ P_0 }{ r }[ \symvars{ D_0'' }, d_0' ] \entails %
(d_0' \cons C_0, C_1) \]

% give clauses for steps of P1:
Each evaluation rule applied to construct $d_1$ is modeled by clauses
of $\mathcal{S}$.
%
In particular, for each $r \in \instrules{P_1}$ and $D_1'' \in
\subders{d_1}$ such that $d_1' = (D_1'', r) \in \subders{ d_1 }$, %
each $C_0 \in \cuts{d_0}$, and %
each $C_1 \in \cuts{ d_1 }$ such that $d_1' \cons C_1 \in \cuts{d_1}$,
there is a clause
\[ (C_0, D_1'' \concat C_1), %
\symstep{ P_1 }{ r }[ \symvars{ D_1'' }, d_1' ] \entails %
(C_0, d_1' \cons C_1) \]

% split into P0 and P1 tilings
$\mathcal{S}$ contains clauses that constrain that the invariants for
tilings of a sequence of sub-derivations of $d_0$ must entail the
relational invariant for the sequence that they tile.
%
In particular, for all $C_0, C_0', C_0'' \in \cuts{d_0}$ such that
$C_0'$ and $C_0''$ are a tiling of $C_0$, and %
each $C_1 \in \cuts{d_1}$, there is a clause
\[ (C_0', C_1), (C_0'', C_1) \entails (C_0, C_1)
\]
%
Symmetrically, for each $C_0 \in \cuts{d_0}$ and %
for all $C_0, C_1', C_1'' \in \cuts{d_1}$ such that $C_1'$ and $C_1''$
are a tiling of $C_1$, %
there is a clause 
\[ (C_0, C_1'), (C_0, C_1'') \entails (C_0, C_1)
\]

% point out which relational predicate is the query:
The query relational predicate of $\mathcal{S}$ is, by the above
construction, $( [ D_0 ], [ D_1 ])$.

\subsubsection{Merging Derivation Relational Invariants}
% mergeinvs: give components of invariants 0:
$\mergeinvs$, given $I_0, I_1 \in \dersinvs{P_0}{P_1}$, returns $I'
\in \dersinvs{P_0}{P_1}$ such that
% case: domain is only P0:
\textbf{(1)} for $C_0 = \domain(I_0) \setminus \domain(I_1)$,
$\restrict{I'}{C_0} = \restrict{I'}{C_0}$; 
% case: domain is only P1:
\textbf{(2)} for $C_1 = \domain(I_1) \setminus \domain(I_0)$,
$\restrict{I'}{C_1} = \restrict{I'}{C_1}$;
% case: domain is intersection:
\textbf{(3)} for all $\Gamma \in \domain(I_0) \intersection
\domain(I_1)$, $I'(\Gamma) = I_0(\Gamma) \lor I_1(\Gamma)$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
