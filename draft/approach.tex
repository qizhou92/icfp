% give the real meat of the thing
\section{Technical Approach}
%
This section describes our technical approach in detail.
%
\autoref{sec:rel-types} we defines a type system that can be used to
prove that collections of programs satisfy relational properties.
%
\autoref{sec:infer} presents an algorithm for inferring typings in the
system.

\subsection{Relational properties as relational types}
\label{sec:rel-types}
%
This section describes a space of types over indexed expressions,
which correspond to properties over the indexed expressions.
%
\autoref{sec:rel-type-space} defines the representation of types, %
\autoref{sec:rel-type-ops} defines the space of relational types as
the closure under type operations, and %
\autoref{sec:rel-type-sys} defines a typing relation from indexed
expressions to relational types.

\subsubsection{Representation of relational refinement types}
\label{sec:rel-type-space}
% give overview:
A relational type is a set of refinement predicates that relate data
within components of structural types, combined with an association of
related least-fixed-point structural types.
%
Relational types are defined partially over a space of type positions,
which represent component types within algebraic types.
%
A type position is a sequences of type fields, which are symbols that
identify a structural type's component types.
%
The space of such fields, denoted $\typosfields$, consists of
$\tyunitfield$, $\tydatafield$, $\typaramfield$, $\tyresfield$,
$\tyleftprod$, $\tyrightprod$, $\tyleftsum$, $\tyrightsum$, and for
each $X \in \lfpvars$, $X$ and $\mu_X$.
%
The space of positions is denoted $\typos = \typosfields^{*}$.
% define subspaces of indexed positions:
For indices $I$, the space of type positions \emph{indexed} by $I$ is
denoted $\idxpos{I} = I \times \typos$.

% define refinement predicates, indexed predicates:
A relational refinement type is represented as indexed refinement
predicates that represent relations over data components of types and
an association of least-fixed point variables, with which
mutual-inductive properties over multiple least-fixed point types are
defined.
%
For indices $I$, a \emph{relational refinement predicate} over $I$ is
a refinement predicate whose vocabulary is the space of type positions
indexed by $I$ (i.e., the space $\refpreds{ \idxpos{I} }$).
%
$\Phi : \pset(I) \to \refpreds{ I }$ are \emph{indexed} relational
refinement predicates if for each $J \in \domain(\Phi)$, it holds
that $\Phi(J) \in \refpreds{J}$.
%
The space of refinement predicates indexed by $I$ is denoted
$\idxrefpreds{I}$.

% define relational refinement types:
Relational refinement types are represented as indexed refinement
predicates and an association of least-fixed point variables.
%
\begin{defn}
  \label{defn:rel-type-rep}
  For indices $I$, a \emph{relational refinement type representation}
  over $I$ is a tuple $(\Phi, N, P, M)$, where
  % indexed refinement predicates
  \textbf{(1)} $\Phi : \idxrefpreds{I}$ are refinement predicates
  indexed on $I$;
  % 
  \textbf{(2)} the least-fixed point variable \emph{indexing} is
  $N : \lfpvars \partto I$;
  % 
  \textbf{(3)} the least-fixed point variable \emph{positioning} is
  $P : \lfpvars \partto \typos$, where $X = \domain(N) = \domain(P)$
  % 
  \textbf{(4)} $M \subseteq X \times X$ is an equivalence relation
  over $X$ such that for each equivalence class $E \in \equiv_{M}$,
  the restriction $\restrict{N}{E}$ is one-to-one.
\end{defn}
%
The space of representations of relational refinement types over $I$
are denoted $\relreps{ I }$.

% walkthrough the operations over types:
\subsubsection{Operations and relations over relational refinement types}
\label{sec:rel-type-ops}
The space of relational refinement types is defined as a space of
relational refinement type representations closed under the following
set of operations.
%
Each operation corresponds to a constructor used to define a
conventional space of types (e.g., the space of structural types
defined in \autoref{sec:stlc}).

\paragraph{Atomic relational refinement types}
%
Atomic representations are defined purely over trivial type positions.
% e: pair each index with the empty type
For indices $I$, let $e : I \to I \times \typos$ be the one-to-one
function such that for each $i \in I$, $e(i) = (i, \epsilon)$.
% introduce map
For each $f : I \to I \times \typos$, let
$l_f : \refpreds{I} \to \refpreds{ \idxpos{I} }$ be such that for each
$\varphi \in \refpreds{I}$,
$l_f(\varphi) = \setformer{ e(i) / i }{ i \in I }$.
%
Then for each $N : \lfpvars \partto I$ and $M \in \equiv_X$ for
$X = \domain(N)$, the \emph{atomic} relational type defined by $\Phi$,
$N$, and $M$ is
$(\inv{e} \compose \Phi \compose l_{e}, N, X \mapsto \epsilon, M)$.
%
The space of atomic representations over $I$ is denoted $\atomics{I}$.

\paragraph{Abstraction of relational refinement function types}
%
The abstraction of representation $\tau$ over variable $x$ at index
$i$ is a representation in which the type at $i$ is a function from
the type at $x$ in $\tau$ to the type at $i$ in $\tau$.
% define renaming over indices:
For space of indices $I$ and $i, j \in I$, let
$\renamefn{i}{j} = \upd{ \iota_I }{i}{j}$.
% lift index renaming to position renaming
For $f : I \to I$, let $\renamepos{f} : \idxpos{I} \to \idxpos{I}$ be
such that for each $i \in I$ and $p \in \typos$,
$\renamepos{f}(i, p) = (f(i), p)$.
% define index renaming over sets of indexed type positions,
For $f : \idxpos{I} \to \idxpos{I}$, let
$\renameidxpos{f} : \pset(\idxpos{I}) \to \pset(\idxpos{I})$ be such
that for all $J \subseteq \idxpos{I}$, $\renameidxpos{f}(J) = %
\setformer{ f(p) }{ p \in J }$.
% define index renaming over relational refinement predicates,
Let
$\renamepred{f} : \refpreds{ \idxpos{I} } \to \refpreds{ \idxpos{I} }$
be such that for each $\varphi \in \refpreds{ \idxpos{I} }$,
$\renamepred{f}(\varphi) = \varphi[ \setformer{ f(p) / p }{ p \in
  \idxpos{I} } ]$.
%
For each $\Phi : \idxpos{I} \to \refpreds{ \idxpos{I} }$, the renaming
of $\Phi$ from $i$ to $j$ is
$\rename{ \Phi }{ i }{ j } = \renameidxpos{ \renamefn{j}{i} } \compose
\Phi \compose \renamepred{ \renameidxpos{ \renamefn{j}{i} } }$.

% define renaming over mapped indices
For all $i, j \in I$, the renaming of $N$ from $i$ to $j$ is
$N \compose \renamefn{i}{j}$.
%
For each $\Phi : \idxrefpreds{ I }$, $N : \lfpvars \to I$,
$P : \lfpvars \to \typos$, $E \in \equiv_{\mathcal{X}}$, and all
$i, j \in I$, the renaming in $(\Phi, N, P, E)$ from $i$ to $j$ is
$\rename{(\Phi, N, P, E) }{ i }{ j } = (\rename{ \Phi }{ i }{ j },
\rename{ N }{ i }{ j }, P, E)$.

% define prepending over indexed predicates:
For $i \in I$, $p \in \typos$,
$\prependpos{i}{p} : \idxpos{I} \to \idxpos{I}$ is such that for each
$q \in \typos$, $\prependpos{i}{p}(i, q) = (i, p \concat q)$, and for
each $j \not= i \in I$, $\prependpos{i}{p}(j, q) = q$.
%
For $\Phi : \idxrefpreds{ I }$, $i \in I$, and $p \in \typos$, $p$
prepended to $\Phi$ at $i$ is $p \prepend{i} \Phi = %
\renameidxpos{ \inv{ \prependpos{i}{p} } } \compose \Phi \compose
\prependpos{i}{p}$.

% define prepending over mapped type positions:
For $N : \mathcal{X} \to I$, $i \in I$, and $p \in \typos$, let
$\mathsf{pair}_{P}^N : \mathcal{X} \to I \times \typos$ be such that
for each $X \in \mathcal{X}$, $p_{P}^N(X) = (N(X), P(X))$.
%
The \emph{prepending} of $P$ with $p$ at $i$ under $N$ is
$p \fullprepend{i}{N} P = \mathsf{pair}_{P}^{N} \compose
\prependpos{i}{p}$.
%
For $\Phi : \idxrefpreds{ I }$, $N : \lfpvars \to I$,
$P : \lfpvars \to \typos$, and $E \in \equiv_{\mathcal{X}}$ the
prepending of $(\Phi, N, P, E)$ with $p$ at $i$ is
$p \prepend{i} (\Phi, N, P, E) = (p \fullprepend{i}{N} \Phi, N, p
\fullprepend{i}{N} P, E)$.

% define well-formedness of indexed refinement predicates
$\Phi \in \idxrefpreds{ I }$ are a \emph{valid instance} of index $i$
over index $j$ if for all $J \in \domain(\Phi)$ and each
$p \in \typos$ such that $(i, p) \in J$, there are no
$q_0, q_1 \in \typos$ such that
$q_0 \concat [ \typaramfield ] \concat q_1$ or
$q_0 \concat [ \tyresfield ] \concat q_1 \in J$.

% define function relational type operator
For index $i, x \in I$, %
$\Phi \in \idxrefpreds{I}$ a valid instance of $i$ over $x$, %
$N : \lfpvars \partto I$, %
$P : \lfpvars \partto \typos$, and %
$E \subseteq \lfpvars \times \lfpvars$ such that
$\tau = (\Phi, N, P, E)$ is a valid relational refinement type
representation (\autoref{defn:rel-type-rep}), the abstraction of
$\tau$ over $x$ at $i$ is
$\to_x^i \tau = \rename{ (\typaramfield \prepend{x} \tyresfield
  \prepend{i} \tau)}{ x }{ i }$.

% define relational sum:
\paragraph{Relational refinement sum types} The relational sum of
types $\tau$ and $\tau'$ from indices $i$ and $j$ to index $k$ is a
relational refinement type in which the type at $k$ is the sum of
types at $i$ in $\tau$ and at $j$ in $\tau'$.
%
I.e., for space of indices $I$,
$\mathcal{X}, \mathcal{X}' \subseteq \lfpvars$, index $i \in I$,
$\Phi, \Phi' \in \idxrefpreds{ \idxpos{I} }$,
% lfp vars to indices,
$N : \mathcal{X} \to I$, $N' : \mathcal{X}' \to I$,
% lfp vars to positions,
$P : \mathcal{X} \to \typos$, $P' : \mathcal{X}' \to \typos$, 
% equivalence classes:
$\mathcal{M} \in \equiv_{\mathcal{X}}$, and
$\mathcal{M}' \in \equiv_{\mathcal{X}'}$, the sum of
$(\Phi, N, P, \mathcal{M})$ and $(\Phi', N', P', \mathcal{M}')$ at $i$
is $(\Phi, N, P, \mathcal{M}) +^i (\Phi', N', P', \mathcal{M}') = %
% build disjoint union of extended indexed relational preds,
(\tyleftsum \prepend{i} \Phi \union \tyrightsum \prepend{i} \Phi',
% build disjoint union of variable map,
N \union N',
% build disjoint union of extended position maps,
\tyleftsum \fullprepend{i}{N} P \union \tyrightsum \fullprepend{i}{N}
P',
% equivalence classes: build union:
\mathcal{M} \union \mathcal{M}')$.

% define relational product:
\paragraph{Relational refinement product types}
The indexed product of relational type $\tau$ from indices $i$ and $j$
to index $k$ is a relational type in which the type at $k$ is the
product of types at $i$ and $j$.
%
I.e., for indices $I$, $\tau \in \reltypes{I}$, and indices
$i, j, k \in I$, the relational product of $\tau$ from $i$ and $j$ to
$k$ is
$\times_{i, j}^k \tau = \rename{ (\tyleftprod \prepend{i} \tyrightprod
  \prepend{j} \tau)}{ i, j }{k}$.

% define lfp:
\paragraph{Relational refinement least-fixed points}
The indexed least-fixed point of relational type $\tau$ at index $i$
defines a relational type over unbounded unfoldings of the relational
type at $i$.
%
I.e., for space of indices $I$, $\tau \in \reltypes{I}$ and
$X \in \mathcal{X}$, the least-fixed point of $\tau$ over $X$ at $i$
is $\mu_i X. \tau = %
\mu_X \prepend{i} \tau$.
%
For $\mathcal{Y} : I \partto \mathcal{X}$, the \emph{mutual} least
fixed point of $\tau$ over $\mathcal{Y}$ is
$\mu_\mathcal{Y} \tau = \mu_{i_0} \mathcal{Y}(i_0). \mu_{i_1}
\mathcal{Y}(i_1) \ldots \tau$ for all indices
$i_k \in \domain(\mathcal{Y})$.

% define space of relational types:
The space of relational refinement types is the closure of the space
of the atomic relational refinement types over the type operations
defined above.
%
\begin{defn}
  \label{defn:rel-types}
  For indices $I$, the space of relational refinement types over $I$,
  denoted $\reltypes{I}$, is defined inductively by the following
  cases:
  %
  \begin{itemize}
  \item % atomics,
    For each $A \in \atomics{I}$, it holds that $A \in \reltypes{I}$;
  \item % abstraction,
    For each $\tau \in \reltypes{I}$, each $i \in I$ and
    $x \in \vars$, $\to_x^i \tau \in \reltypes{I}$;
  \item % product,
    For each $\tau \in \reltypes{I}$ and all $i, j, k \in I$,
    $\times_{i, j}^k \tau \in \reltypes{I}$;
  \item % sum,
    For all $\tau, \tau' \in \reltypes{I}$ and each $i \in I$,
    $\tau +^i \tau' \in \reltypes{I}$;
  \item % lfp,
    For each $\tau \in \reltypes{I}$, $i \in I$, and $X \in \lfpvars$,
    $\mu_i X. \tau \in \reltypes{I}$.
  \end{itemize}
\end{defn}

\BH{define space of atomic representations}

% declare typing relation:
A key contribution of our work is the definition of a typing relation
from finite tuples of expressions to relational types.
%
For $e_0, \ldots, e_n \in \expr$ and
$\tau \in \reltypes{e_0, \ldots, e_n}$ (in which the indices are the
expressions $e_0, \ldots, e_n$ themselves), the fact that
$e_0, \ldots, e_n$ have type $\tau$ will be denoted
$e_0, \ldots, e_n : \tau$.
%
The typing relation is defined in \autoref{sec:rel-type-sys}, using
the type operators defined above, along with substitution and join
operations and a subtyping operation, defined below.

\paragraph{Substitution of relational refinement types}
%
The substitution of relational refinement type $\tau'$ in $\tau$ at
$\mathcal{X} \subseteq \lfpvars$ expands $\tau$ to replace occurrences
of $\mathcal{X}$ with $\tau'$.
%
For indicies $I$, $\mathcal{X} \subseteq \lfpvars$, and %
$m : I \partto \typos$, the prepending of $\Phi \in \idxrefpreds{ I }$
with $m$ is
$m \concat \Phi = m(i_n) \prepend{i_n} \ldots m(i_0) \prepend{i_0}
\Phi$, where $i_k$ range over $\domain(m)$.
%
For each $N : \mathcal{X} \to \typos$, the prepending of
$P : \mathcal{X} \to \typos$ with $m$ under $N$ is
$m \concat^N m(i_n) \fullprepend{i_n}{N} \ldots m(i_0)
\fullprepend{i_0}{N} P$, where $i_k$ range over the $\domain(m)$.

% define the substitution of relational types:
For $\Phi' \in \idxrefpreds{ \mathcal{X} }$, %
$N : \mathcal{X} \to I$, %
$P, P' : \mathcal{X} \to \typos$, %
$\mathcal{M} \in \equiv_{\mathcal{X}}$, and %
$\mathcal{Y} \in \mathcal{C}_{\mathcal{M}}$, the substitution of
$(\Phi', N, P', \mathcal{M})$ in $(\Phi, N, P, \mathcal{M})$ is %
$\replace{ (\Phi, N, P, \mathcal{M}) }{ \mathcal{Y} }{ %
  (\Phi', N, P', \mathcal{M}) } = %
(\Phi \union m \concat \Phi', N, %
P \union m \concat^N P', \mathcal{M})$, where
$m = \inv{ \restrict{N}{ \mathcal{Y} } } \compose P$.


% define refinement relation over types
\paragraph{Joining relational refinement types}

% inference rules that define join:
\begin{figure}
  \centering
  \begin{gather*}
    % join atomics:
    \inference[ ATOMICS ]{
      % 
      E \union E' \subseteq E'' }{
      %
      \tau^A_{\Phi, N, E} \Join \tau^A_{\Phi', N', E'} \subtype %
      \tau^A_{\Phi \Join \Phi'', N \union N', E''} } \\
    % join shared function:
    \inference[ FNS ]{
      % join the nested relational types:
      \tau \Join \tau' \subtype \tau'' }{
      % combine results using relational function,
      \to_x^i \tau \Join \to_x^i \tau' \subtype \to_x^i \tau'' }
    % join shared product:
    \inference[ PROD ]{
      % get refinement for nested type,
      \tau \Join \tau' \subtype \tau'' }{
      % complete type is product
      \times_{i, j}^k \tau \Join %
      \times_{i, j}^k \tau' \subtype \times_{i, j}^k \tau'' } \\
    % join shared sum:
    \inference[ SUM ]{
      % join the lhs's
      \tau_l \Join \tau_l' \subtype \tau_l'' &
      % join the rhs's
      \tau_r \Join \tau_r' \subtype \tau_r'' }{
      % complete type is sum
      \tau_l +^i \tau_r \Join \tau_l' +^i \tau_r' %
      \subtype \tau_l'' +^i \tau_r'' } 
    % join shared lfps:
    \inference[ LFP ]{
      % join types of bodies of lfp's,
      \tau \Join \tau' \subtype \tau'' }{
      % wrap up the result,
      \mu_i X. \tau \Join \mu_i X. \tau' \subtype %
      \mu_i X. \tau'' } \\
    % join unshared function:
    \inference[ FNS-A ]{
      % join the nested relational types:
      \tau \Join \tau' \subtype \tau'' }{
      % combine results using relational function,
      \to_x^i \tau \Join \tau' \subtype \to_x^i \tau'' }
    % join unshared product:
    \inference[ PROD-A ]{
      % get refinement for nested type,
      \tau \Join \tau' \subtype \tau'' }{
      % complete type is product
      \times_{i, j}^k \tau \Join \tau' \subtype %
      \times_{i, j}^k \tau'' } \\
    % join unshared sum:
    \inference[ SUM-A ]{
      % join the lhs's
      \tau_l \Join \tau' \subtype \tau_l'' &
      % join the rhs's
      \tau_r \Join \tau' \subtype \tau_r'' }{
      % complete type is sum
      \tau_l +^i \tau_r \Join \tau' %
      \subtype \tau_l'' +^i \tau_r'' } 
    % join unshared lfp:
    \inference[ LFP-A ]{
      % get refinement for nested type,
      \tau \join \tau' \subtype \tau'' }{
      % wrap lhs type in lfp constructor,
      \mu_i X. \tau \Join \tau' \subtype \tau'' } 
    % join is symmetric on first two component relational types:
    \inference[ SYM ]{ %
      \tau' \Join \tau \subtype \tau'' }{ %
      \tau \Join \tau' \subtype \tau'' } 
  \end{gather*}
  \caption{Inductive inference rules that define the join of two relational types.
    %
    Metavariable $\Phi$ ranges over indexed refinement predicates, %
    $\tau$ ranges over relational refinement types, %
    $i$ ranges over indices, %
    $X$ ranges over least-fixed point variables, and %
    $x$ ranges over program variables. }
  \label{fig:join}
\end{figure}
% give overview:
The join of relational refinement types $\tau$ and $\tau'$ combines
their relationships over common indices.
%
For indices $I$, refinement predicate $\varphi \in \refpreds{I}$, and
all $\tau, \tau', \tau'' \in \reltypes{I}$, the fact that $\tau$ and
$\tau'$ \emph{join to form} $\tau''$ is denoted
$\tau \join{ \varphi } \tau' \subtype \tau''$.

% walk through the rules:
The join operation is defined by the inductive inference rules given
in \autoref{fig:join}.
% atomic relational types:
Rule~ATOMICS establishes that the atomic types defined by %
indexed refinement predicates $\Phi, \Phi' : \idxrefpreds{I}$, %
variable indexings $N, N' : \lfpvars \partto I$, and %
mutual induction relations $E, E' \subseteq \lfpvars \times \lfpvars$
join to form any atomic relational refinement type defined by %
\textbf{(1)} indexed refinement predicates
$\Phi \Join \Phi'' : \idxrefpreds{I}$ such that for each
$Q \in \domain(\Phi)$ and $Q' \in \domain(\Phi')$,
$(\Phi \Join \Phi')(Q \union Q') = \Phi(Q) \land \Phi'(Q')$; %
\textbf{(2)} variable indexing $N \union N'$; %
\textbf{(3)} any equivalence relation
$E'' \subseteq \lfpvars \times \lfpvars$ such that
$E \union E' \subseteq E''$.

% synchronous rules: functions:
Rules~FNS, SUM, PROD, and LFP establish that the join relation is
preserved by the abstraction, sum, production, and least-fixed point
operators over relational refinement types on common indices.
%
For relational refinement types $\tau$, $\tau'$, and $\tau''$, if
$\tau$ joins with $\tau'$ on $\varphi$ to form $\tau''$, then the
abstractions of each of $\tau$ and $\tau'$ at index $i$ join to form
$\tau''$ abstracted at $i$.
% relational sums:
For relational refinement types $\tau_l$, $\tau_l'$, $\tau_l''$,
$\tau_r$, $\tau_r'$, and $\tau_r''$, if %
\textbf{(1)} $\tau_l$ joins with $\tau_l'$ on $\varphi$ to form
$\tau_l''$ and %
\textbf{(2)} $\tau_r$ joins with $\tau_r'$ on $\varphi$ to form
$\tau_r''$, then $\tau_l +^i \tau_r$ joins with $\tau_l' +^i \tau_r'$
to form $\tau_l'' +^i \tau_r''$.
% relational products:
If $\tau$ joins with $\tau'$ on $\varphi$ to form $\tau''$, then %
$\times_{i, j}^k \tau$ joins with $\times_{i, j}^k \tau'$ to form
$\times_{i, j}^k \tau''$.
% relational lfp:
If $\tau$ joins with $\tau'$ on $\varphi$ to form $\tau''$, then %
$\mu_i X. \tau$ joins with $\mu_i X. \tau'$ on $\varphi$ to from
$\mu_i X. \tau''$.

% walkthrough asynchronous rules:
Rules~FNS-A, SUM-A, PROD-A, and LFP-A are defined similarly to
Rules~FNS, SUM, PROD, and LFP, but define the join relation over pairs
of relational refinement types that may not share all indices.
%
Rule~SYM establishes if $\tau$ joins with $\tau'$ to form $\tau''$,
then $\tau'$ joins with $\tau$ to form $\tau''$ as well.
%
I.e., the binary relations defined by fixing the third relational
refinement type in the (ternary) join relation are symmetric.

% define the subtyping relation:
\paragraph{Relational refinement subtypes}
%
\begin{figure}
  \centering
  \begin{gather*}
    % subtype pair of atomic types:
    \inference[ ATOMICS ]{ }{ } \\
    % rules that deconstruct both sides. Relational functions:
    \inference[ FNS ]{
      % if parameter 1 subtypes parameter 0,
      \tau \subtype \tau' }{
      % then function types are subtypes,
      \to_x^i \tau \subtype \to_x^i \tau' } 
    % relational products:
    \inference[ PRODS ]{ \tau \subtype \tau'}{
      \times_{i, j}^k \tau \subtype \times_{i, j}^k \tau'}
    % relational sums:
    \inference[ SUMS ]{
      % if component types subtype each other,
      \tau_l \subtype \tau_l' & \tau_r \subtype \tau_r' }{
      % then sums are subtypes
      \tau_l +^i \tau_r \subtype \tau_l' +^i \tau_r' } \\
    % subtype function with atomic
    \inference[ FNS-A]{ \tau \subtype A }{
      \rightarrow_x^i \tau \subtype A } 
    % subtype atomic with product
    \inference[ PROD-A ]{ \tau \subtype A }{
      \times^k_{i, j} \tau \subtype A }
    % subtype atomic with sum
    \inference[ SUM-A ]{ \tau \subtype A & \tau' \subtype A }{
      \tau +^i \tau' \subtype A } \\
    % lfps:
    \inference[ LFPS ]{}{} 
  \end{gather*}
  \caption{Inductive inference rules that define the subtyping relation over relational refinement types.
    %
    \BH{define metavariables} }
  \label{fig:subtypes}
\end{figure}

\BH{walk through subtyping rules}

\subsubsection{A relational type system}
\label{sec:rel-type-sys}
%
The typing relation from tuples of expressions to relational types is
defined as an instance of a typing relation from sub-expressions to
relational types.
% define context:
A context is a partial map from variables to structural types;
%
i.e., the space of contexts is $\ctxs = \vars \partto \types$.
% define expression positions:
An \emph{expression position} partially identifies the position of an
expression within a larger expression, or within a tuple of
expressions.
%
The space of \emph{expression-position fields} is
$\expposfields = \elts{ \leftchild, \rightchild }$.
%
The space of \emph{expression positions} is
$\exppos = \expposfields^{*}$.
% 
The space of \emph{positioned relational types} is
$\reltypes{\vars \union \exppos}$.

% define typing relation over expressions in terms of positioned
% expressions
For $\Gamma \in \ctxs$, $E : \exppos \partto \expr$, and
$\tau \in \posreltypes$, the fact that $E$ have relational type $\tau$
under $\Gamma$ is denoted $\Gamma, \gamma \judges E : \tau$;
%
the typing relation is defined below.
%
The typing relation over expressions is defined in terms of the typing
relation over positioned expressions.
%
In particular, for each $n \in \nats$, let the
\emph{expression-position encoding} of $n$ be
$\pos{n} = \leftchild \cons \rightchild^{n}$.
%
Then for all $e_0, \ldots, e_{n - 1} \in \expr$ and
$\tau \in \reltypes{ e_0, \ldots, e_{n - 1} }$, the typing relation
$e_0, \ldots, e_{n - 1} : \tau$ is
\[ \cdot \judges [ \pos{0} \mapsto e_0, \ldots, \pos{n - 1} \mapsto
  e_{n - 1} ] : %
  \rename{ \tau }{ e_0, \ldots, e_{n - 1} }{ %
    \pos{0}, \ldots, \pos{n - 1} } \]

% typing judgments:
\begin{figure}
  \centering
  \begin{gather*}
    % empty:
    \inference[ EMPTY ]{ }{
      % the empty map of expressions has relational type true
      \Gamma \judges \cdot : \tau_{\emptyset} } 
    % unit:
    \inference[ UNIT ]{
      % get types for remainder,
      \Gamma \judges E : \tau & %
      \tau \Join \tau_1^p \subtype \tau' }{ %
      \Gamma \judges \upd{ E }{ p }{ \unit } : \tau' } 
    % constant:
    \inference[ CONST ]{ %
      % remainder has type tau,
      \Gamma \judges E : \tau &
      \tau \Join \tau_c^p \subtype \tau' }{ %
      \Gamma \judges \upd{ E }{ p }{ c } : %
      \tau' } \\
    % base operation:
    \inference[ OP ]{ %
      % remainder has type tau,
      \Gamma \judges %
      \upd{ E }{ \leftchild \cons p, \rightchild \cons p }{ %
        e_0, e_1 } : \tau \\
      \tau \Join \tau_{\leftchild \cons p \oplus \rightchild \cons
        p}^p \subtype \tau' }{ %
      \Gamma \judges \upd{ E }{ p }{ e_0 \oplus e_1 } : \tau' }
    % base pred:
    \inference[ PRED ]{ %
      % remainder has type tau,
      \Gamma \judges %
      \upd{ E }{ \leftchild \cons p, \rightchild \cons p }{ %
        e_0, e_1 } : \tau \\
      \tau \Join \tau_{\leftchild \cons p \otimes \rightchild \cons
        p}^p \subtype \tau' }{ %
      \Gamma \judges \upd{ E }{ p }{ e_0 \otimes e_1 } : \tau' } \\
    % abstraction:
    \inference[ ABS ]{ 
      % extend the context and typecheck the body,
      \upd{ \Gamma }{ x }{ \sigma } \judges %
      \upd{ E }{ p }{ e } : \tau }{ %
      % type of abstraction is
      \Gamma \judges \upd{ E }{ p }{ \abs{ x }{ \sigma }{ e } } : %
      \to^p_x \tau } 
    % application:
    \inference[ APP ]{ %
      % get type of abstraction,
      \Gamma \judges \upd{E}{p}{e_0} : \to^p_x \tau &
      % get type of argument that is the parameter type,
      \Gamma \judges \upd{E}{p}{e_1} : \tau' \\
      \tau \Join \rename{ \tau' }{ p }{ x } \subtype \tau'' }{
      % return the result type
      \Gamma \judges \upd{ E }{ p }{e_0\ e_1} : \tau'' } \\
    % pairing:
    \inference[ PAIR ]{
      % get type of both expressions,
      \Gamma \judges %
      E[ \leftchild \cons p \mapsto e_0, %
      \rightchild \cons p \mapsto e_1 ] : \tau }{
      % then type of pair is
      \Gamma \judges \upd{E}{p}{ \pair{e_0}{e_1} } :
      \times_{\leftchild \cons p, \rightchild \cons p}^p \tau } 
    % let:
    \inference[ LET ]{
      % get type of bound expression,
      \Gamma \judges \epsilon \mapsto e_0 : %
      \times_{x, y}^{\epsilon} \tau &
      % get type of result under context that binds to x and y,
      \Gamma \judges \upd{ E }{ p }{ e_1 } : \tau' \\
      \tau \Join \tau' \subtype \tau'' }{
      % then complete let expression has type
      \Gamma \judges \upd{E}{p}{ %
        \letexp{x}{\sigma_x}{y}{\sigma_y}{e_0}{e_1} } : %
      \tau'' } \\
    % left injection:
    \inference[ LEFT ]{
      % get type of the nested exp,
      \Gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma \judges \upd{E}{p}{ \injl\ e} : %
      \tau +^p \tau' } 
    % right injection:
    \inference[ RIGHT ]{
      % get type of the nested exp,
      \Gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma \judges \upd{E}{p}{ \injr\ e} : %
      \tau' +^p \tau } \\
    % match:
    \inference[ MATCH ]{
      % get type of matched exp,
      \Gamma \judges \epsilon \mapsto e_0 : %
      \tau_0^l +^\epsilon \tau_0^r \\
      % get type of left branch under context that binds x to left op,
      \Gamma \judges \upd{ E }{ p }{ e_1 } : \tau_1 & %
      \rename{ \tau_0^l }{ \epsilon }{ x } \Join \tau_1 \subtype \tau' \\
      % get type of right branch under context that binds y to right op,
      \Gamma \judges \upd{ E }{ p }{ e_2 } : \tau_2 & %
      \rename{ \tau_0^r }{ \epsilon }{ y } \Join \tau_2 \subtype \tau' }{
      % then type of match exp is type of both branches,
      \Gamma \judges %
      \upd{E}{p}{ \matchexp{e_0}{ x }{\sigma_x}{e_1}{ y }{\sigma_y}{e_2} } : \tau' }
    % vars:
    \inference[ VAR ]{ %
      \Gamma \judges E : \tau & %
      \iseq{p}{x}(\Gamma(x), \tau') \\
      \tau \Join \tau' \subtype \tau'' }{ %
      \Gamma \judges \upd{ E }{ p }{ x } : \tau'' } \\
    % fixpoint:
    \inference[ FIX ]{
      % get type of body under context that binds symbol to tau,
      \upd{ \Gamma }{ f }{ \sigma } \judges %
      \upd{ E }{ p }{ e } : \tau \\
      % constrain that tau implies the result is fixpoint variable,
      \iseq{p}{f}(\sigma, \tau') & \tau \subtype \tau' }{ %
      \Gamma \judges \upd{ E }{ p }{ \fix{f}{\sigma}{e} }: \tau }
    % unfold:
    \inference[ UNFOLD ]{
      % if expressions have tau unfolded at p,
      \Gamma \judges E : %
      \replace{ \tau }{ \mathcal{X} }{ \tau } }{ 
      % then expressions have folded type
      \Gamma \judges E : \mu_{\mathcal{X}}. \tau } 
    % subtype:
    \inference[ SUB ]{
      % if expressions have tau,
      \Gamma \judges E : \tau &
      % and tau subtypes tau',
      \tau \subtype \tau' }{ %
      % then expressions have type tau'
      \Gamma \judges E : \tau' }
  \end{gather*}
  \caption{A typing system for relational types.
    %
    Metavariable %
    $\Gamma$ ranges over contexts, %
    $E$ ranges over positioned expressions, %
    $p$ ranges over expression positions, %
    $e$ ranges over expressions, %
    $\oplus$ ranges over binary operations, %
    $\otimes$ ranges over binary predicates, %
    $\sigma$ ranges over structural types, %
    $\tau$ ranges over relational refinement types, %
    $c$ ranges over constants, %
    $x$, $y$, and $f$ range over variables, and %
    $\mathcal{X}$ ranges over sets of least-fixed-point variables. }
  \label{fig:reltypes-rules}
\end{figure}

% define judgment:
The typing relation over positioned expressions is defined by the
inductive inference rules given in \autoref{fig:reltypes-rules}.
%
The inference rules consist of syntax-directed rules that define the
typing relation for arbitrary expressions in a collection of
positioned expressions, along with rules that define the typing
relation for special cases of positioned expressions, unfold
least-fixed point types, and use the subtype relation.
% empty:
Rule~EMPTY establishes that the empty positioned expressions (denoted
$\cdot$) have the empty positioned relational type $\tau_{\emptyset}$,
which is the unique atomic relational type over the empty spaces of
indices and least-fixed-point variables.

% unit:
Rule~UNIT establishes that if positioned expressions $E$ have type
$\tau$, then $E$ extended to bind position $p$ to the unit expression
have type $\tau$ joined with $\tau_1^p$, the unit atomic type at $p$.
%
$\tau_1^p$ is unique the atomic type over indices $[ p ]$ and the
empty space of least-fixed point variables defined by the indexed
refinement predicates that only bind $\elts{ (p, \epsilon) }$ to the
refinement predicate $\true$.

% const:
Rule~CONST establishes that if $E$ have type $\tau$, then $E$ extended
to bind $p$ to constant $c$ have type $\tau$ joined with $\tau_c^p$,
the atomic type that binds $c$ to $p$.
%
$\tau_c^p$ is the unique atomic type over indices $[ p ]$ and the
empty space of least-fixed point variables defined by indexed
refinement predicates that only bind $\elts{ (p, \epsilon) }$ to
refinement predicate $(p, \epsilon) = c$.

% op:
Rule~OP establishes that if $E$ extended to bind positions
$\leftchild \cons p$ and $\rightchild \cons p$ to expressions $e_0$
and $e_1$ have type $\tau$, then $E$ extended to bind $p$ to
$e_0 \oplus e_1$ have type $\tau$ joined with
$\tau_{\leftchild \cons p \oplus \rightchild \cons p}^p$, the atomic
type that binds $p$ to $\oplus$ over $\leftchild \cons p$ and
$\rightchild \cons p$.
%
$\tau_{\leftchild \cons p \oplus \rightchild \cons p}^p$ is the unique
atomic type over indices
$\elts{ (p, \epsilon), (\leftchild \cons p, \epsilon), (\rightchild
  \cons p, \epsilon) }$ and the empty set of least-fixed point
variables defined by the indexed refinement predicates that only bind
$\elts{ (p, \epsilon), (\leftchild \cons p, \rightchild \cons p) }$ to
refinement predicate
$(p, \epsilon) = (\leftchild \cons p, \epsilon) \oplus (\rightchild
\cons p, \epsilon)$.

% preds:
Rule~PRED establishes that if $E$ extended to bind positions
$\leftchild \cons p$ and $\rightchild \cons p$ to expressions $e_0$
and $e_1$ have type $\tau$, then $E$ extended to bind $p$ to
$e_0 \otimes e_1$ have type $\tau$ joined with
$\tau_{\leftchild \cons p \otimes \rightchild \cons p}^p$, the atomic
type that binds $p$ to $\otimes$ over $\leftchild \cons p$ and
$\rightchild \cons p$.
%
$\tau_{\leftchild \cons p \otimes \rightchild \cons p}^p$ is the
unique atomic type over indices
$\elts{ (p, \epsilon), (\leftchild \cons p, \epsilon), (\rightchild
  \cons p, \epsilon) }$ and the empty set of least-fixed point
variables defined by the indexed refinement predicates that only bind
\textbf{(1)}
$\elts{ (p, [ \tyleftsum ]), (\leftchild \cons p, \rightchild \cons p)
}$ to refinement predicate
$(\leftchild \cons p, \epsilon) \otimes (\rightchild \cons p,
\epsilon)$ and bind \textbf{(2)}
$\elts{ (p, [ \tyrightsum ]), (\leftchild \cons p, \rightchild \cons
  p) }$ to the refinement predicate
$\lnot (\leftchild \cons p, \epsilon) \otimes (\rightchild \cons p,
\epsilon)$.

% abs:
Rules~ABS and APP are defined using the relational function type
operator.
%
Rule~ABS establishes that if $E$ extended to bind $p$ to expression
$e$ have type $\tau$, then $E$ extended to bind $p$ to $\lambda x. e$
is a relational abstraction of $\tau$ at $p$ over $x$.
% app:
Rule~APP establishes that if %
\textbf{(1)} $E$ extended to bind $p$ to $e_0$ is a relational
abstraction of $\tau$ at $p$ over $x$ and %
\textbf{(2)} $E$ extended to bind $p$ to $e_1$ have type $\tau'$, then
$E$ extended to bind $p$ to $e_0$ applied to $e_1$ have $\tau$ joined
with $\tau'$ renamed from $p$ to $x$.

% relational prod:
Rules~PAIR and LET are defined using the relational product type
operator.
% pair:
Rule~PAIR establishes that if $E$ extended to bind
$\leftchild \cons p$ and $\rightchild \cons p$ to $e_0$ and $e_1$ have
type $\tau$, then $E$ extended to bind $p$ to $\pair{ e_0 }{ e_1 }$
has as a type the relational product of $\tau$ from
$\leftchild \cons p$ and $\rightchild \cons p$ to $p$.
% let:
Rule~LET establishes that if %
\textbf{(1)} $e_0$ has as a relational type the relational product of
$\tau$ from variables $x$ and $y$ to the empty position;
%
\textbf{(2)} $E$ extended to bind $p$ to $e_1$ have type $\tau'$, then
$E$ extended to bind $p$ to
$\letexp{x}{\sigma_x}{y}{\sigma_y}{e_0}{e_1}$ has type $\tau$ joined
with $\tau'$.

% relational sum:
Rules~LEFT, RIGHT, and MATCH are defined using the relational sum type
operator.
% left:
Rule~LEFT establishes that if $E$ extended to bind $p$ to $e$ have
type $\tau$, then $E$ extended to bind $p$ to the left injection of
$e$ is a relational sum at $p$ of $\tau$ and arbitrary relational type
$\tau'$.
%
Rule~RIGHT is defined symmetrically to Rule~LEFT.
% match:
Rule~MATCH establishes that if %
\textbf{(1)} $e_0$ is the relational sum at $\epsilon$ of $\tau_0^l$
and $\tau_0^r$;
% 
\textbf{(2)} $E$ extended to bind $p$ to $e_1$ has type $\tau_1$ that
joins with $\tau_0^l$ with $\epsilon$ renamed to $x$ to form $\tau'$;
%
\textbf{(3)} $E$ extended to bind $p$ to $e_2$ has type $\tau_2$ that
joins with $\tau_0^r$ with $\epsilon$ renamed to $y$ to form $\tau'$,
then $E$ extended to bind $p$ to
$\matchexp{e_0}{x}{\sigma_x}{e_1}{y}{\sigma_y}{e_2}$ has type
$\tau'$.

% var:
Rule~VAR establishes that if %
\textbf{(1)} $E$ have type $\tau$ and %
\textbf{(2)} $\tau'$ is a relational type in which $p$ has structure
$\Gamma(x)$ (denoted as stating that $\Gamma(x)$ and $\tau'$ hold the
property the relation $\iseq{p}{f}$), then %
$E$ extended to bind $p$ to
$x$ have type $\tau$ joined with the type $\tau_{x : \Gamma(x)}^p$,
which binds $p$ to variable $x$ of type $\Gamma(x)$.
%
The type property $\iseq{p}{f}$ is defined below.
% fix:
Rule~FIX establishes that if %
\textbf{(1)} $E$ extended to bind $p$ to $e$ has type $\tau$; %
\textbf{(2)} $\tau'$ asserts that $p$ and $f$ are equivalent with
structural type $\sigma$ (i.e., $\sigma$ and $\tau'$ hold the property
$\iseq{p}{f}$); %
\textbf{(3)} $\tau$ is a subtype of $\tau'$, then %
$E$ extended to bind $p$ to $\fix{f}{p}{e}$ have type $\tau$.
% unfold:
Rule~UNFOLD establishes that if $E$ has type $\tau$ unfolded on
least-fixed-point variables $\mathcal{X}$, then $E$ have type $\tau$.
% sub:
Rule~SUB establishes that if $E$ have type $\tau$ a subtype of $\tau'$,
then $E$ has type $\tau'$.

\paragraph{Constraining equivalence over indices}
%
The typing system in \autoref{fig:reltype-rules} assigns types to
occurrences of variables and to fixpoint expressions using a property
over structural and relational types, namely that relational type
$\tau$ constrains that indices $i$ and $j$ are equivalent over
structural type $\sigma$.
%
We now define this property over types in terms of two auxiliary
relations that define \textbf{(1)} when a relational type $\tau$ holds
a structural type $\sigma$ at a given index and \textbf{(2)} when
relational type $\tau'$ constrains that copies of a relational type
$\tau$ at given indices are equivalent.

% inference rules that define relational type of a structural type:
\begin{figure}
  \centering
  \begin{gather*}
    \inference[ ATOMS ]{
      % for each subset of sets of positions,
      \mathcal{ Q } \subseteq \pset(\domain(A)) }{
      % 
      A \hasreltype{i} \tau^A_{ \Phi_Q^{\true}, N_A, E } } 
    % structural functions:
    \inference[ FN ]{ 
      % get relational types of parameter, result
      \upd{ T }{ %
        \leftchild \cons p, \rightchild \cons p }{ %
        \sigma_{\alpha}, \sigma_{\nu} } \hasreltype{i} \tau }{
      % construct relational function type
      \upd{ T }{ p }{ \sigma_{\alpha} \to \sigma_{\nu} } \hasreltype{i}
      \to^i_x \tau } 
    % structural products:
    \inference[ PROD ]{
      % get relational types of components,
      \upd{ T }{ %
        \leftchild \cons p, \rightchild \cons p }{ %
        \sigma_l, \sigma_r } \hasreltype{i} \tau }{
      % construct relational product type
      \upd{ T }{ p }{ \sigma_l \times \sigma_r } \hasreltype{i}
      \times_{ \leftchild \cons i, \rightchild \cons i }^{i} \tau } \\
    % structural sum:
    \inference[ SUM ]{
      % get relational type of lhs,
      \upd{ T }{ p }{ \sigma_l } \hasreltype{i} \tau_l &
      % get relational type of rhs,
      \upd{ T }{ p }{ \sigma_r } \hasreltype{i} \tau_r }{
      % combine results mutual sum:
      \upd{ T }{ p }{ \sigma_l + \sigma_r } \hasreltype{i}
      \tau_l +^{i} \tau_r } 
    % structural lfp:
    \inference[ LFP ]{
      % get relational type of nested type,
      \upd{ T }{ p }{ \sigma } \hasreltype{i} \tau }{
      % operate using the lfp operator
      \upd{ T }{ p }{ \mu X. \sigma } \hasreltype{i}
      \mu_i X. \tau }
  \end{gather*}
  \caption{Inductive inference rules that define conditions under which a relational type is a relational type of a structural type.
    %
    Metavariable %
    $A$ ranges over atomic structual types, %
    $E$ ranges over equivalence relations over $\lfpvars$, %
    $T$ ranges over maps from type positions to structural types, %
    $p$ ranges over type positions, %
    $\tau$ ranges over relational types, %
    $\sigma$ ranges over structural types, %
    $i$ ranges over indicies $I$, %
    $x$ ranges over $\vars$, and %
    $X$ ranges over $\lfpvars$. }
  \label{fig:struct-rel}
\end{figure}

% define judgment:
\autoref{fig:struct-rel} contains a set of inductive inference rules
that define the fact that relational type
$\tau \in \reltypes{ \add{i}{ \vars } }$ is a relational type of
structural type $\sigma$ at index $i$, denoted
$\sigma \hasreltype{i} \tau$.
%
The relation is defined in terms of a relation from relates structural
types in an alternative representation as maps from type positions to
structural types.
%
For $\Sigma: \typos \partto \types$, the fact that $\Sigma$ is related
to relational refinement type $\tau$ at $i$ is denoted
$\Sigma \hasreltype{i} \tau$.
%
The relation over structural types is defined to be
$\sigma \hasreltype{i} \tau \equiv \iseq{i}{j}(\epsilon \mapsto \sigma,
\tau)$.

% walk through the rules
The has-relational-type relation is defined by the inductive inference
rules given in \autoref{fig:struct-rel}.
%
Rule~ATOMS defines the correspondence for maps to atomic structural
types.
% define atomic maps:
For $A : \typos \partto \types$ if the range of $A$ consists of only
atomic structual types, then $A$ itself is \emph{atomic}.
% define relational refinement type:
For each $\mathcal{Q} \subseteq \pset(\domain(A))$, let
$\Phi_Q^{\true} = \mathcal{Q} \to \true$.
% var indexing,
$N_A : \lfpvars \partto \typos$ such that for each $p \in \domain(A)$,
it holds that $N_A(A(p)) = p$; %
% 
and each equivalence class $E \in \equiv_{\lfpvars}$, $A$ has as a
relational type the atomic type defined by $\Phi_Q^{\true}$, $N_A$,
and $E$.

% functions:
Rule~FN establishes that for $T : \typos \partto \types$,
$p \in \typos$, $\sigma_{\alpha}, \sigma_{\nu} \in \types$, and
$\tau$, if $T$ extended to map type positions $\leftchild \cons p$ and
$\rightchild \cons p$ to $\sigma_{\alpha}$ and $\sigma_{\nu}$
respectively has relational type $\tau$, then $T$ extended to bind $p$
to $\sigma_{\alpha} \to \sigma_{\nu}$ has relational type $\tau$
abstracted over $x$ at $i$.
% products
Rule~PROD establishes that if $T$ extended to bind
$\leftchild \cons p$ and $\rightchild \cons p$ to structural types
$\sigma_l$ and $\sigma_r$ respectively has relational type $\tau$,
then $T$ extended to map $p$ to $\sigma_l \times \sigma_r$ has
relational product of $\tau$ from $\leftchild \cons i$ and
$\rightchild \cons i$ to $i$ has relational type $\tau$.

% sums:
Rule~SUM establishes that if %
\textbf{(1)} $T$ extended to map $p$ to $\sigma_l$ has relational type
$\tau_l$ and %
\textbf{(2)} $T$ extended to map $p$ to $\sigma_r$ has relational type
$\tau_r$, then %
$T$ extended to bind $p$ to $\sigma_l +^{i, j} \sigma_r$ has the sum
of $\tau_l$ and $\tau_r$ at $i$.
%
Rule~LFP establishes that if %
$T$ extended to map $p$ to $\sigma$ has relational type $\tau$, then
$T$ extended to bind $p$ to $\mu X. \sigma$ has
$\mu_i X. \mu_j X. \tau$.

% inference rules that define relational type of a structural type:
\begin{figure}
  \centering
  \begin{gather*}
    \inference[ ATOMS ]{ }{ %
      \tau^A_{\Phi, N, E} \copyrel{i}{j} %
      \tau^A_{\Phi'_{i, j}, N_{i, j}, E_{i, j}} } 
    % structural functions:
    \inference[ FN ]{ 
      % get relational types of parameter, result
      \tau \copyrel{i}{j} \tau' }{
      % construct relational function type
      \to_x^a \tau \copyrel{i}{j} \to_x^a \tau' } 
    % structural products:
    \inference[ PROD ]{
      % get relational types of components,
      \tau \copyrel{i}{j} \tau' }{
      \times_{a, b}^c \tau \copyrel{i}{j} \times_{a, b}^c \tau' } \\
    % structural sum:
    \inference[ SUM ]{
      % get relational type of lhs,
      \tau_l \copyrel{i}{j} \tau_l' & %
      \tau_r \copyrel{i}{j} \tau_r' }{
      % combine results mutual sum:
      \tau_l +^a \tau_r \copyrel{i}{j} \tau_l' +^a \tau_r' }
    % structural lfp:
    \inference[ LFP ]{
      % get relational type of nested type,
      \tau \copyrel{i}{j} \tau' }{
      % operate using the lfp operator
      \mu_a X. \tau \copyrel{i}{j} \mu_a X. \tau' }
  \end{gather*}
  \caption{Inductive inference rules that define when relational type $\tau'$ constrains that a copies of $\tau$ at $i$ are equal at $i$ and $j$.
    %
    Metavariable $\tau$ ranges over relational refinement types, %
    $a$, $b$, and $c$ range over $\add{i}{\vars}$, and %
    $X$ ranges over $\lfpvars$. }
  \label{fig:ctr-eq}
\end{figure}
%
\autoref{fig:ctr-eq} defines conditions under which relational type
$\tau'$ contains that copies of relational type $\tau$ at indices $i$
and $j$ are equivalent.
%
Rules~FN, SUM, PROD, and LFP establish that the relation is preserved
over relational type operations.
%
Rule~ATOMIC relates the atomic relational type defined by, for some
$X \subseteq \vars$ $I = \add{i}{X}$, indexed refinement predicates
$\Phi : \idxrefpreds{ I }$, %
$N : \lfpvars \partto I$, and for $\mathcal{X} = \domain(N)$,
$E \subseteq \mathcal{X} \times \mathcal{X}$, to the atomic relational
predicate over indices $I' = I \union \add{ j }{ \vars_j }$ defined by
the following indexed refinement predicates $\Phi'$, least-fixed-point
mapping $N'$, and equivalence relation $E'$ over least-fixed point
variables.
%
$X_j \subseteq \vars$ denotes a disjoint copy of $X$ such that for
each $x \in X$, there is a corresponding $x_j \in X_j$, and
$\mathcal{X} \subseteq \lfpvars$ denotes a disjoint copy of
$\mathcal{X}$ such that for each $X \in \mathcal{X}$ there is a
corresponding $X_j \in \mathcal{X}$.
% define indexed refinement predicates:
$\Phi' : I' \partto \idxrefpreds{ I' }$ is such that for each
$Q \subseteq \idxpos{ I }$ in the domain of $\Phi$, $\Phi'$ binds the
indexed type positions
$\setformer{ (i, p), (j, p) }{ p \in \typos, (i, p) \in Q } \union
\setformer{ (x_j, p) }{ x \in \vars, p \in \typos }$ to refinement predicate
\[ \Phi(Q) \bigland_{p \in \typos} (i, p) = (j, p) \land %
  \bigland_{ x \in \vars } (x, p) = (x_j, p) \]
% define variable indexing:
$N' : \lfpvars \partto I'$ is such that %
for each $i \in I$, $N'(i) = N(i)$; %
if $i \in \domain(N)$, then $N'(j) = N(i)_j$;
for each $x \in \vars$, $N'(x_j) = N'(x)_j$.
% define equivalence class
$E' \subseteq \lfpvars \times \lfpvars$ is the reflexive, symmetric,
transitive closure of
$E \union \setformer{ (X, X_j) }{ X \in \mathcal{ X } }$.

% connect it back to typing rules:
For indices $i$ and $j$, structural type $\sigma$, and relational type
$\tau$, $\tau$ constrains equivalence from $i$ to $j$ over $\sigma$ if
there is some $\tau'$ such that \textbf{(1)} $\tau'$ is a structural
type of $\sigma$ at $i$ (i.e., $\sigma \hasreltype{i} \tau'$) and
\textbf{(2)} $\tau$ constrains equality of copies of $\tau$ at $i$ and
$j$.

% main lemma of the typing system:
\subsubsection{Correctness}
\label{sec:corr}

The typing relation is preserved by the evaluation relation.
%
\begin{lemma}
  \label{lemma:preservation}
  For all $e_0, \ldots, e_n$, $v_0, \ldots, v_n \in \values$ such that
  $v_0 \evalsto v_0, \ldots, e_n \evalsto v_n$, and
  $\tau \in \reltypes{e_0, \ldots, e_n}$ such that
  $e_0, \ldots, e_n : \tau$, it holds that $v_0, \ldots, v_n : \tau$.
\end{lemma}
%
One proof of \autoref{lemma:preservation} uses proof by induction on
%
\BH{complete}

\subsection{Inferring relational refinement types}
\label{sec:infer}
%
A key contribution of our work is a type-inference algorithm for
relational refinement types, named \sys.
%
\sys, given expressions $e_0, \ldots, e_n$ and relational refinement
type $\tau$, attempts to determine if $e_0, \ldots, e_n : \tau$.
%
This section defines collections of relational refinement types over
sub-expressions maintained by \sys (\autoref{sec:bnd-unfoldings}).
%
The section then defines a type-inference algorithm that synthesizes
such collections of relational refinement types
(\autoref{sec:infer-alg}).

\subsubsection{Relational types of sub-expressions}
\label{sec:bnd-unfoldings}
%
\sys, given expressions $e_0, \ldots, e_n$ and relational type
$\tau \in \reltypes{e_0, \ldots, e_n}$, attempts to determine if
$e_0, \ldots, e_n : \tau$ by finding types of expansions of
$e_0, \ldots, e_n$.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $e \in \expr$, the \emph{unfoldings} of $e$, denoted
  $\unfoldings{ \fix{f}{\sigma}{e} }$ are defined inductively as follows:
  %
  \begin{enumerate}
  \item % expression is unfolding
    $e \in \unfoldings{ e }$;
  \item % replacement:
    For $e \in \expr$ and $e' \in \unfoldings{e}$ that contains
    subexpressions
    $\fix{f_0}{\sigma}{e_0}, \ldots, \fix{f_n}{\sigma}{e_n}$
    $\replace{e'}{f_0, \ldots, f_n}{ \fix{f_0}{\sigma}{e_0}, \ldots,
      \fix{f_n}{\sigma}{e_n} }$.
  \end{enumerate}
\end{defn}
%
\BH{give examples}

% type-inference algorithm:
\subsubsection{A procedure for inferring relational refinement types}
\label{sec:infer-alg}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$e_0, \ldots, e_n \in \expr$ and
    $\tau \in \reltypes{e_0, \ldots, e_n}$.}
  % Output: decision for safety
  \Output{A decision whether $e_0, \ldots, e_n : \tau$ holds.}
  % infer: top-level procedure
  \myproc{ $\sys(e_0, \ldots, e_n, \tau)$ %
    \label{line:infer-begin} }{ %
    % infer helper procedure,
    \myproc{$\inferaux(e_0', \ldots, e_n')$ %
      \label{line:infer-aux-begin} }{ %
      % try to infer types for the bounded unfoldings,
      \Switch{$\inferbnd(e_0', \ldots, e_n', \tau)$ %
        \label{line:infer-bnd} }{
        % if inference returns bottom, give up
        \lCase{$\bot$}{ 
          % then expressions don't have the type
          \Return{$\false$} \label{line:ret-no-has-ty} }
        % if inference returns relational types,
        \Case{$T \in \subexptypes{ e_0, \ldots, e_n }{ \tau }$ %
          \label{line:subexp-types} }{ %
          % then check if they're inductive:
          \lIf{$\chkinductive(e_0, \ldots, e_n, T)$ %
            \label{line:chk-ind} }{ 
            \Return{ $\true$ } \label{line:ret-eq} } %
          \lElse{ %
            \Return{ $\inferaux(\unfoldexp(e_0'), \ldots, %
              \unfoldexp(e_n))$ } \label{line:recurse} }
        } %
      } \label{line:infer-aux-end} }
    \Return{$\inferaux(e_0, \ldots, e_n)$ %
      \label{line:infer-base} }
  }
  % 
  \caption{ \sys: a type-inference procedure that uses procedures
    \inferbnd, \chkinductive, and \unfoldexp. }
  \label{alg:infer}
\end{algorithm}
\end{figure}

% inference procedure top-level:
The type-inference procedure \sys is given in \autoref{alg:infer}.
%
\sys (\autoref{alg:infer}) expressions $e_0, \ldots, e_n \in \expr$
and relational type $\tau \in \reltypes{e_0, \ldots, e_n}$, attempts
to decide if $e_0, \ldots, e_n : \tau$.
%
\sys uses a procedure \inferaux
(\autoref{line:infer-aux-begin}---\autoref{line:infer-aux-end}) that,
given unfoldings $e_0', \ldots, e_n'$ of $e_0, \ldots, e_n$ attempts
to determine if $e_0, \ldots, e_n : \tau$ by finding relational types
over fixpoint expressions in $e_0, \ldots, e_n$ based on relational
types of $e_0', \ldots, e_n'$.
%
\sys, given $e_0', \ldots, e_n'$, calls procedure \inferbnd on
$e_0', \ldots, e_n'$ and $\tau$ (\autoref{line:infer-bnd}), which
returns either $\bot$ to denote that $e_0', \ldots, e_n'$ do not have
type $\tau$ or $T \in \subexptypes{ e_0, \ldots, e_n' }{ \tau }$.
% case: bounded does not have type,
If \inferbnd returns $\bot$, then \sys returns that
$e_0, \ldots, e_n : \tau$ (\autoref{line:ret-no-has-ty}).

% case: bounded has type,
If \inferbnd returns sub-expression types $T$
(\autoref{line:subexp-types}), then \inferaux calls procedure
\chkinductive on $e_0, \ldots, e_n$ and $T$, which soundly determines
if $e_0, \ldots, e_n : \tau$ by assigning types of fixpoint
subexpressions of $e_0, \ldots, e_n$ that are relational subtypes of
their unfoldings in $e_0', \ldots, e_n'$.
%
If \chkinductive determines that $e_0, \ldots, e_n : \tau$, then \sys
determines that $e_0, \ldots, e_n : \tau$ (\autoref{line:ret-eq}).
%
Otherwise, \chkinductive constructs expressions
$e_0' \unfolding \unfold(e_0', e_0) \unfolding e_0, \ldots, e_n'
\unfolding \unfold(e_n', e_n) \unfolding e_n$, recurses on the result,
and returns the result of the recursion
(\autoref{line:infer-recurse}).

% sketch unfolding operations:
The procedure \unfoldexp is straightforward to implement.
%
One implementation of \unfoldexp, given $e \in \expr$, iteratively
replaces each occurrence of fixpoint variable $f$ in $e$ with
$\fix{f}{\sigma}{e'}$, where $\fix{f}{\sigma}{e'}$ is a sub-expression
of $e$.
%
The procedures \inferbnd and \chkinductive are defined below.

\paragraph{Typing subexpressions of bounded expressions}
\label{sec:type-bnd}
% give an overview:
\verifybnd, given $\cc{P}_0' \in \unfoldings{ \cc{P}_0 }$ and
$\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$, either returns types of the
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$ or returns $\nonequiv$
to denote that $\cc{P}_0' \not\equiv \cc{P}_1'$.
%
\verifybnd reduces this problem to solving a CHC system
(\autoref{sec:chcs}).
%
Each solution of the system defines types and contexts of
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$.
%
The clauses of the system correspond to rules for establishing types
of expressions (\autoref{fig:reltypes-rules}).

% give the construction in detail:
\BH{update}
%
\verifybnd generates the following CHC system $\mathcal{C}_{
  \cc{P}_0', \cc{P}_1' }$.
% define the space of relational predicates
Let $E \subseteq \subexps{ \cc{P}_0' } \union \subexps{ \cc{P}_1' }$.
% define relational predicates of a set of types:
For typed symbols $T$, let the set of relational predicates
$\symrelpreds{ T }$ be defined as follows.
% base case: T is the empty set of types:
If $T = \emptyset$, then $R_T = \emptyset$.
% inductive case: T is a non-empty set
Otherwise, let $R$ be such that for all $\tau_0, \ldots, \tau_n, \tau'
\in \reftypes$ such that $\tau = \tau_0 \rightarrow \ldots \rightarrow
\tau_n \rightarrow \tau'$, $R$ has variables corresponding to
$\tau_0$, \ldots, $\tau_n$, and $\tau'$.
%
Let $T'$ be collection of typed symbols in which each symbol is a pair
of a typed symbol $f \in T$ and the position of a higher-order
argument type in the type of $f$ in $T$.
%
Then $\symrelpreds{ T } = \add{ \symrelpreds{ T' } }{ R }$.

% define type of a context:
Let $\Gamma : E \times \vars \to \types$ map each $e \in E$ and each
$x \in \freevars(e)$ to its type in $e$, and let $R_E^{\Gamma} =
\symrelpreds( \Gamma )$.
%
Let $T : E \to \types$ map each $e \in E$ to its type under its
context in $\cc{P}_0$ or $\cc{P}_1$.
%
\BH{define all notions of base types in programs correctly}
%
Let $R_E = \symrelpreds(\Gamma \union T)$.
%
The relational predicates of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$
are $\bigunion \setformer{ R_E^{\Gamma} \union R_E }{ E \in
  \antichains{ \cc{P}_0' }{ \cc{P}_1' }}$.

% define clauses
The clauses of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$ are defined as
follows.
%
\BH{define clauses for each relational type}

% define join of relational predicates:
For $\mathcal{R}, \mathcal{R}', \mathcal{R}''$,
%
\BH{patch}
%
, the clauses $\mathcal{R}\andsub(E_0, E_1, E')$ and $\orsub(E_0, E_1,
E')$ constrain that the conjunction (and similarly, disjunction) of
the relational types defined by interpretations of $\symrelpreds(E_0)$
and the interpretations of $\symrelpreds(E_1)$ is a subtype of the
interpretation of the $\symrelpreds(E')$.
%
I.e., if $R$
%
\BH{define clauses for subtype of conjunction (and
  disjunction). Maybe need to structure relational predicates in
  sequences.}
%
Such clauses are denoted $\mathcal{R} \joinctr \mathcal{R}' \subtype
\mathcal{R}''$.

\BH{remove indices}

% enumerate clauses per form of expression:
\verifybnd generates clauses that model each of the syntax-directed
typing rules given in (\autoref{fig:reltype-rules}).
% sets of atomic expressions:
For all $E_0 \subseteq \subexps{ P_0 }$ and $E_1 \subseteq \subexps{
  P_1 }$ such that $E_0$ and $E_1$ contain only atomic expressions,
\verifybnd generates the following clauses:
%
$\mathcal{R} \joinctr %
\bigland \setformer{ c = (c, i) }{ c \in \consts, i \in I, (c, i) \in E
} \subtype \mathcal{R}'$.

% clauses for op:
Let $e_0, e_1 \in \subexps{ \cc{P}_0 }$ such that $e_0 \oplus e_1
\in \subexps{ P_0 }$, %
$E_0 \subseteq \subexps{ P_0 }$, and %
$E_1 \subseteq \subexps{ P_1 }$.
%
\verifybnd generates the clauses
\begin{align*}
  % constrain contexts,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % subtyping of expression types:
  \mathcal{R}, %
  \resvar{e_0 \oplus e_1} = \resvar{e_0} \oplus \resvar{e_1} &
  \subtype \mathcal{R}'
\end{align*}
%
\BH{define subtyping constraint syntax over ops}
%
Similar clauses are included for all subexpressions of $P_1$ that are
constructed from binary operations.

% clauses for if-then-else:
For all $e_0, e_1, e_2 \in \subexps{ P_0' }$ and $E \subseteq
\subexps{ P_0 } \union \subexps{ P_1 }$, let $\mathcal{R} =
\symrelpreds(\elts{ e_0, e_1, e_2 } \union E)$ and $\mathcal{R}' =
\symrelpreds(\elts{ \ite{ e_0 }{ e_1 }{ e_2 } } \union E)$.
%
Then \verifybnd generates relational predicates $R_0$ and $R_1$ and
clauses
%
\BH{fix this defn}
\begin{align*}
  % context subtyping,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % copy the then expression to the whole expression:
  \mathcal{R}, \resvar{e_0} = \true & \subtype \mathcal{R}_T &
  % case where guard is true: define the copy predicates:
  \resvar{ e_1 } \equiv \resvar{ e } & \subtype \mathcal{COPY}_T &
  % copy value from the then expression to the whole expression:
  \mathcal{R}_T \joinctr \mathcal{COPY}_T & \subtype \mathcal{R}' &
  % assume that 
  \mathcal{R}_T, \resvar{ e_0 } = \true & \subtype \mathcal{R}'
  % case where guard is false:
\end{align*}
%
\BH{renamesub: remove use}
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_0 }{ \mathcal{ R }' }{ \resvar{ (e_1, i_1) }
}{ \resvar{(e, i)} }$,
%
\BH{define updated sets of relational predicates}
% add constraint for case where the guard is false,
$\ctrclause{ R }{ R_1 }{ \resvar{ (e_0, i) } = \false}$, and
%
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_1 }{ \mathcal{ R }' }{ \resvar{ (e_2, i_2) }
}{ \resvar{ (e, i) } }$.
%
Similar clauses are included for all \cc{if}-\cc{then}-\cc{else}
subexpressions of $P_1$.

% clause for abs
For all $x \in \vars$, %
$e \in \subexps{ P_0' }$ such that $\lambda x. e \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \subseteq \subexps{P_1}'$, \verifybnd adds clauses that solve
for a relational type of $x$, use it to strengthen the context for
typechecking the $e$.
%
I.e., \verifybnd generates a collection of relational predicates
$\mathcal{R}_x$ for $x$ grouped with $E_0$ and $E_1$, %
adds the clauses
% context for typechecking body is strengthen
$\mathcal{R}'_{\Gamma} \joinctr \mathcal{R}_x \subtype
\mathcal{R}_{\Gamma}$, %
% type of body is type of abstraction, after renaming:
$\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ \argnum{e} }$.
%
Similar clauses are included for all abstraction subexpressions of
$P_1$.

% clause for app
For all $e_0, e_1 \in \subexps{P_0'}$ such that $e_0\ e_1 \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \in \subexps{P_1'}$, let $E = E_0 \union \elts{ e_0, e_1 }
\union E_1$, %
let $E' = E_0 \union \elts{ e_0\ e_1 } \union E_1$, and %
let $f$ be a fresh variable with the same type as $x$.
%
\verifybnd adds the clauses 
% type of context is subtype of context over components:
$E_{\Gamma} \subtype E'_{\Gamma}$ and %
$\replace{ E }{ \firstarg{e_0} }{ f } \subtype \replace{ E }{ e_1 }{ f
}$.
%
\BH{define firstarg symbolic variable per expression}
%
Similar clauses are included for all application subexpressions of
$P_1$.

% define clauses for subsets of expressions
For all $E_0, E_0', E_0'' \in \antichains{ P_0' }$ and %
$E_1, E_1', E_1'' \in \antichains{ P_1' }$ such that $E_1 \union E_1'
= E_1''$, \verifybnd generates clauses $(E_0 \union E_1) \joinctr
(E_0' \union E_1') \subtype E_0'' \union E_1''$.

\BH{define the query of the system}

% walk through the other typing rules that aren't used.
\verifybnd does not generate clauses that model the typing rule
\textsc{Fix}, because an unfolding cannot contain a fixpoint
expression.
%
\verifybnd does not explicitly add clauses that model uses of the
\textsc{Sub} rule, given that a CHC solution may choose types for any
set of expressions that satisfy a subtyping relationship.
%
Sets of fixpoint variables are unconstrained, and in particular may be
interpreted as $\false$.

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to )$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics{I}$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $...$ } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$...$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
