% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-types}, we define a type system for proving
equivalence of programs.
%
In \autoref{sec:infer}, we present an algorithm for
inferring such types.

\subsection{Relational properties as relational types}
\label{sec:rel-types}
%
In this section, we describe a space of types over collections of
expressions, which can represent proofs of equivalence of functional
programs.
%
\autoref{sec:rel-type-space} defines the space of types, %
\autoref{sec:rel-type-ops} defines key operations and relations over
the types, and %
\autoref{sec:rel-type-sys} defines a typing relation from indexed
expressions to the types.

\subsubsection{A space of relational types}
\label{sec:rel-type-space}
% give overview:
A relational type is a set of refinement predicates that relate data
within components of algebraic types, combined with information that
defines mutual inductive definitions of data.
%
Relational types are defined partially over a space of type positions,
which represent component types within algebraic types.
%
Relational positions are a class of sequences of type fields, which
are symbols that denote component types to which algebraic type
constructors are applied.
%
The space of such fields consists of $\tyunitfield$, $\tydatafield$,
$\typaramfield$, $\tyresfield$, $\tyleftprod$, $\tyrightprod$,
$\tyleftsum$, $\tyrightsum$, and for each $X \in \lfpvars$, $X$ and
$\mu_X$.
%
The space of positions is denoted $\typos = \typosfields^{*}$.
% define subspaces of indexed positions:
For indices $I$, the space of type positions \emph{indexed} by $I$ is
denoted $\idxpos{I} = I \times \typos$.

% define refinement predicates, indexed predicates:
A relational refinement type is represented as a set of refinement
predicates that represent relations over data components of types and
an equivalence relation over type variables that define how
least-fixed-point types are mutually unfolded.
%
For indices $I$, a \emph{relational refinement predicate} over $I$ is
a refinement predicate whose vocabulary is the space of data type
positions indexed by $I$ (i.e., the space
$\refpreds{ \idxpos{I} }$).
%
For $f : \pset(I) \to \refpreds{ I }$ are \emph{indexed} relational
refinement predicates if for each $J \subseteq \idxpos{I}$ bound in
$\Phi$, $\Phi(J) \in \refpreds{J}$.

% define relational refinement types:
For indices $I$ and $X \subseteq \lfpvars$, an \emph{relational
  refinement type representation} over $I$ and $X$ is a tuple
$(\Phi, N, P, E)$, where
% indexed refinement predicates
\textbf{(1)}
$\Phi : \pset(\idxpos{I}) \partto \refpreds{ \idxpos{I} }$ are indexed
refinement predicates;
%
\textbf{(2)} $N : X \to I$;
%
\textbf{(2)} $P : X \to \typos$;
%
\textbf{(3)} $E \subseteq X \times X$ an equivalence relation over
$X$.
%
The space of relational refinement types over $I$ and $X$ is denoted
$\reltypes{I, X}$.

% declare typing relation:
A key contribution of our work is the definition of a typing relation
from finite tuples of expressions to relational types.
%
For $e_0, \ldots, e_n \in \expr$ and
$\tau \in \reltypes{e_0, \ldots, e_n}$ (in which the indices are the
expressions $e_0, \ldots, e_n$ themselves), the fact that
$e_0, \ldots, e_n$ have type $\tau$ will be denoted
$e_0, \ldots, e_n : \tau$.
%
The typing relation is defined in \autoref{sec:rel-type-sys}.

% walkthrough the operations over types:
\subsubsection{Operations and relations over relational refinement types}
\label{sec:rel-type-ops}
Our relational type system is defined using operators over relational
types.
%
The operators include generalizations of the type constructors and
operators over structural types, generalizations of type operators
used in refinement type systems, and operators introduced to operate
over features unique to relational types.

\paragraph{Atomic relational refinement types}
%
% introduce map
For indices $I$ and $X \subseteq \lfpvars$, let
$f : \refpreds{I} \to \refpreds{\idxpos{I} }$ be such that for each
$\varphi \in \refpreds{I}$,
$f(I) = \setformer{ (i, \epsilon) / i }{ i \in I }$.
%
Let $g : I \to I \times \typos$ be the one-to-one function such that
for each $i \in I$, $g(i) = (i, \epsilon)$.
%
Then for each $N : X \to I$ and $\mathcal{M} \in \equiv_X$, the
\emph{atomic} relational type defined by $\Phi$, $P$, and
$\mathcal{M}$ is
$(\inv{g} \compose \Phi \compose f, N, P \compose g, \mathcal{M})$.

\paragraph{Relational refinement function types}
%
The relational function from type $\tau$ to $\tau'$ at index $i$ over
abstraction variable $x$ is a relational refinement type in which the
type at $i$ is a function from the type at $i$ in $\tau$ to the type
at $i$ in $\tau'$, and all references to $x$ in $\tau'$ are replaced
with references to components of $\tau$.
% define renaming over indices:
For indices $I$ and $i, j \in I$, let
$\renamefn{i}{j} = \upd{ \iota_I }{i}{j}$.
% define index renaming over sets of indexed type positions,
Let $\renamefn{i}{j}' : \pset(\idxpos{I}) \to \pset(\idxpos{I})$ be
such that for all $J \subseteq \idxpos{I}$,
$\renamefn{i}{j}'(J) = \setformer{(k, p)}{ k \not= j \in J, p \in
  \typos, (k, p) \in J} \union \setformer{ (j, p) }{ p \in \typos, (i,
  p) \in J}$.
% define index renaming over relational refinement predicates,
For indices $I$, let $\renamefn{i}{j}'' : \idxpos{I} \to \idxpos{I}$
be such that for each $\varphi \in \refpreds{ \idxpos{I} }$,
$\renamefn{i}{j}'(\varphi) = \varphi[ \setformer{(j, p) / (i, p)}{ p
  \in \typos} ]$.
%
\BH{define renaming over types}
  
% define prepending over type positions:
For $\varphi \in \refpreds{ \idxpos{I} }$, and $f \in \typosfields$,
$f$ prepended to $\varphi$ at $i$ is denoted
$f \prepend{i} \varphi = \varphi[ \setformer{ (i, f \cons p) / (i,
  f)}{ p \in \typos } ]$.
% define prepending over sets of indexed positions:
For $J \subseteq \idxpos{I}$, the prepending of $f$ to $J$ at $i$ is
denoted $f \prepend{i} J = %
\setformer{ (k, p) }{ k \not= j \in J, p \in \typos, (k, p) \in J} %
\union \setformer{ (i, f \cons p) }{ p \in \typos, (i, p) \in J}$.
%  
For $\Phi : \idxrefpreds{ I}$, $f$ prepended to $\Phi$ at $i$ is
$f \prepend{i} \Phi = %
\setformer{ f \prepend{i} J }{ J \subseteq \idxpos{I}, J \in
  \domain(\Phi)}$.
%
\BH{define prepending over types}

% define function relational type operator,
For index $i \in I$, $X \subseteq \lfpvars$,
$\tau \in \reltypes{I, X}$, $i \in I$, and $x \in \absvars$, the
abstraction of $\tau$ over $x$ at $i$ is
$\to_x^i \tau = \rename{ (\typaramfield \prepend{x} \tyresfield
  \prepend{i} \tau)}{x}{i}$.

% define relational sum:
\paragraph{Relational refinement sum types} The relational sum of
types $\tau$ and $\tau'$ from indices $i$ and $j$ to index $k$ is a
relational refinement type in which the type at $k$ is the sum of
types at $i$ in $\tau$ and at $j$ in $\tau'$.
%
I.e., for space of indices $I$,
$\mathcal{X}, \mathcal{X}' \subseteq \lfpvars$, index $i \in I$,
$\Phi, \Phi' \subseteq \refpreds{ \idxpos{I} }$,
% lfp vars to indices,
$N : \mathcal{X} \to I$, $N' : \mathcal{X}' \to I$,
% lfp vars to positions,
$P : \mathcal{X} \to \typos$, $P' : \mathcal{X}' \to \typos$, 
% equivalence classes:
$\mathcal{M} \in \equiv_{\mathcal{X}}$, and
$\mathcal{M}' \in \equiv_{\mathcal{X}'}$, the sum of
$(\Phi, N, P, \mathcal{M})$ and $(\Phi', N', P', \mathcal{M}')$ at $i$
is $(\Phi, N, P, \mathcal{M}) +^i (\Phi', N', P', \mathcal{M}') = %
% build disjoint union of extended indexed relational preds,
(\tyleftsum \prepend{i} \Phi \union \tyrightsum \prepend{i} \Phi',
% build disjoint union of variable map,
N \union N',
% build disjoint union of extended position maps,
\tyleftsum \prepend{i} P \union \tyrightsum \prepend{i} P',
% equivalence classes: build union:
\mathcal{M} \union \mathcal{M}')$.

% define relational product:
\paragraph{Relational refinement product types}
The indexed product of relational type $\tau$ from indices $i$ and $j$
to index $k$ is a relational type in which the type at $k$ is the
product of types at $i$ and $j$.
%
I.e., for indices $I$, $X \subseteq \lfpvars$,
$\tau \in \reltypes{I, X}$, and indices $i, j, k \in I$, the
relational product of $\tau$ from $i$ and $j$ to $k$ is
$\times_{i, j}^k \tau = \rename{ (\tyleftprod \prepend{i} \tyrightprod
  \prepend{j} \tau)}{ i, j }{k}$.

% define lfp:
\paragraph{Relational refinement least-fixed points}
The indexed least-fixed point of relational type $\tau$ at index $i$
defines a relational type over unbounded unfoldings of the relational
type at $i$.
%
I.e., for space of indices $I$, $\mathcal{X} \subseteq \lfpvars$,
$\tau \in \reltypes{I, \mathcal{X}}$ and $X \in \mathcal{X}$, the
least-fixed point of $\tau$ over $X$ at $i$ is $\mu_i X. \tau = %
\mu_X \prepend{i} \tau$.
%
For $\mathcal{Y} : I \partto \mathcal{X}$, the \emph{mutual} least
fixed point of $\tau$ over $\mathcal{Y}$ is
$\mu_\mathcal{Y} \tau = \mu_{i_0} \mathcal{Y}(i_0). \mu_{i_1}
\mathcal{Y}(i_1) \ldots \tau$ for all indices
$i_k \in \domain(\mathcal{Y})$.

\paragraph{Substitution of relational refinement types}
%
The substitution of relational refinement type $\tau'$ in $\tau$ at
indexed least-fixed-point type variables $\mathcal{X}$ expands $\tau$
to replace occurrences of type variables indexed in $\mathcal{X}$ with
$\tau'$.
% define concatenation of mutual-induction map with refinement predicate
For indices $I$, $M \in \mutinds{I}$, and
$\varphi \in \refpreds{ \idxpos{ \domain(M) } }$, the prefixing of
$\varphi$ with $M$ is
$M \concat \varphi = \varphi[ \setformer{ (i, p \concat \justpos{M}(i)
  / (i, p) }{ i \in I, p \in \typos } ]$.
% define concatenation of mutual-induction maps 
For $N \in \mutinds{I}$ such that $\domain(M) = \domain(N)$, the
concatenation of $M$ with $N$ is
$M \concat N = \setformer{ i \mapsto \justpos{M}(i) \concat
  \justpos{N}(i) }{ i \in \domain(M) }$.

% define closure of indexed lfp vars 
For space of indices $I$, $\mathcal{X} : I \partto \lfpvars$, and
$M \subseteq \idxpos{I}$, $M$ \emph{terminates} at $\mathcal{X}$,
denoted $\terminates{ \mathcal{X} }{ M }$, if for each $i \in I$,
$p \in \typos$, and $Y \in \lfpvars$ such that
$(i, p \concat [ Y ]) \in M$, it holds that $\mathcal{X}(i) = Y$.
%
$\mathcal{X}$ is \emph{closed} under $M$ if either $M$ terminates at
$\mathcal{X}$ or
$\domain(\mathcal{X}) \intersection \domain(M) = \emptyset$;
%
$\mathcal{X}$ is closed over $\mathcal{M} \subseteq \pset(\idxpos{I})$
if $\mathcal{X}$ is closed for each $M \in \mathcal{M}$.

% define renaming over sets of indexed positions,
For $M \subseteq \idxpos{I}$, the naming of $M$ from $i$ to $j$ is
\[ \rename{M}{i}{j} = %
  \setformer{ (k, p) }{ k \not= i, p \in \typos, (k, p) \in M }
  \union %
  \setformer{ (j, p) }{ p \in \typos, (i, p) \in M } \]
% define renaming over sets of sets of indexed variables,
For $\mathcal{M} \subseteq \pset(\idxpos{I})$, the renaming of
$\mathcal{M}$ from $i$ to $j$ is
$\rename{\mathcal{M}}{i}{j} = \setformer{ \rename{M}{i}{j} }{ M \in
  \mathcal{M} }$.
% define renaming over relational refinement types
The naming of each relational refinement type is
$\rename{(\Phi, \mathcal{M})}{i}{j} = (\rename{\Phi}{i}{j}, \rename{
  \mathcal{M}}{i}{j})$.

% define type position field prepended to mutual induction sets,
For $M \subseteq \idxpos{I}$, $f$ prepended to $M$ at $i$ is
$f \prepend{i} M = \setformer{ (i, f \cons p) }{ p \in \typos,
  (i, p) \in M}$.
%
For $\mathcal{M} \subseteq \pset(\idxpos{I})$, $f$ prepended to
$\mathcal{M}$ at $i$ is
$f \prepend{i} \mathcal{M} = \setformer{ f \prepend{i} M }{ M
  \in \mathcal{M} }$.

% define replacement:
For $\Phi, \Phi' \subseteq \refpreds{ \idxpos{I} }$ and %
$\mathcal{M}, \mathcal{M}' \subseteq \pset(\idxpos{I})$ such that
$\mathcal{X}$ is closed over $\mathcal{M}$, the replacement of
$(\Phi', \mathcal{M}')$ in $(\Phi, \mathcal{M})$ at $\mathcal{X}$,
denoted
$\replace{(\Phi, \mathcal{M})}{ \mathcal{X} }{(\Phi', \mathcal{M}')}$,
is $(\Phi \union \Phi'', \mathcal{M} \union \mathcal{M}'')$, where
%
\begin{align*}
  % refinement predicates are base refinement predicates and
  \Phi'' = & % concatenation of M and phi
             \setformer{ M \concat \varphi' }{ 
             % for each mutual induction set M in base type and
             M \in \mathcal{M}, \terminates{ \mathcal{X} }{ M },
             % each refinement predicate in substituted type,
             \varphi' \in \Phi', %
             \varphi' \in \refpreds{ \idxpos{ \domain(M) } } } \\
  % mutual induction sets are base mutual induction sets and
  \mathcal{M}'' = & % concatenation of M and M'
                    \setformer{ M \concat M' }{
                      % for each mutual induction set M in the base and
                    M \in \mathcal{M},
                    % such that M terminates at X,
                    \terminates{ \mathcal{X} }{ M },
                    % each mutual induction set M' in subst type
                    M' \in \mathcal{M}',
                    % with equal domains,
                    \domain(M) = \domain(M') }
\end{align*}


% define refinement relation over types
\paragraph{Joining relational refinement types}

% inference rules that define join:
\begin{figure}
  \centering
  \begin{gather*}
    % join atomics:
    \inference[ ATOMICS ]{
      % join the indexed refinement predicates,
      \Phi \join{ \varphi } \Phi' \subtype_V \Phi'' &
      % join the mutual induction sets,
      \mathcal{M} \join{ \varphi } \mathcal{M}' \subtype_V \mathcal{M}'' }{
      (\Phi, \mathcal{M}) \join{ \varphi } (\Phi', \mathcal{M}') \subtype_V %
      (\Phi', \mathcal{M}'') } \\
    % join shared function:
    \inference[ FNS ]{
      % join the nested relational types:
      \tau \join{ \varphi } \tau' \subtype \tau'' }{
      % combine results using relational function,
      \to^i \tau \join{ \varphi } \to^i \tau' \subtype \to^i \tau'' }
    % join shared sum:
    \inference[ SUM ]{
      % join the lhs's
      \tau_l \join{ \varphi } \tau_l' \subtype_V \tau_l'' &
      % join the rhs's
      \tau_r \join{ \varphi } \tau_r' \subtype_V \tau_r'' }{
      % complete type is sum
      \tau_l +^i \tau_r \join{ \varphi } \tau_l' +^i \tau_r' %
      \subtype_V \tau_l'' +^i \tau_r'' } \\
    % join shared product:
    \inference[ PROD ]{
      % get refinement for nested type,
      \tau \join{ \varphi } \tau' \subtype_V \tau'' }{
      % complete type is product
      \times_{i, j}^k \tau \join{ \varphi } %
      \times_{i, j}^k \tau' \subtype_V \times_{i, j}^k \tau'' }
    % join shared lfps:
    \inference[ LFP ]{
      % join types of bodies of lfp's,
      \tau \join{ \varphi } \tau' \subtype_V \tau'' }{
      % wrap up the result,
      \mu_i X. \tau \join{ \varphi } \mu_i X. \tau' \subtype %
      \mu_i X. \tau'' } \\
    % join unshared function:
    \inference[ FNS-A ]{
      % join the nested relational types:
      \tau \join{ \varphi } \tau' \subtype \tau'' }{
      % combine results using relational function,
      \to^i \tau \join{ \varphi } \tau' \subtype \to^i \tau'' }
    % join unshared sum:
    \inference[ SUM-A ]{
      % join the lhs's
      \tau_l \join{ \varphi } \tau' \subtype_V \tau_l'' &
      % join the rhs's
      \tau_r \join{ \varphi } \tau' \subtype_V \tau_r'' }{
      % complete type is sum
      \tau_l +^i \tau_r \join{ \varphi } \tau' %
      \subtype_V \tau_l'' +^i \tau_r'' } \\
    % join unshared product:
    \inference[ PROD-A ]{
      % get refinement for nested type,
      \tau \join{ \varphi } \tau' \subtype_V \tau'' }{
      % complete type is product
      \times_{i, j}^k \tau \join{ \varphi } \tau' \subtype_V %
      \times_{i, j}^k \tau'' } 
    % join unshared lfp:
    \inference[ LFP-A ]{
      % get refinement for nested type,
      \tau \join \tau' \subtype_V \tau'' }{
      % wrap lhs type in lfp constructor,
      \mu_i X. \tau \join{ \varphi } \tau' \subtype_V \tau'' } 
    % join is symmetric on first two component relational types:
    \inference[ SYM ]{ %
      \tau' \join{ \varphi } \tau \subtype_V \tau'' }{ %
      \tau \join{ \varphi } \tau' \subtype_V \tau'' } 
  \end{gather*}
  \caption{Inductive inference rules that define the join of two relational types.
    %
    \BH{define metavariables used in rules} }
  \label{fig:join}
\end{figure}
% give overview:
The join of relational refinement types $\tau$ and $\tau'$ combines
their relationships over common indices.
%
For indices $I$, refinement predicate $\varphi \in \refpreds{I}$, and
all $\tau, \tau', \tau'' \in \reltypes{I}$, the fact that $\tau$ and
$\tau'$ \emph{join to form} $\tau''$ is denoted
$\tau \join{ \varphi } \tau' = \tau''$.

% walk through the rules:
The join operation is defined by the inductive inference rules given
in \autoref{fig:join}.
% atomic relational types:
Rule~ATOMICS
%
\BH{complete}

% synchronous rules: functions:
Rules~FNS, SUM, PROD, and LFP establish that the join relation is
preserved by the abstraction, sum, production, and least-fixed point
operators over relational refinement types on common indices.
%
For relational refinement types $\tau$, $\tau'$, and $\tau''$, if
$\tau$ joins with $\tau'$ on $\varphi$ to form $\tau''$, then the
abstractions of each of $\tau$ and $\tau'$ at index $i$ join to form
$\tau''$ abstracted at $i$.
% relational sums:
For relational refinement types $\tau_l$, $\tau_l'$, $\tau_l''$,
$\tau_r$, $\tau_r'$, and $\tau_r''$, if %
\textbf{(1)} $\tau_l$ joins with $\tau_l'$ on $\varphi$ to form
$\tau_l''$ and %
\textbf{(2)} $\tau_r$ joins with $\tau_r'$ on $\varphi$ to form
$\tau_r''$, then $\tau_l +^i \tau_r$ joins with $\tau_l' +^i \tau_r'$
to form $\tau_l'' +^i \tau_r''$.
% relational products:
If $\tau$ joins with $\tau'$ on $\varphi$ to form $\tau''$, then %
$\times_{i, j}^k \tau$ joins with $\times_{i, j}^k \tau'$ to form
$\times_{i, j}^k \tau''$.
% relational lfp:
If $\tau$ joins with $\tau'$ on $\varphi$ to form $\tau''$, then %
$\mu_i X. \tau$ joins with $\mu_i X. \tau'$ on $\varphi$ to from
$\mu_i X. \tau''$.

% walkthrough asynchronous rules:
Rules~FNS-A, SUM-A, PROD-A, and LFP-A are defined similarly to
Rules~FNS, SUM, PROD, and LFP, but define the join relation over pairs
of relational refinement types that may not share all indices.
%
Rule~SYM establishes if $\tau$ joins with $\tau'$ to form $\tau''$,
then $\tau'$ joins with $\tau$ to form $\tau''$ as well.
%
I.e., the binary relations defined by fixing the third relational
refinement type in the (ternary) join relation are symmetric.

% define the subtyping relation:
\paragraph{Relational refinement subtypes}
%
\begin{figure}
  \centering
  \begin{gather*}
    % subtype pair of atomic types:
    \inference[ ATOMICS ]{
      \Phi \subtype \Phi' & \mathcal{M} \subtype \mathcal{M}' }{
      (\Phi, \mathcal{M}) \subtype (\Phi', \mathcal{M}') } \\
    % rules that deconstruct both sides. Relational functions:
    \inference[ FNS ]{
      % if parameter 1 subtypes parameter 0,
      \tau_1 \subtype \tau_0 &
      % and result 0 subtypes result 1
      \tau_0' \subtype \tau_1' }{
      % then function types are subtypes,
      \tau_0 \to_x^i \tau_0' \subtype \tau_1 \to_x^i \tau_1' } 
    % relational sums:
    \inference[ SUMS ]{
      % if component types subtype each other,
      \tau_l \subtype \tau_l' & \tau_r \subtype \tau_r' }{
      % then sums are subtypes
      \tau_l +^i \tau_r \subtype \tau_l' +^i \tau_r' } 
    % relational products:
    \inference[ PRODS ]{ \tau \subtype \tau'}{
      \times_{i, j}^k \tau \subtype \times_{i, j}^k \tau'} \\
    % subtype function with atomic
    \inference[ FNS-A]{ \tau \subtype A & A \subtype \tau' }{
      A \subtype \tau \rightarrow_x^i \tau'} 
    % subtype atomic with sum
    \inference[ SUM-A ]{ A \subtype \tau & A \subtype \tau' }{
      A \subtype \tau +^i \tau' } 
    % subtype atomic with product
    \inference[ PROD-A ]{ A \subtype \tau }{
      A \subtype \times^k_{i, j} \tau } \\
    % lfps:
    \inference[ LFPS ]{}{} 
  \end{gather*}
  \caption{Inductive inference rules that define relational refinement
    subtypes.
    %
    \BH{define metavariables}
  }
  \label{fig:subtypes}
\end{figure}

\BH{define subtyping relation over indexed relational predicates}

\BH{walk through subtyping rules}

\subsubsection{A relational type system}
\label{sec:rel-type-sys}
%
The typing relation from tuples of expressions to relational types is
defined as an instance of a typing relation from sub-expressions to
relational types.
% define context:
A \emph{contextual relational type} is a relational type with program
variables as indices.
%
I.e., the space of contextual relational types is $\reltypes{\vars}$.
%
A \emph{fixpoint relational context} is a map from fixpoint variables
to contextual relational types.
%
I.e., the space of contexts is
$\ctxs = \fixvars \partto \ctxreltypes$.

% define expression positions:
An \emph{expression position} partially identifies the position of an
expression within a larger expression, or within a tuple of
expressions.
%
The space of \emph{expression-position fields} is
$\expposfields = \elts{ \leftchild, \rightchild }$.
%
The space of \emph{expression positions} is
$\exppos = \expposfields^{*}$.
% 
The space of \emph{positioned relational types} is
$\reltypes{\vars \union \exppos}$.

% define typing relation over expressions in terms of positioned
% expressions
For $\Gamma \in \ctxs$, $\gamma \in \ctxreltypes$,
$E : \exppos \partto \expr$, and $\tau \in \posreltypes$, the fact
that $E$ have relational type $\tau$ under $\Gamma$ and $\gamma$ is
denoted $\Gamma, \gamma \judges E : \tau$;
%
the typing relation is defined below.
%
The typing relation over expressions is defined in terms of the typing
relation over positioned expressions.
%
In particular, for each $n \in \nats$, let the expression-position
encoding of $n$ be $\pos{n} = \leftchild \cons \rightchild^{n}$, and
let $\gamma_{\emptyset}$ denote the unique contextual relational type
over the empty set of variables.
%
Then for all $e_0, \ldots, e_{n - 1} \in \expr$ and
$\tau \in \reltypes{ e_0, \ldots, e_{n - 1} }$, the typing relation
$e_0, \ldots, e_{n - 1} : \tau$ is
\[ \cdot, \gamma_{\emptyset} \judges [ \pos{0} \mapsto e_0, \ldots,
  \pos{n - 1} \mapsto e_{n - 1} ] : \rename{ \tau }{ e_0, \ldots,
    e_{n - 1} }{ \pos{0}, \ldots, \pos{n - 1} } \]

% typing judgments:
\begin{figure}
  \centering
  \begin{gather*}
    % empty:
    \inference[ EMPTY ]{ }{
      % the empty map of expressions has relational type true
      \Gamma, \gamma \judges \cdot : \gamma } 
    % unit:
    \inference[ UNIT ]{
      % get types for remainder,
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ \unit } : \tau %
    } 
    % constant:
    \inference[ CONST ]{ %
      % remainder has type tau,
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ c } : %
      \tau \joinctr p \equiv c } \\
    % vars:
    \inference[ VAR ]{ %
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ a } : %
      \tau \joinctr p \equiv a } 
    % base operation:
    \inference[ OP ]{ %
      % remainder has type tau,
      \Gamma, \gamma \judges %
      E[ \leftchild \cons p \mapsto e_0, %
        \rightchild \cons p \mapsto e_1 ] : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ e_0 \oplus e_1 } : %
      \tau \joinctr %
      p \equiv \leftchild \cons p \oplus \rightchild \cons p } \\
    % abstraction:
    \inference[ ABS ]{ 
      % extend the context and typecheck the body,
      \Gamma, \gamma \judges \upd{ E }{ p }{ e } : \tau }{ %
      % type of abstraction is
      \Gamma, \gamma' \judges \upd{ E }{ p }{ \lambda x. e } : %
      \gamma \to_p \tau } 
    % application:
    \inference[ APP ]{ %
      % get type of abstraction,
      \Gamma, \gamma \judges \upd{E}{p}{e_0} : \tau \to_p \tau' \\
      % get type of argument that is the parameter type,
      \Gamma, \gamma \judges \upd{E}{p}{e_1} : \tau }{
      % return the result type
      \Gamma, \gamma \judges \upd{ E }{ p }{e_0\ e_1} : \tau' } \\
    % pairing:
    \inference[ PAIR ]{
      % get type of both expressions,
      \Gamma, \gamma \judges %
      E[ \leftchild \cons p \mapsto e_0, %
      \rightchild \cons p \mapsto e_1 ] : \tau }{
      % then type of pair is
      \Gamma, \gamma \judges \upd{E}{p}{ \pair{e_0}{e_1} } :
      \times_{\leftchild \cons p, \rightchild \cons p}^p \tau } 
    % let:
    \inference[ LET ]{
      % get type of bound expression,
      \Gamma, \gamma \judges \epsilon \mapsto e_0 : %
      \times_{x, y}^{\epsilon} \gamma' \\
      % get type of result under context that binds to x and y,
      \Gamma, \gamma' \judges \upd{ E }{ p }{ e_1 } : \tau }{
      % then complete let expression has type
      \Gamma, \gamma \judges \upd{E}{p}{ \letexp{x}{y}{e_0}{e_1} } : %
      \tau } \\
    % left injection:
    \inference[ LEFT ]{
      % get type of the nested exp,
      \Gamma, \gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma, \gamma \judges \upd{E}{p}{ \injl\ e} : %
      \tau +^p \tau' } 
    % right injection:
    \inference[ RIGHT ]{
      % get type of the nested exp,
      \Gamma, \gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma, \gamma \judges \upd{E}{p}{ \injr\ e} : %
      \tau' +^p \tau } \\
    % match:
    \inference[ MATCH ]{
      % get type of matched exp,
      \Gamma, \gamma \judges \epsilon \mapsto e_0 : %
      \gamma' +^\epsilon \gamma'' \\
      % get type of left branch under context that binds x to left op,
      \Gamma, \rename{ \gamma' }{ \epsilon }{ x } \judges %
      \upd{E}{p}{e_1} : \tau \\
      % get type of right branch under context that binds y to right op,
      \Gamma, \rename{ \gamma'' }{ \epsilon }{ y } \judges %
      \upd{E}{p}{e_2} : \tau }{
      % then type of match exp is type of both branches,
      \Gamma, \gamma \judges %
      \upd{E}{p}{ \matchexp{e_0}{ x }{e_1}{ y }{e_2} } : \tau } 
    % fixpoint:
    \inference[ FIX ]{
      % get type of body under context that binds symbol to tau,
      \upd{ \Gamma }{ f }{ \gamma' }, \gamma \judges %
      \upd{ E }{ p }{ e } : \tau \\
      % constrain that tau' with result renamed to f is subtype of tau,
      \replace{ \tau }{ p }{ f } \subtype \gamma' }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ \fix{f}{e} }: \tau } \\
    % fixpoint variable:
    \inference[ FVAR ]{ }{
      % the empty map of expressions has relational type true
      \Gamma, \gamma \judges p \mapsto f : %
      \Gamma(f) \joinctr p \equiv f} 
    % unfold:
    \inference[ UNFOLD ]{
      % if expressions have tau unfolded at p,
      \Gamma, \gamma \judges E : %
      \replace{ \tau }{ \mathcal{X} }{ \tau }_p }{ 
      % then expressions have folded type
      \Gamma, \gamma \judges E : \mu_{\mathcal{X}}. \tau } 
    % subtype:
    \inference[ SUB ]{
      % if expressions have tau,
      \Gamma, \gamma \judges E : \tau &
      % and tau subtypes tau',
      \tau \subtype \tau' }{ %
      % then expressions have type tau'
      \Gamma, \gamma \judges E : \tau' }
  \end{gather*}
  \caption{A typing system for relational types.
    %
    Metavariable %
    $\gamma$ ranges over contexual relational types, %
    $\Gamma$ ranges over contexts, %
    $E$ ranges over positioned expressions, %
    $p$ ranges over expression positions, %
    $e$ ranges over expressions, %
    $\tau$ ranges over relational types, %
    $c$ ranges over constants, %
    $x$ and $y$ range over abstraction variables, %
    $f$ ranges over fixpoint variables, %
    $a$ ranges over variables, and
    $\mathcal{X}$ ranges over indexed least-fixed-point variables. }
  \label{fig:reltypes-rules}
\end{figure}

% define judgment:
The typing relation over positioned expressions is defined by the
inductive inference rules given in \autoref{fig:reltypes-rules}.
%
The inference rules consist of syntax-directed rules that define the
typing relation for arbitrary expressions in a collection of
positioned expressions, along with rules that define the typing
relation for special cases of positioned expressions and for assigning
relational least-fixed-point types and using the subtype relation.
% empty:
Rule~EMPTY establishes that under contextual relational type $\gamma$,
the empty positioned expressions (denoted $\cdot$) have type $\gamma$.

% unit:
Rule~UNIT establishes that if positioned expressions $E$ have type
$\tau$, then $E$ extended to bind position $p$ to the unit have type
$\tau$.
% const:
Rule~CONST establishes that if $E$ have type $\tau$, then $E$ extended
to bind $p$ to constant $c$ have type $\tau$ refined to equate $p$
with $c$.
% op:
Rule~OP establishes that if $E$ extended to bind positions
$\leftchild \cons p$ and $\rightchild \cons p$ to expressions $e_0$
and $e_1$ have type $\tau$, then $E$ extended to bind $p$ to
$e_0 \oplus e_1$ have type $\tau$ refined to set $p$ to
$\leftchild \cons p \oplus \rightchild \cons p$.

% inference rules that define relational type of a structural type:
\begin{figure}
  \centering
  \begin{gather*}
    \inference[ ATOMS ]{ }{ %
      A \reltyof \tau_A } 
    % structural functions:
    \inference[ FN ]{ 
      % get relational types of parameter, result
      \upd{ T }{ \leftchild \cons p, \rightchild \cons p }{ \sigma, \sigma' } %
      \reltyof \tau }{
      % construct relational function type
      \upd{ T }{ p }{ \sigma \to \sigma' } \reltyof \tau \to^p \tau' } 
    % structural products:
    \inference[ PROD ]{
      % get relational types of components,
      \upd{ T }{ \leftchild \cons p, \rightchild \cons p }{ %
        \sigma_l, \sigma_r } \reltyof \tau }{
      % construct relational product type
      \upd{ T }{ p }{ \sigma_l \times \sigma_r } \reltyof %
      \times_{ \leftchild \cons p, \rightchild \cons p }^{p} \tau } \\
    % structural sum:
    \inference[ SUM ]{
      % get relational type of lhs,
      \upd{ T }{ p }{ \sigma_l } \reltyof \tau_l &
      % get relational type of rhs,
      \upd{ T }{ p }{ \sigma_r } \reltyof \tau_r }{
      % combine results using relational sum
      \upd{ T }{ p }{ \sigma_l + \sigma_r } \reltyof \tau_l +^p \tau_r } 
    % structural lfp:
    \inference[ LFP ]{
      % get relational type of nested type,
      \upd{ T }{ p }{ \sigma } \reltyof \tau }{
      % operate using the lfp operator
      \upd{ T }{ p }{ \mu X. \sigma } \reltyof \mu_p X. \tau }
  \end{gather*}
  \caption{Inductive inference rules that define the relational type
    of a structural type.
    %
    \BH{define metavariables used in rules} }
  \label{fig:structure-rel}
\end{figure}

% variables:
Rule~VAR establishes that if $E$ have type $\tau$, then $E$ extended
to bind $p$ to variable $a$ have type $\tau$ refined to equate $p$
with $a$.
% overview:
Each structural type $\sigma$ corresponds to potentially-many
relational refinement types.
%
For $\tau \in \reltypes{\sigma}$, we denote the fact that $\sigma$
corresponds to $\tau$ as $\sigma \reltyof \tau$.

% define judgment:
\autoref{fig:structurel-rel} contains the finite set of inductive
inference rules that define the correspondence from structural types
to relational refinement types.
%
The inference rules define a correspondence relation over maps from
type positions to structural types to relational refinement types.
%
For $\sigma \in T$ and $T: \typos \partto \types$ and
$\tau \in \reltypes{ \sigma }$, the fact that $T$ corresponds to
$\tau$ is denoted $T \reltyof \tau$.
%
The fact that $\sigma$ corresponds to $\tau$ is denoted
$\sigma \reltyof \tau \equiv [ \epsilon \mapsto \sigma ] \reltyof
\tau$.

% walkthrough rules: atomic maps:
The correspondence from type-position maps to relational refinement
types is defined by the rules in \autoref{fig:structure-rel} as
follows.
%
Rule~ATOMS defines the correspondence for maps to atomic structural
types.
% define atomic maps:
For $A : \typos \partto \types$, if each binding in $A$ is to an
atomic structural type, then $A$ itself is \emph{atomic}.
% define relational refinement type:
Each atomic type $A$ corresponds to the relational refinement type
$\tau_A = (\Phi, \mathcal{M})$, defined as follows.
% define indexed refinement predicate:
Let $P \in \typos$ be the maximal set of type positions such that for
each $p \in P$, $A(p) = \basety$;
%
then $\Phi = P \mapsto \true$.
%
$\mathcal{M}$ is an arbitrary mutual-induction set.
%
\BH{bkg: require that refinement theory has true/top formula}

% functions:
Rule~FN establishes that for $T : \typos \partto \types$,
$p \in \typos$, $\sigma, \sigma_{\alpha}, \sigma_{\nu} \in \types$,
and $\tau_{\alpha}, \tau_{\nu} \in \reltypes{ \sigma }$, if %
\textbf{(1)} $\tau_{\alpha}$ is a relational refinement type of $T$
extended to bind $p$ to $\sigma_{\alpha}$ and %
\textbf{(2)} $\tau_{\nu}$ is a relational refinement type of $T$
extended to bind $p$ to $\sigma_{\nu}$, then
$\tau_{\alpha} \to_{x}^p \tau_{\nu}$ is a relational refinement type
of $T$ extended to bind $p$ to $\sigma \to \sigma$.
% products: sums
Rule~PROD establishes that if $T$ extended to bind
$\leftchild \cons p$ and $\rightchild \cons p$ to structural types
$\sigma_l$ and $\sigma_r$ respectively has relational refinement type
$\tau$, then $T$ extended to bind $p$ to $\sigma_l \times \sigma_r$
has relational refinement type
$\times_{ \leftchild \cons p, \rightchild \cons p}^{p} \tau$.
% sums:
Rule~SUM establishes that if %
\textbf{(1)} $T$ extended to bind $p$ to $\sigma_l$ has relational
refinement type $\tau_l$ and $T$ extended to bind $p$ to $\sigma_r$
has relational refinement type $\tau_r$, then $T$ extended to bind $p$
to $\sigma_l + \sigma_r$ has relational refinement type
$\tau_l +^{p} \tau_r$.
%
Rule~LFP establishes that if %
$T$ extended to bind $p$ to $\sigma$ has relational type $\tau$, then
$T$ extended to bind $p$ to $\tylfp_p X. \tau$ has relational type
$\mu_p X. \tau$.

% abs:
Rules~ABS and APP are defined using the relational function type
operator.
%
Rule~ABS establishes that if, under contextual relational type
$\gamma$, $E$ extended to bind $p$ to expression $e$ have type $\tau$,
then under contextual relational type $\gamma'$, $E$ extended to bind
$p$ to $\lambda x. e$ is a relational function from $\gamma$ to
$\tau'$ at $p$.
% app:
Rule~APP establishes that if %
\textbf{(1)} $E$ extended to bind $p$ to $e_0$ is a relational
function from $\tau$ to $\tau'$ at $p$ and %
\textbf{(2)} $E$ extended to bind $p$ to $e_1$ has type $\tau$, then
$E$ extended to bind $p$ to $e_0$ applied to $e_1$ has type $\tau'$.

% relational prod:
Rules~PAIR and LET are defined using the relational product type
operator.
% pair:
Rule~PAIR establishes that if $E$ extended to bind
$\leftchild \cons p$ and $\rightchild \cons p$ to $e_0$ and $e_1$ has
type $\tau$, then $E$ extended to bind $p$ to $\pair{ e_0 }{ e_1 }$ is
the relational product of $\tau$ from $\leftchild \cons p$ and
$\rightchild \cons p$ to $p$.
% let:
Rule~LET establishes that if %
\textbf{(1)} under $\gamma$, the $e_0$ is the relational product of
$\gamma'$ from variables $x$ and $y$;
%
\textbf{(2)} under $\gamma'$, $e_1$ has type $\tau$, then under
$\gamma$, $E$ extended to bind $p$ to $\letexp{x}{y}{e_0}{e_1}$ has
type $\tau$.

% relational sum:
Rules~LEFT, RIGHT, and MATCH are defined using the relational sum type
operator.
% left:
Rule~LEFT establishes that if $E$ extended to bind $p$ to $e$ has type
$\tau$, then $E$ extended to bind $p$ to the left injection of $e$ is
a relational sum of from $p$ and $p$ to $p$ of $\tau$ and any
relational type $\tau'$.
%
Rule~RIGHT is defined symmetrically to Rule~LEFT.
% match:
Rule~MATCH establishes that if %
\textbf{(1)} under $\gamma$, $e_0$ is the relational sum of $\gamma'$
and $\gamma''$ from variables $x$ and $y$;
% 
\textbf{(2)} under $\gamma'$, $E$ extended to bind $p$ to $e_1$ has
type $\tau''$; and
%
\textbf{(3)} under $\gamma''$, $E$ extended to bind $p$ to $e_2$ also
has type $\tau''$, then under $\gamma$, $E$ extended to bind $p$ to
$\matchexp{e_0}{x}{e_1}{y}{e_2}$ has type $\tau''$.

% fix:
Rule~FIX establishes that if %
\textbf{(1)} under $\Gamma$ extended to bind $f$ to $\gamma'$ and
$\gamma$, $E$ extended to bind $p$ to $e$ has type $\tau$; and %
\textbf{(2)} $\tau'$ with $p$ renamed to $f$ is a subtype of
$\gamma'$, then under $\Gamma$ and $\gamma$, $E$ extended to bind $p$
to $\fix{f}{e}$ has type $\tau$.
% fixpoint var:
Rule~FVAR establishes that under context $\Gamma$, the positioned
expression that maps only position $p$ to fixpoint variable $f$ has
type $\Gamma(f)$ refined to equate $p$ with $f$.

% unfold:
Rule~UNFOLD establishes that if $E$ has type $\tau$ unfolded,
then $E$ has type $\tau$.
% sub:
Rule~SUB establishes that if $E$ has type $\tau$ a subtype of $\tau'$,
then $E$ has type $\tau'$.

% main lemma of the typing system:
The typing relation is preserved by the evaluation relation.
%
\begin{lemma}
  \label{lemma:preservation}
  For all $e_0, \ldots, e_n$, $v_0, \ldots, v_n \in \values$ such that
  $v_0 \evalsto v_0, \ldots, e_n \evalsto v_n$, and
  $\tau \in \reltypes{e_0, \ldots, e_n}$ such that
  $e_0, \ldots, e_n : \tau$, it holds that $v_0, \ldots, v_n : \tau$.
\end{lemma}
%
One proof of \autoref{lemma:preservation} uses proof by induction on
%
\BH{complete}

\subsection{Inferring relational refinement types}
\label{sec:infer}
%
A key contribution of our work is a type-inference algorithm for
relational refinement types, named \sys.
%
\sys, given expressions $e_0, \ldots, e_n$ and relational refinement
type $\tau$, attempts to determine if $e_0, \ldots, e_n : \tau$.
%
This section defines collections of relational refinement types over
sub-expressions maintained by \sys (\autoref{sec:bnd-unfoldings}).
%
The section then defines a type-inference algorithm that synthesizes
such collections of relational refinement types
(\autoref{sec:infer-alg}).

\subsubsection{Relational types of sub-expressions}
\label{sec:bnd-unfoldings}
%
\sys, given expressions $e_0, \ldots, e_n$ and relational type
$\tau \in \reltypes{e_0, \ldots, e_n}$, attempts to determine if
$e_0, \ldots, e_n : \tau$ by finding types of expansions of
$e_0, \ldots, e_n$.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $e \in \expr$, the \emph{unfoldings} of $e$, denoted
  $\unfoldings{ \fix{f}{e} }$ are defined inductively as follows:
  %
  \begin{enumerate}
  \item % expression is unfolding
    $e \in \unfoldings{ e }$;
  \item % replacement:
    For $e \in \expr$ and $e' \in \unfoldings{e}$ that contains
    subexpressions $\fix{f_0}{e_0}, \ldots, \fix{f_n}{e_n}$
    $\replace{e'}{f_0, \ldots, f_n}{ \fix{f_0}{e_0}, \ldots,
      \fix{f_n}{e_n} }$.
  \end{enumerate}
\end{defn}
%
\BH{give examples}

% type-inference algorithm:
\subsubsection{A procedure for inferring relational refinement types}
\label{sec:infer-alg}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$e_0, \ldots, e_n \in \expr$ and
    $\tau \in \reltypes{e_0, \ldots, e_n}$.}
  % Output: decision for safety
  \Output{A decision whether $e_0, \ldots, e_n : \tau$ holds.}
  % infer: top-level procedure
  \myproc{ $\sys(e_0, \ldots, e_n, \tau)$ %
    \label{line:infer-begin} }{ %
    % infer helper procedure,
    \myproc{$\inferaux(e_0', \ldots, e_n')$ %
      \label{line:infer-aux-begin} }{ %
      % try to infer types for the bounded unfoldings,
      \Switch{$\inferbnd(e_0', \ldots, e_n', \tau)$ %
        \label{line:infer-bnd} }{
        % if inference returns bottom, give up
        \lCase{$\bot$}{ 
          % then expressions don't have the type
          \Return{$\false$} \label{line:ret-no-has-ty} }
        % if inference returns relational types,
        \Case{$T \in \subexptypes{ e_0, \ldots, e_n }{ \tau }$ %
          \label{line:subexp-types} }{ %
          % then check if they're inductive:
          \lIf{$\chkinductive(e_0, \ldots, e_n, T)$ %
            \label{line:chk-ind} }{ 
            \Return{ $\true$ } \label{line:ret-eq} } %
          \lElse{ %
            \Return{ $\inferaux(\unfoldexp(e_0'), \ldots, %
              \unfoldexp(e_n))$ } \label{line:recurse} }
        } %
      } \label{line:infer-aux-end} }
    \Return{$\inferaux(e_0, \ldots, e_n)$ %
      \label{line:infer-base} }
  }
  % 
  \caption{ \sys: a type-inference procedure that uses procedures
    \inferbnd, \chkinductive, and \unfoldexp. }
  \label{alg:infer}
\end{algorithm}
\end{figure}

% inference procedure top-level:
The type-inference procedure \sys is given in \autoref{alg:infer}.
%
\sys (\autoref{alg:infer}) expressions $e_0, \ldots, e_n \in \expr$
and relational type $\tau \in \reltypes{e_0, \ldots, e_n}$, attempts
to decide if $e_0, \ldots, e_n : \tau$.
%
\sys uses a procedure \inferaux
(\autoref{line:infer-aux-begin}---\autoref{line:infer-aux-end}) that,
given unfoldings $e_0', \ldots, e_n'$ of $e_0, \ldots, e_n$ attempts
to determine if $e_0, \ldots, e_n : \tau$ by finding relational types
over fixpoint expressions in $e_0, \ldots, e_n$ based on relational
types of $e_0', \ldots, e_n'$.
%
\sys, given $e_0', \ldots, e_n'$, calls procedure \inferbnd on
$e_0', \ldots, e_n'$ and $\tau$ (\autoref{line:infer-bnd}), which
returns either $\bot$ to denote that $e_0', \ldots, e_n'$ do not have
type $\tau$ or $T \in \subexptypes{ e_0, \ldots, e_n' }{ \tau }$.
% case: bounded does not have type,
If \inferbnd returns $\bot$, then \sys returns that
$e_0, \ldots, e_n : \tau$ (\autoref{line:ret-no-has-ty}).

% case: bounded has type,
If \inferbnd returns sub-expression types $T$
(\autoref{line:subexp-types}), then \inferaux calls procedure
\chkinductive on $e_0, \ldots, e_n$ and $T$, which soundly determines
if $e_0, \ldots, e_n : \tau$ by assigning types of fixpoint
subexpressions of $e_0, \ldots, e_n$ that are relational subtypes of
their unfoldings in $e_0', \ldots, e_n'$.
%
If \chkinductive determines that $e_0, \ldots, e_n : \tau$, then \sys
determines that $e_0, \ldots, e_n : \tau$ (\autoref{line:ret-eq}).
%
Otherwise, \chkinductive constructs expressions
$e_0' \unfolding \unfold(e_0', e_0) \unfolding e_0, \ldots, e_n'
\unfolding \unfold(e_n', e_n) \unfolding e_n$, recurses on the result,
and returns the result of the recursion
(\autoref{line:infer-recurse}).

% sketch unfolding operations:
The procedure \unfoldexp is straightforward to implement.
%
One implementation of \unfoldexp, given $e \in \expr$, iteratively
replaces each occurrence of fixpoint variable $f$ in $e$ with
$\fix{f}{e'}$, where $\fix{f}{e'}$ is a sub-expression of $e$.
%
The procedures \inferbnd and \chkinductive are defined below.

\paragraph{Typing subexpressions of bounded expressions}
\label{sec:type-bnd}
% give an overview:
\verifybnd, given $\cc{P}_0' \in \unfoldings{ \cc{P}_0 }$ and
$\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$, either returns types of the
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$ or returns $\nonequiv$
to denote that $\cc{P}_0' \not\equiv \cc{P}_1'$.
%
\verifybnd reduces this problem to solving a CHC system
(\autoref{sec:chcs}).
%
Each solution of the system defines types and contexts of
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$.
%
The clauses of the system correspond to rules for establishing types
of expressions (\autoref{fig:reltypes-rules}).

% give the construction in detail:
\BH{update}
%
\verifybnd generates the following CHC system $\mathcal{C}_{
  \cc{P}_0', \cc{P}_1' }$.
% define the space of relational predicates
Let $E \subseteq \subexps{ \cc{P}_0' } \union \subexps{ \cc{P}_1' }$.
% define relational predicates of a set of types:
For typed symbols $T$, let the set of relational predicates
$\symrelpreds{ T }$ be defined as follows.
% base case: T is the empty set of types:
If $T = \emptyset$, then $R_T = \emptyset$.
% inductive case: T is a non-empty set
Otherwise, let $R$ be such that for all $\tau_0, \ldots, \tau_n, \tau'
\in \reftypes$ such that $\tau = \tau_0 \rightarrow \ldots \rightarrow
\tau_n \rightarrow \tau'$, $R$ has variables corresponding to
$\tau_0$, \ldots, $\tau_n$, and $\tau'$.
%
Let $T'$ be collection of typed symbols in which each symbol is a pair
of a typed symbol $f \in T$ and the position of a higher-order
argument type in the type of $f$ in $T$.
%
Then $\symrelpreds{ T } = \add{ \symrelpreds{ T' } }{ R }$.

% define type of a context:
Let $\Gamma : E \times \vars \to \types$ map each $e \in E$ and each
$x \in \freevars(e)$ to its type in $e$, and let $R_E^{\Gamma} =
\symrelpreds( \Gamma )$.
%
Let $T : E \to \types$ map each $e \in E$ to its type under its
context in $\cc{P}_0$ or $\cc{P}_1$.
%
\BH{define all notions of base types in programs correctly}
%
Let $R_E = \symrelpreds(\Gamma \union T)$.
%
The relational predicates of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$
are $\bigunion \setformer{ R_E^{\Gamma} \union R_E }{ E \in
  \antichains{ \cc{P}_0' }{ \cc{P}_1' }}$.

% define clauses
The clauses of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$ are defined as
follows.
%
\BH{define clauses for each relational type}

% define join of relational predicates:
For $\mathcal{R}, \mathcal{R}', \mathcal{R}''$,
%
\BH{patch}
%
, the clauses $\mathcal{R}\andsub(E_0, E_1, E')$ and $\orsub(E_0, E_1,
E')$ constrain that the conjunction (and similarly, disjunction) of
the relational types defined by interpretations of $\symrelpreds(E_0)$
and the interpretations of $\symrelpreds(E_1)$ is a subtype of the
interpretation of the $\symrelpreds(E')$.
%
I.e., if $R$
%
\BH{define clauses for subtype of conjunction (and
  disjunction). Maybe need to structure relational predicates in
  sequences.}
%
Such clauses are denoted $\mathcal{R} \joinctr \mathcal{R}' \subtype
\mathcal{R}''$.

\BH{remove indices}

% enumerate clauses per form of expression:
\verifybnd generates clauses that model each of the syntax-directed
typing rules given in (\autoref{fig:reltype-rules}).
% sets of atomic expressions:
For all $E_0 \subseteq \subexps{ P_0 }$ and $E_1 \subseteq \subexps{
  P_1 }$ such that $E_0$ and $E_1$ contain only atomic expressions,
\verifybnd generates the following clauses:
%
$\mathcal{R} \joinctr %
\bigland \setformer{ c = (c, i) }{ c \in \consts, i \in I, (c, i) \in E
} \subtype \mathcal{R}'$.

% clauses for op:
Let $e_0, e_1 \in \subexps{ \cc{P}_0 }$ such that $e_0 \oplus e_1
\in \subexps{ P_0 }$, %
$E_0 \subseteq \subexps{ P_0 }$, and %
$E_1 \subseteq \subexps{ P_1 }$.
%
\verifybnd generates the clauses
\begin{align*}
  % constrain contexts,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % subtyping of expression types:
  \mathcal{R}, %
  \resvar{e_0 \oplus e_1} = \resvar{e_0} \oplus \resvar{e_1} &
  \subtype \mathcal{R}'
\end{align*}
%
\BH{define subtyping constraint syntax over ops}
%
Similar clauses are included for all subexpressions of $P_1$ that are
constructed from binary operations.

% clauses for if-then-else:
For all $e_0, e_1, e_2 \in \subexps{ P_0' }$ and $E \subseteq
\subexps{ P_0 } \union \subexps{ P_1 }$, let $\mathcal{R} =
\symrelpreds(\elts{ e_0, e_1, e_2 } \union E)$ and $\mathcal{R}' =
\symrelpreds(\elts{ \ite{ e_0 }{ e_1 }{ e_2 } } \union E)$.
%
Then \verifybnd generates relational predicates $R_0$ and $R_1$ and
clauses
%
\BH{fix this defn}
\begin{align*}
  % context subtyping,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % copy the then expression to the whole expression:
  \mathcal{R}, \resvar{e_0} = \true & \subtype \mathcal{R}_T &
  % case where guard is true: define the copy predicates:
  \resvar{ e_1 } \equiv \resvar{ e } & \subtype \mathcal{COPY}_T &
  % copy value from the then expression to the whole expression:
  \mathcal{R}_T \joinctr \mathcal{COPY}_T & \subtype \mathcal{R}' &
  % assume that 
  \mathcal{R}_T, \resvar{ e_0 } = \true & \subtype \mathcal{R}'
  % case where guard is false:
\end{align*}
%
\BH{renamesub: remove use}
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_0 }{ \mathcal{ R }' }{ \resvar{ (e_1, i_1) }
}{ \resvar{(e, i)} }$,
%
\BH{define updated sets of relational predicates}
% add constraint for case where the guard is false,
$\ctrclause{ R }{ R_1 }{ \resvar{ (e_0, i) } = \false}$, and
%
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_1 }{ \mathcal{ R }' }{ \resvar{ (e_2, i_2) }
}{ \resvar{ (e, i) } }$.
%
Similar clauses are included for all \cc{if}-\cc{then}-\cc{else}
subexpressions of $P_1$.

% clause for abs
For all $x \in \vars$, %
$e \in \subexps{ P_0' }$ such that $\lambda x. e \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \subseteq \subexps{P_1}'$, \verifybnd adds clauses that solve
for a relational type of $x$, use it to strengthen the context for
typechecking the $e$.
%
I.e., \verifybnd generates a collection of relational predicates
$\mathcal{R}_x$ for $x$ grouped with $E_0$ and $E_1$, %
adds the clauses
% context for typechecking body is strengthen
$\mathcal{R}'_{\Gamma} \joinctr \mathcal{R}_x \subtype
\mathcal{R}_{\Gamma}$, %
% type of body is type of abstraction, after renaming:
$\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ \argnum{e} }$.
%
Similar clauses are included for all abstraction subexpressions of
$P_1$.

% clause for app
For all $e_0, e_1 \in \subexps{P_0'}$ such that $e_0\ e_1 \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \in \subexps{P_1'}$, let $E = E_0 \union \elts{ e_0, e_1 }
\union E_1$, %
let $E' = E_0 \union \elts{ e_0\ e_1 } \union E_1$, and %
let $f$ be a fresh variable with the same type as $x$.
%
\verifybnd adds the clauses 
% type of context is subtype of context over components:
$E_{\Gamma} \subtype E'_{\Gamma}$ and %
$\replace{ E }{ \firstarg{e_0} }{ f } \subtype \replace{ E }{ e_1 }{ f
}$.
%
\BH{define firstarg symbolic variable per expression}
%
Similar clauses are included for all application subexpressions of
$P_1$.

% define clauses for subsets of expressions
For all $E_0, E_0', E_0'' \in \antichains{ P_0' }$ and %
$E_1, E_1', E_1'' \in \antichains{ P_1' }$ such that $E_1 \union E_1'
= E_1''$, \verifybnd generates clauses $(E_0 \union E_1) \joinctr
(E_0' \union E_1') \subtype E_0'' \union E_1''$.

\BH{define the query of the system}

% walk through the other typing rules that aren't used.
\verifybnd does not generate clauses that model the typing rule
\textsc{Fix}, because an unfolding cannot contain a fixpoint
expression.
%
\verifybnd does not explicitly add clauses that model uses of the
\textsc{Sub} rule, given that a CHC solution may choose types for any
set of expressions that satisfy a subtyping relationship.
%
Sets of fixpoint variables are unconstrained, and in particular may be
interpreted as $\false$.

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to )$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $\replace{ E }{ f }{ \fix{ f }{ \fixexpr{ f } } }$ 
        } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$\fix{ f }{ e } \in E$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
