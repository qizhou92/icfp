% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-invs}, we define the class of proof
structures synthesized by \sys.
%
In \autoref{sec:verifier}, we present the verification algorithm used
by \sys to synthesize such structures.

\subsection{Relational invariants as equivalence proofs}
\label{sec:rel-invs}
%
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0$ is equivalent to $P_1$ that is represented as set of
subexpressions of $P_0$ and $P_1$, each mapped to relational
invariants that relate all evaluations of the subexpressions.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% define symbolic relations:
For each $i \in \elts{0, 1}$ and $n \in nats$, let $\symvarsidx{i}{n}$
denote a distinct set of symbolic variables.
%
\begin{defn}
  \label{defn:sym-rels}
  Let $R: \subexps(P_0)^{*} \times \subexps(P_1)^{*} \partto
  \formulas{ \bigunion_{i \in \elts{0 , 1}, n \in \nats }
    \symvarsidx{i}{n} }$ be such that %
  for all $E_0 \in \subexps(P_0)^{*}$ and $E_1 \in \subexps(P_1)^{*}$,
  $R(E_0, E_1) \in \formulas{ %
    \bigunion_{ 0 \leq i < |P_0|} \symvarsidx{0}{i} \union %
    \bigunion_{0 \leq j < |P_1|} \symvarsidx{1}{j} }$.
  %
  Then $R$ are \emph{symbolic relations}.
\end{defn}
%
The space of symbolic relations of $P_0$ and $P_1$ is denoted
$\symrels{P_0}{P_1}$.

% relational invariants
% define relational invariants
Relational invariants of $P_0$ and $P_1$ are a map from sets of
subexpressions of $P_0$ and $P_1$, with each set $S$ mapped to a
formula that relates the evaluations of all expressions in $S$.
%
Relational invariants soundly describe all steps of evaluation that
can be taken by $P_0$ and $P_1$.
\begin{defn}
  \label{defn:rel-invs}
  Let $R_0, R_1 \in \symrels{P_0}{P_1}$ be such that %
  % condition: relation of empty set is entailed by true:
  \textbf{(1)} $\true \entails R_0(\epsilon, \epsilon) \lor
  R_1(\epsilon, \epsilon)$;
  % condition: steps are valid:
  \textbf{(2)} for all $e_0 \in \subexps{P_0}^{*}$, %
  $E_0 \in \subexps{P_0}^{*}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \evalrules$ that decomposes $e_0$ to $E_0' \in
  \subexps(P_0)^{*}$, %
  there are some $E_0'', E_0''' \in \subexps{P_0}^{*}$ such that $E_0'
  \concat E_0 = E_0'' \concat E_0'''$ and
  \begin{align*}
    R_0(E_0'' \concat E_0''', E_1), %
    \subs{ \symstep{P_0}{ r } }{ \vars[ E_0' ], \vars[ e_0 ] } 
    & \entails R_0(e_0 \cons E_0, E_1) \\
    %
    R_1(E_0'' \concat E_0''', E_1), %
    \subs{ \symstep{P_0}{ r } }{ \vars[ E_0' ], \vars[ e_0 ] }
    & \entails R_0(e_0 \cons E_0, E_1)
  \end{align*}
  % symmetric condition for P1
  \textbf{(3)} for all $E_0 \in \subexps{P_0}^{*}$, %
  $e_1 \in \subexps{P_1}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \evalrules$ that decomposes $e_1$ to $E_1' \in
  \subexps(P_1)^{*}$, %
  there are some $E_1'', E_1''' \in \subexps{P_1}^{*}$ such that
  $E_1' \concat E_1 = E_1'' \concat E_1'''$ and
  \begin{align*}
    R_0(E_0, E_1'' \concat E_0'''), %
    \subs{ \symstep{P_1}{ r } }{ \vars[ E_0' ], \vars[ e_0 ] }
    & \entails R_1(E_0, e_1 \cons E_1) \\
    R_1(E_0, E_1'' \concat E_1'''), %
    \subs{ \symstep{P_1}{ r } }{ \vars[ E_1' ], \vars[ e_1 ] }
    & \entails R_1(E_0, e_1 \cons E_1) 
  \end{align*}
  %
  Then $R_0$ and $R_1$ are \emph{relational invariants} of $P_0$ and
  $P_1$.
\end{defn}
%
The space of relational invariants of $P_0$ and $P_1$ is denoted
$\relinvs{P_0}{P_1}$.

% strengthen relational invariants to evidence of equivalence:
If relational invariants $R$ are such that the invariant for $\elts{
  P_0, P_1 }$, combined with the assumption that $P_0$ and $P_1$ are
given equal values, entails that $P_0$ and $P_1$ evaluate to equal
values, then $R$ is evidence of the partial equivalence of $P_0$ and
$P_1$.
%
\begin{defn}
  \label{defn:eq-pf}
  Let $R \in \relinvs{P_0}{P_1}$ be such that $R(P_0, P_1), \alpha^0_0
  = \alpha^1_0 \entails \nu^0 = \nu^1$.
  %
  Then $R$ is \emph{evidence} of $P_0 \equiv P_1$.
\end{defn}

% example of relational invariants:
\begin{ex}
  \label{ex:rel-invs}
  \BH{give example relational invariants}
\end{ex}

% evidence is a valid proof of partial equivalence:
If there is evidence of the equivalence of $P_0$ and $P_1$, then $P_0
\equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are some $R \in \relinvs{P_0}{P_1}$ such that $R$ is
  evidence of $P_0 \equiv P_1$, then $P_0 \equiv P_1$.
\end{lemma}

% define class of invariants that are actually maintained
\sys, given programs $P_0$ and $P_1$ attempts to determine if $P_0
\equiv P_1$ by synthesizing evidence of $P_0 \equiv P_1$ from a map
from sets of derivations to relational invariants.
%
Let the space of such maps be denoted $\dersrels{P_0}{P_1} =
\subexps(P_0)^{*} \times \subexps(P_1)^{*} \to \symrels{P_0}{P_1}$.
%
\begin{defn}
  \label{defn:der-rel-invs}
  Let $I \in \dersrels{P_0}{P_1}$ be such that %
  \begin{enumerate}
  \item 
    % supports relational invariants of complete derivations:
    For all $D_0 \in \dertrees{P_0}$ and $D_1 \in \dertrees{P_1}$,
    \[ I([ D_0 ], [ D_1 ]), \alpha_0 = \alpha_1 \entails %
    \nu_0 = \nu_1 \]
  \item 
    % soundly models each step of P0:
    For all $d_0 \in \dertrees{P_0}$, %
    $D_0 \in \dertrees{P_0}^{*}$, %
    $D_1 \in \dertrees{P_1}^{*}$ such that $(d_0 \cons D_0, D_1) \in
    \domain(I)$, %
    there are some $D_0', D_0'' \in \dertrees{P_0}^{*}$ such that
    $\immsubtrees{d_0} \concat D_0 = D_0' \concat D_0''$ and %
    \[ I(D_0', D_1), I(D_0'', D_1), %
    \symstep{ \head{ \immsubtrees{ d_0 } } }{ d_0 } \entails %
    I(D_0, D_1) \]
  \item 
    % soundly models each step of P1:
    For all $D_0 \in \dertrees{P_0}^{*}$, %
    $d_1 \in \dertrees{P_1}$, %
    $D_1 \in \dertrees{P_1}^{*}$ such that $(D_0, d_1 \cons D_1) \in
    \domain(I)$, %
    there are some $D_1', D_1'' \in \dertrees{P_1}^{*}$ such that
    $\immsubtrees{d_1} \concat D_1 = D_1' \concat D_1''$ and %
    \[ I(D_0, D_1'), I(D_0, D_1''), %
    \symstep{ \head { \immsubtrees{ d_1 } } }{ d_1 } \entails %
    I(D_0, D_1) \]
  \end{enumerate}
  %
  Then $I$ are \emph{derivation relational invariants} of $P_0$ and
  $P_1$.
\end{defn}
%
The space of all derivation relational invariants for $P_0$ and $P_1$
is denoted $\dersinvs{P_0}{P_1}$.
%
\BH{add a running example}

% define inductive derivation relational invariants
Derivation relational invariants are inductive if they define
relational invariants.
%
In particular, for $I \in \dersinvs{P_0}{P_1}$, let $I' \in
\relinvs{P_0}{P_1}$ be such that for all $E_0 \in \subexps(P_0)^{*}$
and $e_1 \in \subexps(P_1)^{*}$,
\begin{align*}
  \exprel{I}(E_0, E_1) = %
  \biglor \setformer{ I(D_0, D_1)}{ %
    & d_0^0, \ldots, d_0^m \in \dertrees{P_0}^{*}, %
    \explabel{d_0^0}(\head{d_0^0}), \ldots,
    \explabel{d_0^m}(\head{d_0^m}) = E_0, \\
    & d_1^0, \ldots, d_1^n \in \dertrees{P_1}^{*},  %
    \explabel{d_1^0}(\head{d_1^0}), \ldots,
    \explabel{d_1^n}(\head{d_1^n}) = E_1 }
\end{align*}
%
Derivation invariants $I$ are inductive for $P_0$ and $P_1$ if they
are the union of two derivation relations that define relational
invariants of $P_0$ and $P_1$.
%
\begin{defn}
  \label{defn:inductive-der-rels}
  For $I_0, I_1 \in \dersrels{P_0}{P_1}$, if $(\exprel{I_0},
  \exprel{I_1})$ are relational invariants of $P_0$ and $P_1$, then
  $I_0 \union I_1$ are \emph{inductive} derivation relational
  invariants.
\end{defn}
%
Derivation relational invariants are evidence of partial equivalence,
by \autoref{lemma:equiv-evidence}.
%
\sys, given programs $P_0$ and $P_1$ attempts to determine their
partial equivalence by synthesizing inductive derivation relational
invariants.

\subsection{Verification algorithm}
\label{sec:verifier}
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:verify-begin}} %
  { \myproc{$\verifyaux(I)$ \label{line:aux-begin} }{ %
      % check if the solution is inductive:
      \Switch{$\chkinductive(I)$ \label{line:chkind} }{ %
        \lCase{$\isind$}{ %
          % case: it is. Return that P0, P1 are equivalent.
          \Return{$\true$} \label{line:ret-equiv} %
        } %
        \Case{$D_0 \in \dertrees{ \cc{P}_0 }, %
          D_1 \in \dertrees{ \cc{P}_1 }$ %
          \label{line:case-cex}}{ %
          \Switch{$\verifyders(D_0, D_1)$ \label{line:verify-ders} }{ %
            \lCase{$\nonequiv$:}{ %
              \Return{$\false$} \label{line:ret-non-equiv} %
            } %
            \Case{$I'$: \label{line:case-ders-invs} }{ %
              \Return{$\verifyaux(\mergeinvs(I, I'))$} %
              \label{line:recurse}
            } %
          } %
        } %
      } %
    } \label{line:aux-end} %
    \Return{$\verifyaux(\emptyset)$} \label{line:base-call} } %
  %
  \caption{% interface of verify:
    \verify: given $P_0, P_1 \in \stlc$, decides if $P_0 \equiv P_1$.
    % procedures used: 
    \verify uses procedures \mergeinvs (\autoref{sec:verifier}), %
    \chkinductive (\autoref{sec:chk-ind}), and %
    \verifyders (\autoref{sec:verify-ders}).
  }
  \label{alg:verify}
\end{algorithm}
% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:verify}.
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:verify-begin}),
defines a procedure $\verifyaux$ that, given derivation relational
invariants $I$, attempts to determine if $P_0 \equiv P_1$ by finding
inductive derivation relational invariants built from $I$
(\autoref{line:aux-begin}---\autoref{line:aux-end}).
%
\verify calls \verifyaux on the empty map of derivation relational
invariants and returns the result (\autoref{line:base-call}).

% verify auxiliary procedure:
\verifyaux, given derivation relational invariants $I$, runs procedure
\chkinductive on $I$ (\autoref{line:chkind}; \chkinductive is given in
\autoref{sec:chk-ind}).
%
If \chkinductive determines that some restriction of $I$ are
inductive, then \chkinductive returns the value $\isind$, and
\verifyaux returns that $P_0 \equiv P_1$ (\autoref{line:ret-equiv}).

% case: no inductive restriction found:
Otherwise, \chkinductive returns a derivation $D_0$ of $P_0$ and $D_1$
of $P_1$ that do not have derivation relational
invariants in $I$ (\autoref{line:case-cex}).
%
\verifyaux then runs a procedure \verifyders on $D_0$ and $D_1$
(\autoref{line:verify-ders}; \verifyders is given in
\autoref{sec:verify-ders}).
%
If \verifyders returns the value $\nonequiv$ to denote that $D_0$ and
$D_1$ are not equivalent, then \verifyaux returns that $P_0 \not\equiv
P_1$ (\autoref{line:ret-non-equiv}).

% subcase: finds path-pair invariants:
Otherwise, \verifyders returns relational derivation invariants $I'$
of $D_0$ and $D_1$ (\autoref{line:case-ders-invs}).
%
\verifyaux runs a procedure \mergeinvs on $I$ and $I'$, which
generates derivation relational invariants of all pairs of derivations
with relational invariants in both $I$ and $I'$.
%
\verifyaux recurses on the generated invariants and returns the result
(\autoref{line:recurse}).

% mergeinvs: combine using disjunction:
\mergeinvs, given derivation relational invariants $I, I' \in
\dersinvs{P_0}{P_1}$, generates $I'' \in \dersinvs{P_0}{P_1}$ such
that for each $D_0 \in \dertrees{P_0}$ and $D_1 \in \dertrees{P_1}$, %
\textbf{(1)} if $(D_0, D_1) \in \domain(I) \setminus \domain(I')$,
then $I''(D_0, D_1) = I(D_0, D_1)$;
%
\textbf{(2)} if $(D_0, D_1) \in \domain(I') \setminus \domain(I)$,
then $I''(D_0, D_1) = I'(D_0, D_1)$; %
\textbf{(3)} otherwise, $I''(D_0, D_1) = I(D_0, D_1) \lor I'(D_0,
D_1)$.

\subsubsection{Checking inductiveness of derivation invariants}
\label{sec:chk-ind}

%
\BH{define procedure that checks inductiveness of given relational
  invariants}

\subsubsection{Verifying equivalence of derivations}
\label{sec:verify-ders}
%
\verifyders, given derivations $D_0 \in \dertrees{P_0}$ and $D_1 \in
\dertrees{P_1}$, returns either relational derivation invariants of
pairs of tuples of sub-derivations of $D_0$ and $D_1$ that prove $D_0
\equiv D_1$ or the value $\nonequiv$ to denote that $D_0 \not\equiv
D_1$.
%
\verifyders reduces the problem of determining $D_0 \equiv D_1$ to
solving a series of recursion-free systems of Constrained Horn Clauses
(\autoref{sec:chcs}).
%
Let $\mathcal{C}_0 \subseteq \nodes{D_0}^{*}$ and $\mathcal{C}_1
\subseteq \nodes{D_1}^{*}$ be the cuts of $D_0$ and $D_1$,
respectively, and let $\mathcal{C}_0' \subseteq \nodes{D_0}$ and
$\mathcal{C}_1' \subseteq \nodes{D_1}$ be the subsequences of
$\mathcal{C}_0$ and $\mathcal{C}_1$, respectively.
%
For $C \in \mathcal{C}_0$ and $T \subseteq \mathcal{C}_0$, if $C$ is
the union of $T$, then $T$ is a \emph{tiling} of $C$, and similarly
for $\mathcal{C}_1$.

% introduce tiling relation:
For $E \subseteq (\pset(\mathcal{C}_0) \times \pset(\mathcal{C}_1))
\times (\mathcal{C}_0 \union \mathcal{C}_1)$ an arbitrary relation
from pairs of tilings to the pair of cuts that they tile, the
recursion-free CHC system $\mathcal{S}$ for $D_0$, $D_1$, and $E$ is
defined as follows.
%
\BH{restate this to put decompositions context}
% define relational predicates per tiling:
The relational predicates of $\mathcal{S}$ are $\mathcal{C}_0 \times
\mathcal{C}_1$.

% define clauses per tiling:
The clauses of $\mathcal{S}$ are defined as follows.
%
$\mathcal{S}$ contains clauses that model all steps of evaluation
taken by $P_0$.
%
In particular, for each $n' \in \nodes{D_0}$ with children $N \in
\nodes{D_0}^{*}$, %
$C_0 \in \mathcal{C}_0$ such that $n' \cons C_0 \in \mathcal{C}_0$,
$C_1 \in \mathcal{C}_1$, there is a clause %
\[ (N \concat C_0, C_1)[ \symvars{N}, \symvars{C_0}, \symvars{C_1} ], %
\derstep{D_0}{ n' } \entails %
(n' \cons C_0, C_1) \]
%
\BH{define shorthand, symbolic variables used}
%
$\mathcal{S}$ contains clauses that model all steps of evaluation
taken by $P_1$.
%
In particular, for each $n' \in \nodes{D_1}$ with children $N \in
\nodes{D_1}^{*}$, %
$C_0 \in \mathcal{C}_0$, and %
$n' \in \nodes{C_1}$, %
$C_1 \in \mathcal{C}_1$ such that $n' \cons C_1 \in \mathcal{C}_1$, %
there is a clause %
\[ (C_0, N \concat C_1)[ \symvars{C_0}, \symvars{N}, \symvars{C_1} ], %
\derstep{D_1}{ n' } \entails %
(n' \cons C_0, C_1) \]
%
For each decomposition in $E$, there is a clause that constrains that
the combination of invariants of a tiling entail the invariant of the
pair of cuts that they tile.
%
I.e., for each $\mathcal{M}_0 \subseteq \mathcal{C}_0$, %
$\mathcal{M}_1 \subseteq \mathcal{C}_1$, %
$C_0 \in \mathcal{C}_0$, and %
$C_1 \in \mathcal{C}_1$, there is a clause
%
\[ \setformer{ M_0[ \symvars{ M_0 } ]}{ M_0 \in \mathcal{M}_0 }, %
\setformer{ M_1[ \symvars{ M_1 } ] }{ M_1 \in \mathcal{M}_1 } \entails %
(C_0[ \symvars{C_0} ], C_1[ \symvars{C_1} ])
\]
%
The query node of $\mathcal{S}$ is $( [ \head{D_0} ], [ \head{D_1}
])$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
