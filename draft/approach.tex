% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-types}, we define a type system for proving
equivalence of programs.
%
In \autoref{sec:infer-rel-types}, we present an algorithm for
inferring such types.

\subsection{Relational properties as relational types}
\label{sec:rel-types}
%
In this section, we describe a space of types over collections of
expressions, which can represent proofs of equivalence of functional
programs.
%
In \autoref{sec:rel-type-space}, we give key instances of such types,
and operators for constructing such types.
%
In \autoref{sec:rel-type-sys}, we give a type system for relational
types.

\subsubsection{A space of relational types}
\label{sec:rel-type-space}

\BH{define space of type positions}

\BH{define relational types, parameterizd on base symbols}

\BH{define context relational type: base symbols are variables}

\BH{define context}

\BH{define positioned expressions. Examples: the empty map, mapping
  from positions to variables}

\BH{define result relational type: base symbols are variables
  expression positions. Example: the empty relational type}

\subsubsection{Operations over relational types}
\label{sec:rel-type-space}
%
The relational typing relation is defined using operators over
relational types.
%
The operators include generalizations of the type constructors and
operators over conventional types, generalizations of type operators
used in refinement type systems, and operators introduced to operate
over features unique to relational types.

% union as type operator:
For all relational types $\tau, \tau'$, the union of relational
predicates in $\tau$ and $\tau'$ (i.e., $\tau \union \tau'$) is a
relational type.
% renaming:
For $\tau \in \reltypes$ and symbols $x$ and $y$, the \emph{renaming}
from $x$ to $y$ in $\tau$, denoted $\replace{\tau}{x}{y}$, is $\tau$
with each logical variable of the form $(x, p)$, for $p \in \typepos$,
with $(x, p)$.
% position cons:
For $\tau \in \reltypes$, $f \in \typeposfield$, and symbol $x$, the
\emph{prepending} of $\tau$ with $f$ at $x$, denoted $f \cons_x \tau$,
is $\tau$ with each logical variable of the form $(x, p)$, for
$p \in \typepos$, replaced with $(x, f \cons p)$.

% define relational product:
The relational product of relational type $\tau$ from symbols $x$ and
$y$ to symbol $z$ is a relational type in which each pair of values
related at $x$ and $y$ in $\tau$ is a value at $z$.
%
I.e., the relational product of $\tau$ from $x$ and $y$ to $z$,
denoted $\times_{x, y}^z \tau$, is
\[ \replace{ (\tyleftprod \cons_x \tyrightprod \cons_y \tau) }{ x, y }{ p, p }
\]

% define relational sum:
The relational sum of types $\tau$ and $\tau'$ from symbols $x$ and
$y$ to $z$ is a relational type in which the disjoint union of values
related at $x$ and $y$ is a values at $z$.
%
I.e., the relational union of $\tau, \tau'$ from $x$ and $y$ to $z$,
denoted $\tau +_{x, y}^z \tau'$, is
\[ \replace{ (\tyleftsum \cons_x \tau \union \tyrightsum \cons_y
    \tau')}{ x, y }{ p, p }
\]

\BH{define unfolding of fixpoint type}
%
The unfolding of $\tau$ at symbol $x$ is $\tau$ with a partially
unfolded definition of the least-fixpoint type in which $x$ is
associated.
%


% define refinement
For $\tau \in \reltypes$, symbol $x$, and base term $t$,
%
\BH{background: define base terms}
%
the \emph{refinement} of $\tau$ for $x$ and $t$ extends $\tau$ with
base value $x$ set to $t$.
%
I.e., the refinement of $\tau$ for $x$ and $t$ is $\tau$ with each
refinement predicate $P$ replaced with the following predicate:
%
\begin{itemize}
\item % co-variant:
  If $P$ is covariant, then $P \land x = t$;
\item % contra-variant:
  If $P$ is contravariant, then $x = t \implies P$;
\item % bi-variant:
  If $P$ is bivariant, then $P$.
\end{itemize}
%
For each $y \in \vars$, the refinement of $\tau$ for $x$ and $y$ is
defined as follows.
%
\BH{complete}

\subsubsection{A relational type system}
\label{sec:rel-type-sys}

% rules for determining if expression sequences have a relational type:
\begin{figure}
  \centering
  \begin{gather*}
    % empty:
    \inference[ EMPTY ]{ }{
      % the empty map of expressions has relational type true
      \Gamma, \gamma \judges \cdot : \gamma } \qquad
    \inference[ FVAR ]{ }{
      % the empty map of expressions has relational type true
      \Gamma, \gamma \judges p \mapsto f : %
      \Gamma(f) \joinctr p \equiv f} \qquad
    % constant:
    \inference[ CONST ]{ %
      % remainder has type tau,
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ c } : %
      \tau \joinctr p \equiv c } \\
    % vars:
    \inference[ VAR ]{ %
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ a } : %
      \tau \joinctr p \equiv a } \qquad
    % base operation:
    \inference[ OP ]{ %
      % remainder has type tau,
      \Gamma, \gamma \judges %
      E[ \leftopchild \cons p \mapsto e_0, %
        \rightopchild \cons p \mapsto e_1 ] : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ e_0 \oplus e_1 } : %
      \tau \joinctr %
      p \equiv (\leftopchild \cons p \oplus \rightopchild \cons p) } \\
    % abstraction:
    \inference[ ABS ]{ 
      % extend the context and typecheck the body,
      \Gamma, \gamma \judges \upd{ E }{ p }{ e } : \tau }{ %
      % type of abstraction is
      \Gamma, \gamma' \judges \upd{ E }{ p }{ \lambda x. e } : %
      \gamma \to_p \tau } \qquad
    % application:
    \inference[ APP ]{ %
      % get type of abstraction,
      \Gamma, \gamma \judges \upd{E}{p}{e_0} : \tau \to_p \tau' \\
      % get type of argument that is the parameter type,
      \Gamma, \gamma \judges \upd{E}{p}{e_1} : \tau }{
      % return the result type
      \Gamma, \gamma \judges \upd{ E }{ p }{e_0\ e_1} : \tau' } \\
    % pairing:
    \inference[ PAIR ]{
      % get type of both expressions,
      \Gamma, \gamma \judges %
      E[ \leftchild \cons p \mapsto e_0, %
      \rightchild \cons p \mapsto e_1 ] : \tau }{
      % then type of pair is
      \Gamma, \gamma \judges \upd{E}{p}{ \pair{e_0}{e_1} } :
      \times_{\leftchild \cons p, \rightchild \cons p}^p \tau } \qquad
    % let:
    \inference[ LET ]{
      % get type of bound expression,
      \Gamma, \gamma \judges \upd{ E }{p}{ e_0 } : \times_{x, y}^p \gamma' &
      % get type of result under context that binds to x and y,
      \Gamma, \gamma' \judges e_1 : \tau }{
      % then complete let expression has type
      \Gamma, \gamma \judges \upd{E}{p}{ \letexp{x}{y}{e_0}{e_1} } : %
      \tau } \\
    % left injection:
    \inference[ LEFT ]{
      % get type of the nested exp,
      \Gamma, \gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma, \gamma \judges \upd{E}{p}{ \injl\ e} : %
      \tau +_{p, p}^p \tau' } \qquad
    % right injection:
    \inference[ RIGHT ]{
      % get type of the nested exp,
      \Gamma, \gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma, \gamma \judges \upd{E}{p}{ \injr\ e} : %
      \tau' +_{p, p}^p \tau } \\
    % match:
    \inference[ MATCH ]{
      % get type of matched exp,
      \Gamma, \gamma \judges \upd{E}{p}{e_0} : %
      \gamma' +_{x, y}^p \gamma'' \\
      % get type of left branch under context that binds x to left op,
      \Gamma, \gamma' \judges \upd{E}{p}{e_1} : \tau &
      % get type of right branch under context that binds y to right op,
      \Gamma, \gamma'' \judges \upd{E}{p}{e_2} : \tau }{
      % then type of match exp is type of both branches,
      \Gamma, \gamma \judges %
      \upd{E}{p}{ \matchexp{e_0}{ x }{e_1}{ y }{e_2} } : \tau } \qquad
    % fixpoint:
    \inference[ FIX ]{
      % get type of body under context that binds symbol to tau,
      \upd{ \Gamma }{ f }{ \gamma' }, \gamma \judges %
      \upd{ E }{ p }{ e } : \tau \\
      % constrain that tau' with result renamed to f is subtype of tau,
      \replace{ \tau }{ p }{ f } \subtype \gamma' }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ \fix{f}{e} }: \tau } \\
    % unfold:
    \inference[ UNFOLD ]{
      % if expressions have tau unfolded at p,
      \Gamma, \gamma \judges E : \unfold{\tau}{p} }{ 
      % then expressions have folded type
      \Gamma, \gamma \judges E : \tau } \qquad
    % subtype:
    \inference[ SUB ]{
      % if expressions have tau,
      \Gamma, \gamma \judges E : \tau &
      % and tau subtypes tau',
      \tau \subtype \tau' }{ %
      % then expressions have type tau'
      \Gamma, \gamma \judges E : \tau' }
  \end{gather*}
  \caption{A typing system for relational types.
    %
    Metavariable %
    $\gamma$ ranges over contexual relational types, %
    $\Gamma$ ranges over contexts, %
    $E$ ranges over positioned expressions, %
    $p$ ranges over expression positions, %
    $e$ ranges over expressions, %
    $\tau$ ranges over relational types, %
    $c$ ranges over constants, %
    $x$ and $y$ range over abstraction variables, %
    $f$ ranges over fixpoint variables, and %
    $a$ ranges over variables. }
  \label{fig:reltypes-rules}
\end{figure}

% define judgment:
The typing system is defined by the inductive inference rules given in
\autoref{fig:reltypes-rules}.
%
The inference rules consist of syntax-directed rules that define the
typing relation for arbitrary expressions in a map of positional
expressions, along with rules that define the typing relation for
special cases of positonal expressions and for assigning relational
least-fixed-point types and using the subtype relation.
% empty:
Rule~EMPTY establishes that under contextual relational type $\gamma$,
the empty positioned expressions have type $\gamma$.
% fixpoint var:
Rule~FVAR establishes that under context $\Gamma$, the positioned
expression that maps only position $p$ to fixpoint variable $f$ has
type $\Gamma(f)$ refined to set $p$ to $f$.

% const:
Rule~CONST establishes that if positioned expressions $E$ have type
$\tau$, then $E$ extended to bind position $p$ to constant $c$ have
type $\tau$ refined to set $p$ to $c$.
% variables:
Rule~VARS establishes that if $E$ have type $\tau$, then $E$ extended
to bind $p$ to variable $a$ have type $\tau$ refined to set $p$ to
$x$.
% op:
Rule~OP establishes that if $E$ extended to bind positoins
$\leftopchild \cons p$ and $\rightopchild \cons p$ to expressions
$e_0$ and $e_1$ have type $\tau$, then $E$ extended to bind $p$ to
$e_0 \oplus e_1$ have type $\tau$ refined to set $p$ to
$\leftopchild \cons p \oplus \rightopchild \cons p$.

% abs:
Rules~ABS and APP are defined using the relational function type
operator.
%
Rule~ABS establishes that if, under contextual relational type
$\gamma$, $E$ extended to bind $p$ to expression $e$ have type $\tau$,
then under contextual relational type $\gamma'$, $E$ extended to bind
$p$ to $\lambda x. e$ is a relational function from $\gamma$ to
$\tau'$ at $p$.
% app:
Rule~APP establishes that if %
\textbf{(1)} $E$ extended to bind $p$ to $e_0$ is a relational
function from $\tau$ to $\tau'$ at $p$ and %
\textbf{(2)} $E$ extended to bind $p$ to $e_1$ has type $\tau$, then
$E$ extended to bind $p$ to $e_0$ applied to $e_1$ has type $\tau'$.

% relational prod:
Rules~PAIR and LET are defined using the relational product type
operator.
% pair:
Rule~PAIR establishes that if $E$ extended to bind
$\leftchild \cons p$ and $\rightchild \cons p$ to $e_0$ and $e_1$ has
type $\tau$, then $E$ extended to bind $p$ to $e_0$ paired with $e_1$
is the relational product of $\tau$ from $\leftchild \cons p$ and
$\rightchild \cons p$ to $p$.
% let:
Rule~LET establishes that if %
\textbf{(1)} under $\gamma$, $E$ extended to bind $p$ to $e_0$ is the
relational product of $\gamma'$ from variables $x$ and $y$ to $p$;
%
\textbf{(2)} under $\gamma'$, $e_1$ has type $\tau$, then under
$\gamma$, $E$ extended to bind $p$ to $\letexp{x}{y}{e_0}{e_1}$ has
type $\tau$.

% relational sum:
Rules~LEFT, RIGHT, and MATCH are defined using the relational sum type
operator.
% left:
Rule~LEFT establishes that if $E$ extended to bind $p$ to $e$ has type
$\tau$, then $E$ extended to bind $p$ to the left injection of $e$ is
a relational sum of $\tau$ and any relational type $\tau'$ from $p$
and $p$ to $p$.
%
Rule~RIGHT is defined symmetrically to Rule~LEFT.
% match:
Rule~MATCH establishes that if %
\textbf{(1)} under $\gamma$, $E$ extended to bind $p$ to $e_0$ is a
relational sum of $\gamma'$ and $\gamma''$ from variables $x$ and $y$
to $p$;
% 
\textbf{(2)} under $\gamma'$, $E$ extended to bind $p$ to $e_1$ has
type $\tau''$; and
%
\textbf{(3)} under $\gamma''$, $E$ extended to bind $p$ to $e_2$ also
has type $\tau''$, then under $\gamma$, $E$ extended to bind $p$ to
$\matchexp{e_0}{x}{e_1}{y}{e_2}$ has type $\tau''$.

% fix:
Rule~FIX establishes that if %
\textbf{(1)} under $\Gamma$ extended to bind $f$ to $\gamma'$ and
$\gamma$, $E$ extended to bind $p$ to $e$ has type $\tau$; and %
\textbf{(2)} $\tau'$ with $p$ renamed to $f$ is a subtype of
$\gamma'$, then under $\Gamma$ and $\gamma$, $E$ extended to bind $p$
to $\fix{f}{e}$ has type $\tau$.
% unfold:
Rule~UNFOLD establishes that if $E$ has type $\tau$ unfolded at $p$,
then $E$ has type $\tau$.
% sub:
Rule~SUB establishes that if $E$ has type $\tau$ a subtype of $\tau'$,
then $E$ has type $\tau'$.

% types as proving equivalence:
\BH{deprecated}

\BH{state main soundness result}
% 
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0 \equiv P_1$ as a proof that $\elts{ P_0, P_1 } :
\tau_{\equiv}$.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% structures maintained by inference algorithm. Unfoldings:
\sys attempts to extract a proof that $P_0, P_1 : \tau_{\equiv}$ from
a map from sets of \emph{unfoldings} of sub-expressions of $P_0$
and $P_1$ to candidate relational types.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $f \in \vars$ and $e \in \expr$, the \emph{unfoldings} of
  $\fix{f}{e}$, denoted $\unfoldings{ \fix{f}{e} }$

 are the smallest set of expressions such that:
  %
  \begin{enumerate}
  \item $f \in \unfoldings{ \fix{f}{e} }$;
  \item For each $e' \in \unfoldings{ \fix{f}{e} }$, $\replace{
      \fix{f}{e} }{ f }{ e' } \in \unfoldings{ \fix{f}{e} }$.
  \end{enumerate}
\end{defn}
%
\BH{fix defn of unfoldings above to allow the unfolded expressions to
  occur as subexpressions of the main expressions}
%
\BH{give examples}

% invariant structure:
\BH{rename this}
%
Partial relational invariants assign sets of subexpressions to
relational types.
%
\begin{defn}
  \label{defn:inferred-invs}
  Let
  \begin{itemize}
  \item 
    % subexpressions of unfoldings:
    $\mathcal{E} \subseteq \pset(\subexps{ \unfoldings{P_0} } \union
      \subexps{\unfoldings{P_1} })$;
  \item
    % context types:
    $\Gamma : \mathcal{E} \to \reltypes$;
  \item
    % relational types of subexpressions:
    $T : \mathcal{E} \to \reltypes$
  \end{itemize}
  %
  be such that 
  \begin{itemize}
  \item 
    % set of programs has the equivalence type:
    $T( \elts{ P_0, P_1 } ) \entails \tau_{ \equiv }$; 
  \item 
    % type of set is subtype of type of extension with fixpoint
    % symbol
    For all $E \in \mathcal{E}$ and each $f \in \vars$, $T(E) \subtype
    T(\add{ f }{ E })$.
  \item 
    % relational types are consistent under tiling:
    For each $E \in \mathcal{E}$ and $E_0, E_1 \subseteq E$ such that
    $E = E_0 \union E_1$, it holds that $T(E_0) \land T(E_1) \subtype
    T(E)$.
  \item 
    % relational types are consistent under subtypes:
    For all $e \in \expr$, $E \subseteq \expr$ such that $\add{ e }{ E
    } \in \mathcal{ E }$, $\Gamma(\subexps{e} \union E) \judges
    \subexps{ e } \union E : T( \subexps{e} \union E)$ supports that
    $\Gamma(\add{ e }{ E }) \judges \add{ e }{ E } : T(\add{ e }{ E
    })$.
  \end{itemize}
\end{defn}
%
\BH{patch to account for how predecessors actually work in typing
  rules}
%
\BH{add choice conditions that make invariants evidence}

% define when invariants are inductive:
Unfolded invariants are inductive if they define a proof of the fact
that $P_0$ and $P_1$ have type $\tau_{\equiv}$.
% 
\begin{defn}
  \label{defn:ind-unfolded}
  \BH{complete}
\end{defn}

% evidence is a valid proof of partial equivalence:
If $P_0$ and $P_1$ have relational invariants, then $P_0 \equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are $R \in \relinvs{P_0}{P_1}$, then $P_0 \equiv P_1$.
\end{lemma}
%
\sys, given programs $P_0$ and $P_1$, attempts to determine their
partial equivalence by synthesizing inductive unfolded relational
types.

\subsection{Inferring relational types}
\label{sec:infer-rel-types}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(\cc{P}_0' \in \unfoldings{ \cc{P}_0 }, %
      \cc{P}_1' \in \unfoldings{ \cc{P}_1 })$}{ %
      % try to verify the unfoldings:
      \Switch{$\verifybnd(\cc{P}_0', \cc{P}_1')$ \label{line:ver-bnd} }{
        % if the verifier returns that the unfoldings aren't equivalent
        \lCase{$\nonequiv$}{ 
          % then the top-level returns that the programs aren't
          % equivalent
          \Return{$\false$} \label{line:ret-non-eq} }
        % if the verifier returns relational types of the unfoldings:
        \Case{$T \in \subexptypes{ \cc{P}_0' }{ \cc{P}_1' }$ %
          \label{line:subexp-types} }{ %
          % then check if they're inductive:
          \Switch{$\chkinductive(T)$ \label{line:chk-ind} }{ 
            \lCase{$\isind$}{ \Return{$\true$} \label{line:ret-eq} }
            \lCase{ %
              $\cc{P}_0'' \in \unfoldings{ \cc{P}_0 }, %
              \cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$}{
              \Return{$\verifyaux(\cc{P}_0'', \cc{P}_1'')$ %
                \label{line:ret-rec} }
            }
          }
        }
      }
    }
    \Return{$\verifyaux(\folded(\cc{P}_0), \folded(\cc{P}_1))$ %
      \label{line:core-base} }
  }
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier, which uses procedures
    \verifybnd (\autoref{sec:verify-ders}) and %
    \chkinductive (\autoref{sec:chk-ind}).  }
  \label{alg:infer}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:infer}.
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given $\cc{P}_0' \in
\unfoldings{ \cc{P}_0 }$ and $\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$,
attempts to determine if $P_0 \equiv P_1$ by typed subexpressions of
an unfolding 
%
\BH{fix}
%
of $\cc{P}_0'$ and $\cc{P}_1'$, or determines that $\cc{P}_0
\not\equiv \cc{P}_1$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the complete folding of $\cc{P}_0$ and
$\cc{P}_1$ and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given $\cc{P}_0 \in \unfoldings{\cc{P}_0}$ and $\cc{P}_1
\in \unfoldings{ \cc{P}_1 }$, runs procedure \verifybnd on $\cc{P}_0'$
and $\cc{P}_1'$ (\autoref{line:ver-bnd}).
%
If \verifybnd returns $\nonequiv$, then \verify returns that $\cc{P}_0
\not\equiv \cc{P}_1$ (\autoref{line:ret-non-eq}).

%
Otherwise, if \verifybnd returns $T \in \subexptypes{ \cc{P}_0' }{
  \cc{P}_1' }$,
%
\BH{define sub-expression types}
%
then \verify runs procedure \verifyaux on $T$
(\autoref{line:subexp-types}), then \verifybnd runs procedure
\chkinductive on $T$ (\autoref{line:chk-ind}).
%
If \chkinductive returns $\isind$, then \verify returns that $\cc{P}_0
\equiv \cc{P}_1$ (\autoref{line:ret-eq}).
% subcase: invariants are not inductive:
Otherwise, if \chkinductive returns $\cc{P}_0'' \in \unfoldings{
  \cc{P}_0 }$ and $\cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$, then
\verifyaux runs \verifyaux on $\cc{P}_0''$ and $\cc{P}_1''$ and
returns the result (\autoref{line:ret-rec}).

% overview the rest of the section
\autoref{sec:type-unfoldings} gives an implementation of
\autoref{sec:type-unfoldings};
%
\autoref{sec:chk-ind} gives an implementation of \chkinductive.

\subsubsection{Typing subexpressions of unfoldings}
\label{sec:type-unfoldings}
% give an overview:
\verifybnd, given $\cc{P}_0' \in \unfoldings{ \cc{P}_0 }$ and
$\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$, either returns types of the
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$ or returns $\nonequiv$
to denote that $\cc{P}_0' \not\equiv \cc{P}_1'$.
%
\verifybnd reduces this problem to solving a CHC system
(\autoref{sec:chcs}).
%
Each solution of the system defines types and contexts of
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$.
%
The clauses of the system correspond to rules for establishing types
of expressions (\autoref{fig:reltypes-rules}).

% give the construction in detail:
\BH{update}
%
\verifybnd generates the following CHC system $\mathcal{C}_{
  \cc{P}_0', \cc{P}_1' }$.
% define the space of relational predicates
Let $E \subseteq \subexps{ \cc{P}_0' } \union \subexps{ \cc{P}_1' }$.
% define relational predicates of a set of types:
For typed symbols $T$, let the set of relational predicates
$\symrelpreds{ T }$ be defined as follows.
% base case: T is the empty set of types:
If $T = \emptyset$, then $R_T = \emptyset$.
% inductive case: T is a non-empty set
Otherwise, let $R$ be such that for all $\tau_0, \ldots, \tau_n, \tau'
\in \reftypes$ such that $\tau = \tau_0 \rightarrow \ldots \rightarrow
\tau_n \rightarrow \tau'$, $R$ has variables corresponding to
$\tau_0$, \ldots, $\tau_n$, and $\tau'$.
%
Let $T'$ be collection of typed symbols in which each symbol is a pair
of a typed symbol $f \in T$ and the position of a higher-order
argument type in the type of $f$ in $T$.
%
Then $\symrelpreds{ T } = \add{ \symrelpreds{ T' } }{ R }$.

% define type of a context:
Let $\Gamma : E \times \vars \to \types$ map each $e \in E$ and each
$x \in \freevars(e)$ to its type in $e$, and let $R_E^{\Gamma} =
\symrelpreds( \Gamma )$.
%
Let $T : E \to \types$ map each $e \in E$ to its type under its
context in $\cc{P}_0$ or $\cc{P}_1$.
%
\BH{define all notions of base types in programs correctly}
%
Let $R_E = \symrelpreds(\Gamma \union T)$.
%
The relational predicates of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$
are $\bigunion \setformer{ R_E^{\Gamma} \union R_E }{ E \in
  \antichains{ \cc{P}_0' }{ \cc{P}_1' }}$.

% define clauses
The clauses of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$ are defined as
follows.
%
\BH{define clauses for each relational type}

% define join of relational predicates:
For $\mathcal{R}, \mathcal{R}', \mathcal{R}''$,
%
\BH{patch}
%
, the clauses $\mathcal{R}\andsub(E_0, E_1, E')$ and $\orsub(E_0, E_1,
E')$ constrain that the conjunction (and similarly, disjunction) of
the relational types defined by interpretations of $\symrelpreds(E_0)$
and the interpretations of $\symrelpreds(E_1)$ is a subtype of the
interpretation of the $\symrelpreds(E')$.
%
I.e., if $R$
%
\BH{define clauses for subtype of conjunction (and
  disjunction). Maybe need to structure relational predicates in
  sequences.}
%
Such clauses are denoted $\mathcal{R} \joinctr \mathcal{R}' \subtype
\mathcal{R}''$.

\BH{remove indices}

% enumerate clauses per form of expression:
\verifybnd generates clauses that model each of the syntax-directed
typing rules given in (\autoref{fig:reltype-rules}).
% sets of atomic expressions:
For all $E_0 \subseteq \subexps{ P_0 }$ and $E_1 \subseteq \subexps{
  P_1 }$ such that $E_0$ and $E_1$ contain only atomic expressions,
\verifybnd generates the following clauses:
%
$\mathcal{R} \joinctr %
\bigland \setformer{ c = (c, i) }{ c \in \const, i \in I, (c, i) \in E
} \subtype \mathcal{R}'$.

% clauses for op:
Let $e_0, e_1 \in \subexps{ \cc{P}_0 }$ such that $e_0 \oplus e_1
\in \subexps{ P_0 }$, %
$E_0 \subseteq \subexps{ P_0 }$, and %
$E_1 \subseteq \subexps{ P_1 }$.
%
\verifybnd generates the clauses
\begin{align*}
  % constrain contexts,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % subtyping of expression types:
  \mathcal{R}, %
  \resvar{e_0 \oplus e_1} = \resvar{e_0} \oplus \resvar{e_1} &
  \subtype \mathcal{R}'
\end{align*}
%
\BH{define subtyping constraint syntax over ops}
%
Similar clauses are included for all subexpressions of $P_1$ that are
constructed from binary operations.

% clauses for if-then-else:
For all $e_0, e_1, e_2 \in \subexps{ P_0' }$ and $E \subseteq
\subexps{ P_0 } \union \subexps{ P_1 }$, let $\mathcal{R} =
\symrelpreds(\elts{ e_0, e_1, e_2 } \union E)$ and $\mathcal{R}' =
\symrelpreds(\elts{ \ite{ e_0 }{ e_1 }{ e_2 } } \union E)$.
%
Then \verifybnd generates relational predicates $R_0$ and $R_1$ and
clauses
%
\BH{fix this defn}
\begin{align*}
  % context subtyping,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % copy the then expression to the whole expression:
  \mathcal{R}, \resvar{e_0} = \true & \subtype \mathcal{R}_T &
  % case where guard is true: define the copy predicates:
  \resvar{ e_1 } \equiv \resvar{ e } & \subtype \mathcal{COPY}_T &
  % copy value from the then expression to the whole expression:
  \mathcal{R}_T \joinctr \mathcal{COPY}_T & \subtype \mathcal{R}' &
  % assume that 
  \mathcal{R}_T, \resvar{ e_0 } = \true & \subtype \mathcal{R}'
  % case where guard is false:
\end{align*}
%
\BH{renamesub: remove use}
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_0 }{ \mathcal{ R }' }{ \resvar{ (e_1, i_1) }
}{ \resvar{(e, i)} }$,
%
\BH{define updated sets of relational predicates}
% add constraint for case where the guard is false,
$\ctrclause{ R }{ R_1 }{ \resvar{ (e_0, i) } = \false}$, and
%
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_1 }{ \mathcal{ R }' }{ \resvar{ (e_2, i_2) }
}{ \resvar{ (e, i) } }$.
%
Similar clauses are included for all \cc{if}-\cc{then}-\cc{else}
subexpressions of $P_1$.

% clause for abs
For all $x \in \vars$, %
$e \in \subexps{ P_0' }$ such that $\lambda x. e \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \subseteq \subexps{P_1}'$, \verifybnd adds clauses that solve
for a relational type of $x$, use it to strengthen the context for
typechecking the $e$.
%
I.e., \verifybnd generates a collection of relational predicates
$\mathcal{R}_x$ for $x$ grouped with $E_0$ and $E_1$, %
adds the clauses
% context for typechecking body is strengthen
$\mathcal{R}'_{\Gamma} \joinctr \mathcal{R}_x \subtype
\mathcal{R}_{\Gamma}$, %
% type of body is type of abstraction, after renaming:
$\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ \argnum{e} }$.
%
Similar clauses are included for all abstraction subexpressions of
$P_1$.

% clause for app
For all $e_0, e_1 \in \subexps{P_0'}$ such that $e_0\ e_1 \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \in \subexps{P_1'}$, let $E = E_0 \union \elts{ e_0, e_1 }
\union E_1$, %
let $E' = E_0 \union \elts{ e_0\ e_1 } \union E_1$, and %
let $f$ be a fresh variable with the same type as $x$.
%
\verifybnd adds the clauses 
% type of context is subtype of context over components:
$E_{\Gamma} \subtype E'_{\Gamma}$ and %
$\replace{ E }{ \firstarg{e_0} }{ f } \subtype \replace{ E }{ e_1 }{ f
}$.
%
\BH{define firstarg symbolic variable per expression}
%
Similar clauses are included for all application subexpressions of
$P_1$.

% define clauses for subsets of expressions
For all $E_0, E_0', E_0'' \in \antichains{ P_0' }$ and %
$E_1, E_1', E_1'' \in \antichains{ P_1' }$ such that $E_1 \union E_1'
= E_1''$, \verifybnd generates clauses $(E_0 \union E_1) \joinctr
(E_0' \union E_1') \subtype E_0'' \union E_1''$.

\BH{define the query of the system}

% walk through the other typing rules that aren't used.
\verifybnd does not generate clauses that model the typing rule
\textsc{Fix}, because an unfolding cannot contain a fixpoint
expression.
%
\verifybnd does not explicitly add clauses that model uses of the
\textsc{Sub} rule, given that a CHC solution may choose types for any
set of expressions that satisfy a subtyping relationship.
%
Sets of fixpoint variables are unconstrained, and in particular may be
interpreted as $\false$.

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to \reltypes)$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $\replace{ E }{ f }{ \fix{ f }{ \fixexpr{ f } } }$ 
        } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$\fix{ f }{ e } \in E$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
