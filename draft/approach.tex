% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-types}, we define a type system for proving
equivalence of programs.
%
In \autoref{sec:verifier}, we present an algorithm for inferring such
types.

\subsection{Equivalence proofs as relational types}
\label{sec:rel-types}
%
In this section, we describe a space of types over collections of
expressions, which can represent proofs of equivalence of functional
programs.
%
In \autoref{sec:rel-type-space}, we give key instances of such types,
and operators for constructing such types.
%
In \autoref{sec:rel-type-sys}, we give a type system for relational
types.

\subsubsection{A space of relational types}
\label{sec:rel-type-space}
%
\sys, given programs $P_0$ and $P_1$, attempts to verify that $P_0
\equiv P_1$ by synthesizing a proof that $(P_0, P_1)$ has a relational
type of equivalent programs.

% define relational types:
Relational types describe sets of tuples of values, each of which may
be a higher-order values.
%
\BH{define type positions (in background?)}
%
\begin{defn}
  \label{defn:rel-type}
  For $T \in \types^{*}$, $P_0, P_1 \subseteq ?? \times \typepos$, the
  space of relational types of $P_0$ in $T$ over $P_1$, denoted
  $\reltypes{ T }{ P_0 }{ P_1 }$, is the smallest space that satisfies
  the following conditions:
  % case: nil type is a relational type
  \textbf{(1)} $\nilrel \in \reltypes{ T }{ P_0 }{ P_1 }$;
  % case: constructed relational types from relational types:
  \textbf{(2)} for $P_B, P_F \subseteq \typepos{ T }$ the extensions
  of $P_0$ that are positions of base and function types, %
  $\tau \in \reltypes{ T }{ P_F }{ P_1 \union P_B }$, and %
  $\varphi \in \formulas{ P_1 \union P_B \union P_F }$, it holds that
  $(\tau, \varphi) \in \reltypespos{ T }{ P_0 }{ P_1 }$.
\end{defn}
%
For $T \in \types^{*}$, the relational types over $T$ are denoted
$\reltypestypes{ T } = \reltypespos{ T }{ ?? \times \epsilon }{
  \emptyset }$.
%
\BH{clean up so that type position only points into a type that
  actually has the position}
%
The space of relational types over all sequences of types is denoted
$\reltypes = \bigunion_{T \in \types^{*} } \reltypestypes{T}$.

\BH{give relational type of higher-order expressions from running
  example}

\BH{define the equivalence for any pair of base types}
%
For each $\tau \in \types$, there is a relational type $\tau_{\equiv}
\in \reltypestypes{ [ \tau, \tau] }$ such that for all $e_0, e_1 \in
\stlc$, if $e_0 \equiv e_1$, then $e_0$ paired with $e_1$ have type
$\tau_{\equiv}$.
%
\BH{define the equivalence type for each type}

% 
The definition of when a collection of expressions has a relational
type, and the connection between equivalence the each base type's
equivalence type, is given in \autoref{sec:rel-type-sys}.

\BH{define intersection of relational types}

\subsubsection{A system for relational types}
\label{sec:rel-type-sys}
% rules for determining if expression sequences have a relational type:
\begin{figure}
  \centering
  \begin{gather*}
    % rule: expressions are all atomic (constants or variables):
    \inference[ ATOMICS ]{ %
      E \subseteq \atomics %
    }{ \Gamma \judges E : \Gamma } \\
    % rule: expression is an op:
    \inference[ OP ]{ 
      \Gamma \judges %
      \elts{ (e_0, i_0), (e_1, i_1) } \disjunion E : \tau }{ %
      \Gamma \judges \disjadd{ (e_0 \oplus e_1, i) }{ E } : %
      \replace{ \tau }{ (e_0, i_0) \oplus (e_1, i_1) }{ %
        (e_0 \oplus e_1, i) } } \\
    % rule: expression is an if-then-else:
    \inference[ ITE ]{ %
      \Gamma \judges %
      \elts{ (e_0, i_0), (e_1, i_1), (e_2, i_2) } \disjunion E : %
      \tau }{ %
      \Gamma \judges \disjadd{ e \equiv \ite{ e_0 }{ e_1 }{ e_2 } }{ E } : %
      ((e_0, i_0) = \true \land %
      \replace{ \tau }{ \resvar{ (e_1, i_1) } }{ \resvar{(e, i)}
        }) \lor %
        ((e_0, i_0) = \false \land %
        \replace{ \tau }{ \resvar{(e_2, i_2)} }{\resvar{(e, i)}}) } \\
    % rule: multiset contains an expression that is an abstraction
    \inference[ ABS ]{ \Gamma, \tau \judges \disjadd{ (e, i) }{ E } : \tau' &
    }{ %
      \Gamma \judges \disjadd{ (\lambda x.\ e, i') }{ E } : %
      \replace{ \tau \rightarrow \tau' }{ x }{ \alpha_0 } } 
    % rule: expression is an application:
    \inference[ APP ]{ %
      \Gamma \disjadd{ (e_0, i_0) }{ E } : \tau_0 \rightarrow \tau_0' & 
      \Gamma \disjadd{ (e_1, i_1) }{ E } : %
      \replace{ \tau_0 }{ \alpha_0 }{ (e_1, i_1) }
    }{ \Gamma \disjadd{ (e_0\ e_1, i) }{ E } \judges \tau } \\
    % rule: expression is a fixpoint:
    \inference[ FIX ]{ %
      \Gamma, \tau \judges \disjadd{ (e, i'') }{ E } : \tau }{ %
      \Gamma \judges \disjadd{ ( \fix{ f }{ e }, i ) }{ E } : %
      \replace{ \tau }{ (f, i') }{ ( \fix{ f }{ e }, i ) }
    } \\
    % rule: subtyping:
    \inference[ SUB ]{ %
      \Gamma \judges E : \tau & \tau \subtype \tau'
    }{ \Gamma \judges E : \tau' } 
    % rule: split multiset of expressions:
    \inference[ UNION ]{ 
      \Gamma \judges E_0 : \tau_0 &
      \Gamma \judges E_1 : \tau_1 } %
    { \Gamma \judges E_0 \union E_1 : \tau_0 \land \tau_1 } 
  \end{gather*}
  \caption{A proof system for relational types.}
  \label{fig:reltypes-rules}
\end{figure}
%
\BH{atomics: fix to equate constants to copies in multisets}
% introduce the has-type relation
\BH{define the True relational type}
%
\BH{define subtyping rules}
%
Relational types are associated with multisets of program expressions
to prove that the expressions satisfy relational properties, such as
functional equivalence.
%
\autoref{fig:reltypes-rules} contains a set of inference rules that
define a proof system for establishing that a multiset of expressions
has a relational type.
%
For $\Gamma, \tau \in \reltypes$ and $E \multiset{ \expr }$, the fact
that under $\Gamma$, $E$ has type $\tau$ is denoted $\Gamma \judges E
: \tau$.

determining if sequences of expressions have
a relational type.
%
In particular, Rule~STEP0 asserts that if 
%
\BH{complete}
Rule~STEP1 asserts that if
%
\BH{complete}
% split 0: rule for splitting invariants over sequences:
Rule~SPLIT0 asserts that for all $E_0, E_0', E_0'' \in \expr^{*}$ such
that $E_0'$ and $E_0''$ tile $E_0$ and %
each $E_1 \in \expr^{*}$, if %
\textbf{(1)} under $\Gamma \in \relctxs$ restricted to $E_0'$ and
$E_1$, $(E_0', E_1)$ has type $\tau_0$ and %
\textbf{(2)} under $\Gamma$ restricted to $E_0''$ and $E_1$, $(E_0',
E_1)$ has type $\tau_1$, then under $\Gamma$, $(E_0, E_1)$ has type
as a type the conjunctive unification
%
\BH{fix in rules}
%
of $\tau_0$ and $\tau_1$.
% split 1: rule for splitting invariants over sequences:
Rule~SPLIT1 asserts that for each $E_0 \in \expr^{*}$ and %
all $E_1, E_1', E_1'' \in \subexps$ such that $E_1'$ and $E_1''$ tile
$E_1$, if %
\textbf{(1)} under $\Gamma \in \relctxs$ restricted to $E_0$ and
$E_1'$, $(E_0, E_1')$ has type $\tau_0$ and %
\textbf{(2)} under $\Gamma$ restricted to $E_0$ and $E_1''$, $(E_0,
E_1'')$ has type $\tau_1$, then under $\Gamma$, $(E_0, E_1)$ has as a
type the conjunctive unification
%
\BH{fix in rules}
%
of $\tau_0$ and $\tau_1$.

% types as proving equivalence:
\BH{state main soundness result}
% 
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0 \equiv P_1$ as a proof that $\elts{ P_0, P_1 } :
\tau_{\equiv}$.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% structures maintained by inference algorithm. Unfoldings:
\sys attempts to extract a proof that $P_0, P_1 : \tau_{\equiv}$ from
a map from multisets of \emph{unfoldings} of sub-expressions of $P_0$
and $P_1$ to candidate relational types.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $f \in \vars$ and $e \in \expr$, the \emph{unfoldings} of
  $\fix{f}{e}$, denoted $\unfoldings{ \fix{f}{e} }$

 are the smallest set of expressions such that:
  %
  \begin{enumerate}
  \item $f \in \unfoldings{ \fix{f}{e} }$;
  \item For each $e' \in \unfoldings{ \fix{f}{e} }$, $\replace{
      \fix{f}{e} }{ f }{ e' } \in \unfoldings{ \fix{f}{e} }$.
  \end{enumerate}
\end{defn}
%
\BH{fix defn of unfoldings above to allow the unfolded expressions to
  occur as subexpressions of the main expressions}
%
\BH{give examples}

% invariant structure:
Partial relational invariants are a map from multisets of unfoldings
to relational types.
%
\begin{defn}
  \label{defn:inferred-invs}
  Let
  \begin{itemize}
  \item 
    % subexpressions of unfoldings:
    $\mathcal{E} \subseteq \pset(\subexps{ \unfoldings{P_0} } \union
      \subexps{\unfoldings{P_1} })$;
  \item
    % context types:
    $\Gamma : \mathcal{E} \to \reltypes$;
  \item
    % relational types of subexpressions:
    $T : \mathcal{E} \to \reltypes$
  \end{itemize}
  %
  be such that 
  \begin{itemize}
  \item 
    % multiset of programs has the equivalence type:
    $T( \elts{ P_0, P_1 } ) \entails \tau_{ \equiv }$; 
  \item 
    % type of set is subtype of type of extension with fixpoint
    % symbol
    For all $E \in \mathcal{E}$ and each $f \in \vars$, $T(E) \subtype
    T(\disjadd{ f }{ E })$.
  \item 
    % relational types are consistent under tiling:
    For each $E \in \mathcal{E}$ and $E_0, E_1 \subseteq E$ such that
    $E = E_0 \union E_1$, it holds that $T(E_0) \land T(E_1) \subtype
    T(E)$.
  \item 
    % relational types are consistent under subtypes:
    For all $e \in \expr$, $E \subseteq \expr$ such that
    $\disjadd{e}{E} \in \mathcal{E}$, $\Gamma(\subexps{e} \union E)
    \judges \subexps{ e } \union E : T( \subexps{e} \union E)$
    supports that $\Gamma(\disjadd{e}{E}) \judges \disjadd{e}{E} :
    T(\disjadd{e}{E})$.
  \end{itemize}
\end{defn}
%
\BH{patch to account for how predecessors actually work in typing
  rules}
%
\BH{add choice conditions that make invariants evidence}

% define when invariants are inductive:
Unfolded invariants are inductive if they define a proof of the fact
that $P_0$ and $P_1$ have type $\tau_{\equiv}$.
% 
\begin{defn}
  \label{defn:ind-unfolded}
  \BH{complete}
\end{defn}

% evidence is a valid proof of partial equivalence:
If $P_0$ and $P_1$ have relational invariants, then $P_0 \equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are $R \in \relinvs{P_0}{P_1}$, then $P_0 \equiv P_1$.
\end{lemma}
%
\sys, given programs $P_0$ and $P_1$, attempts to determine their
partial equivalence by synthesizing inductive unfolded relational
types.

\subsection{Verification algorithm}
\label{sec:verifier}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(\cc{P}_0' \in \unfoldings{ \cc{P}_0 }, %
      \cc{P}_1' \in \unfoldings{ \cc{P}_1 })$}{ %
      % try to verify the unfoldings:
      \Switch{$\verifyunfoldings(\cc{P}_0, \cc{P}_1)$}{
        % if the verifier returns that the unfoldings aren't equivalent
        \lCase{$\nonequiv$}{ 
          % then the top-level returns that the programs aren't
          % equivalent
          \Return{$\false$} }
        % if the verifier returns relational types of the unfoldings:
        \lCase{$T \in \reltypes{ P_0 }{ P_1 }$}{ %
          % then check if they're inductive:
          \Switch{$\chkinductive(T)$}{ 
            \lCase{$\isind$}{ \Return{$\true$} }
            \lCase{ %
              $\cc{P}_0'' \in \unfoldings{ \cc{P}_0 }, %
              \cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$}{
              \Return{$\verifyaux(\cc{P}_0'', \cc{P}_1'')$}
            }
          }
        }
      }
    }
    \Return{$\verifyaux(\onestep(\cc{P}_0), \onestep(\cc{P}_1))$ %
      \label{line:core-base} }
  }
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier, which uses procedures
    \chkinductive (\autoref{sec:chk-ind}), \verifyunfoldings
    (\autoref{sec:verify-ders}), and %
    \mergeinvs (\autoref{sec:merge}).  }
  \label{alg:verify}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:verify}.
%
\BH{update}
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given $T \in
\unfoldreltypes{P_0}{P_1}$, attempts to determine if $P_0 \equiv P_1$ by
finding inductive derivation relational invariants built from $T$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the empty map of derivation relational
invariants and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given $T \in \unfoldreltypes{P_0}{P_1}$, runs procedure
\chkinductive on $T$ (\autoref{line:core-chkind};
%
\chkinductive is given in \autoref{sec:chk-ind}).
%
If \chkinductive determines that some restriction of $T$ are
inductive, then \chkinductive returns the value $\isind$, and
\verifyaux returns that $P_0 \equiv P_1$
(\autoref{line:core-ret-equiv}).

% case: no inductive restriction found:
Otherwise, \chkinductive returns $d_0 \in \evalders{ P_0 }$ and $d_1
\in \evalders{ P_1 }$ that do not have derivation relational
invariants in $T$ (\autoref{line:core-case-cex}).
%
\verifyaux then runs a procedure \verifyunfoldings on $d_0$ and $d_1$
(\autoref{line:core-vders}; \verifyunfoldings is given in
\autoref{sec:verify-ders}).
%
If \verifyunfoldings returns the value $\nonequiv$ to denote that $d_0
\not\equiv d_1$ (\autoref{line:core-subcase-non-equiv}), then
\verifyaux returns that $P_0 \not\equiv P_1$
(\autoref{line:core-ret-non-equiv}).

% subcase: finds path-pair invariants:
Otherwise, \verifyunfoldings returns $T' \in \unfoldreltypes{d_0}{d_1}$
(\autoref{line:core-subcase-invs}).
%
\verifyaux runs a procedure \mergeinvs on $T$ and $T'$, which
generates derivation relational invariants of all pairs of derivations
with relational invariants in $T$ or $T'$;
%
\mergeinvs is given in \autoref{sec:merge}.
%
\verifyaux recurses on the generated invariants and returns the result
(\autoref{line:core-recurse}).

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to \reltypes)$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $\replace{ E }{ f }{ \fix{ f }{ \fixexpr{ f } } }$ 
        } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$\fix{ f }{ e } \in E$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...

\subsubsection{Verifying equivalence of unfoldings}
\label{sec:verify-ders}
% give an overview:
$\verifyunfoldings$, given an unfolding $\cc{P}_0'$ of $\cc{P}_0$ and
an unfolding $\cc{P}_1'$ of $\cc{P}_1$, either returns proofs that
$\cc{P}_0'$ and $\cc{P}_1'$ are equivalent, or returns $\nonequiv$ to
denote that $\cc{P}_0'$ and $\cc{P}_1'$ are not equivalent.
%
$\verifyunfoldings$ reduces this problem to solving a CHC system
(\autoref{sec:chcs}).
%
The relational predicates of the system correspond to contexts and
types of subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$.
%
The clauses of the system correspond to the proof values for
establishing valid types of sets of expressions
(\autoref{fig:reltype-rules}).

% give the construction in detail:
$\verifyunfoldings$ constructs the following CHC system $\mathcal{C}_{
  \cc{P}_0', \cc{P}_1' }$.
% define the space of relational predicates
Let $E \in \antichains{ \cc{P}_0' }{ \cc{P}_1' }$ be an arbitrary
anti-chain of $\cc{P}_0'$ and $\cc{P}_1'$.
% define relational predicates of a set of types:
For typed symbols $T$, let the set of relational predicates
$\symrelpreds{T}$ be defined as follows.
% base case: T is the empty set of types:
If $T = \emptyset$, then $R_T = \emptyset$.
% inductive case: T is a non-empty set
Otherwise, let $R$ be such that for each type $\tau = \tau_0
\rightarrow \ldots \rightarrow \tau_n \rightarrow \tau'$, $R$ has
variables corresponding to $\tau_0$, \ldots, $\tau_n$, and $\tau'$.
%
Let $T'$ be collection of typed symbols in which each symbol is a pair
of a typed symbol $f \in T$ and the position of a higher-order
argument type in the type of $f$ in $T$.
%
Then $\symrelpreds{T} = \add{ \symrelpreds{ T' } }{ R }$.

% define type of a context:
Let $\Gamma : E \times \vars \to \types$ map each $e \in E$ and each
$x \in \freevars(e)$ to its type in $e$, and let $R_E^{\Gamma} =
\symrelpreds(\Gamma)$.
%
Let $T: E \to \types$ map each $e \in E$ to its type under its context
in $\cc{P}_0$ or $\cc{P}_1$.
%
\BH{define all notions of base types in programs correctly}
%
Let $R_E = \symrelpreds(\Gamma \union T)$.
%
The relational predicates of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$
are $\bigunion \setformer{ R_E^{\Gamma} \union R_E }{ E \in
  \antichains{ \cc{P}_0' }{ \cc{P}_1' }}$.

% define clauses
The clauses of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$ are synthesized
as follows.
% define operations over types
For $E_0, E_1, E' \in \antichains{ \cc{P}_0' }{ \cc{P}_1' }$, the
clauses $\andsub(E_0, E_1, E')$ and $\orsub(E_0, E_1, E')$ constrain
that the conjunction (and similarly, disjunction) of the relational
types defined by interpretations of $\symrelpreds(E_0)$ and the
interpretation of $\symrelpreds(E_1)$ is a subtype of the
interpretation of the $\symrelpreds(E')$.
%
I.e., if $R$
%
\BH{define clauses for subtype of conjunction (and
  disjunction). Maybe need to structure relational predicates in
  sequences.}
%
\BH{define clauses for subtyping with renaming}
For collections 
%
\BH{define}
%
of relational predicates $\mathcal{R}$ over typed variables $X$,
relational predicates $\mathcal{R}'$ over typed variables $X$ and
variables $x \in X$ and $y \in Y$ with the same type, the clauses
$\renamesub{ \mathcal{R} }{ \mathcal{R'} }{ x }{ y }$ constrain that
each interpretation of $\mathcal{R}$ is a subtype of each
interpretation of $\mathcal{R}'$, with variables that model component
types of $x$ in $\mathcal{R}$ replaced with variables that model
corresponding component types of $y$.
%
Let the \emph{renaming clauses} from $x$ to $y$, denoted
$\renameclauses{ x }{ y }{ \mathcal{R} }$, be the following clauses.
%
\BH{define renaming clauses}
%
Then $\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ y }$ is, for
relational predicates $\mathcal{R}''$ over $x$ and $y$,
$\renameclauses{ x }{ y }{ \mathcal{R} } \union \andsub( \mathcal{R},
\mathcal{R}'', \mathcal{R}')$.
% define constraint clauses:
For relational predicate $R$ over logical variables $X$, %
relational predicate $R'$ over logical vocabulary $X'$ and constraint
$\varphi$ over $X \union X'$, the \emph{constraint clause} of $R$,
$R'$, and $\varphi$, are denoted $\ctrclause{ R }{ R' }{\varphi}$, is
\[ R(X), \varphi \implies R(X')
\]

% enumerate all of the actual clauses generated:
\BH{define clauses for subsets of expressions}
%
For all $E_0, E_1, E \in \antichains{ \cc{P}_0' }{ \cc{P}_1' }$ such
that $E_0 \union E_1 = E$, there are clauses $\andsub(E_0, E_1, E)$.
%
There are also clauses that model each syntax-directed typing rule
given in (\autoref{fig:reltype-rules}).
%
\BH{clause for atomics}

% clause for op:
For all $e_0, e_1 \in \subexps{ \cc{P}_0 }$ and $E \subseteq \subexps{
  \cc{P}_0 } \union \subexps{ \cc{P}_1 }$, there is a clause
\[ (E \disjunion \elts{ (e_0, i_0), (e_1, i_1) } ), %
\resvar{ (e_0, i_0) } \oplus \resvar{ (e_1, i_1) } = %
\resvar{ (e_0 \oplus e_1, i') } \implies %
\disjadd{ E }{ (e_0 \oplus e_1, i') }
\]
%
\BH{cleanly handle first-order variables}
%
Similar clauses are included for all subexpressions of $P_1$ that are
constructed from binary operations.

%
\BH{clause for ite}
%
For all $e_0, e_1, e_2 \in \subexps{ P_0' }$ and $E \subseteq
\subexps{ P_0 } \union \subexps{ P_1 }$, let $\mathcal{R} =
\symrelpreds(E \disjunion \elts{ e_0, e_1, e_2 })$ and $\mathcal{R}' =
\symrelpreds(E \disjunion \elts{ \ite{e_0}{e_1}{e_2} })$.
%
Then there are relational predicates $R_0$ and $R_1$ and clauses
% add constraint for case where the guard is true,
$\ctrclause{ R }{ R_0 }{ \resvar{ (e_0, i) } = \true}$,
%
\BH{define R}
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_0 }{ \mathcal{ R }' }{ \resvar{ (e_1, i_1) }
}{ \resvar{(e, i)} }$,
%
\BH{define updated sets of relational predicates}
% add constraint for case where the guard is false,
$\ctrclause{ R }{ R_1 }{ \resvar{ (e_0, i) } = \false}$, and
%
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_1 }{ \mathcal{ R }' }{ \resvar{ (e_2, i_2) }
}{ \resvar{ (e, i) } }$.
%
Similar clauses are included for all \cc{if}-\cc{then}-\cc{else}
subexpressions of $P_1$.

\BH{clause for abs}
%
For all 

Similar clauses are included for all abstraction subexpressions of
$P_1$.

\BH{clause for app}

Similar clauses are included for all application subexpressions of
$P_1$.

\BH{define the query of the system}

% talk about how interpretation for S is translated to derivation
% relational invariants:
\verifyunfoldings runs the CHC solver \solvechc on $\mathcal{S}$.
%
If \solvechc returns that $\mathcal{S}$ has no solution, then
\verifyunfoldings returns $\nonequiv$, to denote that $d_0 \not\equiv d_1$.
%
Otherwise, if \solvechc returns some $\sigma \in \solutions{
  \mathcal{S} }$, then \verifyunfoldings returns $I \in
\unfoldreltypes{P_0}{P_1}$, where for each $\Gamma_0 \in \derctxs{ P_0
}$ and $\Gamma_1 \in \derctxs{ P_1 }$,
\[ I(\Gamma_0, \Gamma_1) = %
\subs{ \sigma(\Gamma_0, \Gamma_1) }{ %
  \symvars{ \headexps( \Gamma_0 ) }, %
  \symvars{ \headexps( \Gamma_1 ) } } \]

\subsubsection{Merging Derivation Relational Invariants}
\label{sec:merge}
% mergeinvs: give components of invariants 0:
$\mergeinvs$, given $I_0, I_1 \in \unfoldreltypes{P_0}{P_1}$, returns $I'
\in \unfoldreltypes{P_0}{P_1}$ such that
% case: domain is only P0:
\textbf{(1)} for $C_0 = \domain(I_0) \setminus \domain(I_1)$,
$\restrict{I'}{C_0} = \restrict{I_0}{C_0}$; 
% case: domain is only P1:
\textbf{(2)} for $C_1 = \domain(I_1) \setminus \domain(I_0)$,
$\restrict{I'}{C_1} = \restrict{I_1}{C_1}$;
% case: domain is intersection:
\textbf{(3)} for all $\Gamma \in \domain(I_0) \intersection
\domain(I_1)$, $I'(\Gamma) = I_0(\Gamma) \lor I_1(\Gamma)$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
