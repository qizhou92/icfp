% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-invs}, we define the class of proof
structures synthesized by \sys.
%
In \autoref{sec:verifier}, we present the verification algorithm used
by \sys to synthesize such structures.

\subsection{Relational invariants as equivalence proofs}
\label{sec:rel-invs}
%
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0$ is equivalent to $P_1$ that is represented as set of
subexpressions of $P_0$ and $P_1$, each mapped to relational
invariants that relate all evaluations of the subexpressions.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% define symbolic relations:
For each $i \in \elts{0, 1}$ and $n \in nats$, let $\symvarsidx{i}{n}$
denote a distinct set of symbolic variables.
%
Let $\subexpseqs = \subexps(P_0)^{*} \times \subexps(P_1)^{*}$.
%
\begin{defn}
  \label{defn:sym-rels}
  Let $R: \subexpseqs \partto \formulas{ \bigunion_{i \in \elts{0 ,
        1}, n \in \nats } \symvarsidx{i}{n} }$ be such that %
  for all $E_0 \in \subexps{P_0}^{*}$ and $E_1 \in \subexps{P_1}^{*}$,
  $R(E_0, E_1) \in \formulas{ %
    \bigunion_{ 0 \leq i < |P_0|} \symvarsidx{0}{i} \union %
    \bigunion_{0 \leq j < |P_1|} \symvarsidx{1}{j} }$.
  %
  Then $R$ are \emph{symbolic relations}.
\end{defn}
%
The space of symbolic relations of $P_0$ and $P_1$ is denoted
$\symrels{P_0}{P_1}$.

% relational invariants
% define relational invariants
Relational invariants of $P_0$ and $P_1$ are a map from sets of
subexpressions of $P_0$ and $P_1$, with each set $S$ mapped to a
formula that relates the evaluations of all expressions in $S$.
%
Relational invariants soundly describe all steps of evaluation that
can be taken by $P_0$ and $P_1$.
%
\begin{defn}
  \label{defn:rel-invs}
  Let $R_0, R_1 \in \symrels{P_0}{P_1}$ be such that %
  % condition: relation of empty sequences is entailed by true:
  \textbf{(1) \& (2)} $\true \entails R_0(\epsilon, \epsilon)$ and
  $\true \entails R_1(\epsilon, \epsilon)$;
  % steps in P0 are valid:
  \textbf{(2)} for all $E_0 \in \subexps{P_0}^{*}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \instrules{P_0}$, %
  there are some $E_0', E_0'' \in \subexps{P_0}^{*}$ such that
  $\rulepreds{r} \concat E_0 = E_0' \concat E_0''$ and
  \[ R_0(E_0' \concat E_0'', E_1), %
  R_1(E_0' \concat E_0'', E_1), %
  \symstep{ P_0 }{ r } \entails R_0(\rulesucc{r} \cons E_0, E_1) \]
  % symmetric condition for P1:
  \textbf{(3)} for all $E_0 \in \subexps{P_0}^{*}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \instrules{P_1}$, %
  there are some $E_1', E_1'' \in \subexps{P_1}^{*}$ such that
  $\rulepreds{r} \concat E_1 = E_1' \concat E_1''$ and
  \[ R_0(E_0, E_1' \concat E_0''), %
  R_1(E_0, E_1' \concat E_0''), %
  \symstep{P_1}{ r } \entails R_1(E_0, \rulesucc{r} \cons E_1) \]
  %
  Then $R_0$ and $R_1$ are \emph{relational invariants} of $P_0$ and
  $P_1$.
\end{defn}
%
The space of relational invariants of $P_0$ and $P_1$ is denoted
$\relinvs{P_0}{P_1}$.

% strengthen relational invariants to evidence of equivalence:
If relational invariants $R$ are such that the invariant for $\elts{
  P_0, P_1 }$, combined with the assumption that $P_0$ and $P_1$ are
given equal values, entails that $P_0$ and $P_1$ evaluate to equal
values, then $R$ is evidence of the partial equivalence of $P_0$ and
$P_1$.
%
\begin{defn}
  \label{defn:eq-pf}
  Let $R \in \relinvs{P_0}{P_1}$ be such that $R(P_0, P_1), \alpha^0_0
  = \alpha^1_0 \entails \nu^0 = \nu^1$.
  %
  Then $R$ is \emph{evidence} of $P_0 \equiv P_1$.
\end{defn}

% example of relational invariants:
\begin{ex}
  \label{ex:rel-invs}
  \BH{give example relational invariants}
\end{ex}

% evidence is a valid proof of partial equivalence:
If there is evidence of the equivalence of $P_0$ and $P_1$, then $P_0
\equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are some $R \in \relinvs{P_0}{P_1}$ such that $R$ is
  evidence of $P_0 \equiv P_1$, then $P_0 \equiv P_1$.
\end{lemma}

% define class of invariants that are actually maintained
\sys, given programs $P_0$ and $P_1$ attempts to determine if $P_0
\equiv P_1$ by synthesizing evidence of $P_0 \equiv P_1$ from a map
pairs of sequences of derivations of subexpressions of $P_0$ and $P_1$
to relational invariants.
%
\begin{defn}
  \label{defn:der-structs}
  % nodes:
  Let \textbf{(1)} $N$ be a finite space, %
  % expressions annotations:
  % invariants annotations:
  \textbf{(2)} $I: N \to \relinvs{P_0}{P_1}$,
  % step edges in P0:
  \textbf{(3)} $S_0 : N \times \instrules{P_0} \partto N$, %
  % step edges in P1:
  \textbf{(4)} $S_1 : N \times \instrules{P_1} \partto N$, %
  % tilings in P0:
  \textbf{(5)} $T_0 : N \times \subexps{P_0}^{*} \times
  \subexps{P_0}^{*} \to N$, and
  % tilings in P1:
  \textbf{(6)} $T_1 : N \times \subexps{P_1}^{*} \times
  \subexps{P_1}^{*} \to N$ be such that the following conditions
  hold.
  % define the dependence relation:
  \textbf{(a)} Let $E \subseteq N \times N$ be such that for each $n
  \in N$, %
  for each $r \in \instrules{P_0}$ such that $(n, r) \in
  \domain(S_0)$, it holds that $(S_0(n, r), n) \in E$, %
  for each $r \in \instrules{P_1}$ such that $(n, r) \in
  \domain(S_1)$, it holds that $(S_1(n, r), n) \in E$, %
  for all $n_0, n_1 \in N$, %
  for all $E_0, E_0' \in \subexps{P_0}^{*}$ such that $T_0(n, E_0, E_0')
  = (n_0, n_1)$, it holds that $E(n_0, n)$ and $E(n_1, n)$, %
  for all $E_1, E_1' \in \subexps{P_1}^{*}$ such that $T_1(n, E_1,
  E_1') = (n_0, n_1)$, it holds that $E(n_0, n)$ and $E(n_1, n)$.
  %
  Then $(N, E)$ is a DAG.
  %
  \textbf{(b)} For each $n \in N$ and $r \in \instrules{P_0}$ such
  that $(n, r) \in \domain(S_0)$,
  % each E0 edge models a step of P0:
  \[ I(n), \symstep{ P_0 }{ r } \entails I(S_0(n, r))
  \]
  %
  \textbf{(c)} For each $n \in N$ and $r \in \instrules{P_1}$ such
  that $S_1(n, r)$ is defined,
  % each E0 edge models a step of P0:
  \[ I(n), \symstep{ P_1 }{ r } \entails I(S_1(n, r))
  \]
  % H has a unique source annotated with empty seqs
  \textbf{(d)} for each source node $n \in N$ of $H$, it holds that
  $\true \entails I(n)$, and
  % H has a unique sink annotated with P0, P1
  \textbf{(e)} $H$ has a unique sink node $n' \in N$, such that $I(n'),
  \alpha_0 = \alpha_1 \entails \nu_0 = \nu_1$, %
  % invariants respect entailments over decompositions:
  for all $n_0, n_1, n' \in N$, %
  \textbf{(f)} for all $E_0, E_0' \in \subexps{P_0}^{*}$ such that
  $T_0(n', E_0, E_0') = (n_0, n_1)$,
  \[ I(n_0), I(n_1) \entails I(n') \] %
  \textbf{(g)} for all $E_1, E_1' \in \subexps{P_1}^{*}$ such that 
  $T_1(n', E_0, E_0') = (n_0, n_1)$, %
  \[ I(n_0), I(n_1) \entails I(n') \]
  %
  Then $(N, I, S_0, S_1, T_0, T_1)$ is a \emph{derivation structure}
  of $P_0$ and $P_1$.
\end{defn}
%
The space of derivation structures of $P_0$ and $P_1$ is denoted
$\derstructs{P_0}{P_1}$.
%
For each $I \in \dersinvs{P_0}{P_1}$, the components of $I$ are
denoted $\nodes{I}$, $\invsof{I}$, $\stepedges{P_0}{I}$,
$\stepedges{P_1}{I}$, $\tilesof{P_0}{I}$, and $\tilesof{P_1}{I}$,
respectively.
%
The sink node of $I$ is denoted $\sinkof{I}$.

\BH{define tilings of sequences}
% derive map for derivation relational invariants:
Some derivation structures define invariants of all evaluations of
sequences of expressions.
\begin{defn}
  \label{defn:der-rel-invs}
  % introduce components of structure:
  Let $N$, $I : N \to \symrels{P_0}{P_1}$, %
  $S_0 : N \times \instrules{P_0} \partto N$, %
  $S_1 : N \times \instrules{P_1} \partto N$, %
  $T_0 : N \times \subexps{P_0}^{*} \times \subexps{P_0}^{*} \partto
  N$, and %
  $T_1 : N \times \subexps{P_1}^{*} \times \subexps{P_1}^{*} \partto
  N$ be such that $(N, I, S_0, S_1, T_0, T_1) \in
  \derstructs{P_0}{P_1}$.

  % introduce map over subexpressions of P0
  Let there be some $E_0 : N \to \subexps{P_0}^{*}$ that satisfies the
  following conditions.
  % maps sink to just P0:
  \textbf{(a)} $E_0(\sinkof{I}) = [ P_0 ]$;
  % respects steps in P0:
  \textbf{(b)} for each $n \in N$ and $r \in \instrules{P_1}$ such
  that $S_0(n, r)$ is defined, and for $e_0 \in \subexps{P_0}$ and $E'
  \in \subexps{P_0}^{*}$ such that $E_0(n) = e_0 \cons E'$, it holds
  that $E_0( S_0(n, r) ) = \rulepreds{r} \concat E'$;
  % respects splits:
  \textbf{(c)} for each $n' \in N$ and all $F_0, F_1 \in
  \subexps{P_0}$ such that $(F_0, F_1)$ is a tiling of $E_0(n')$,
  there is some, there are some $n_0, n_1 \in N$ such that $T_0(n',
  F_0, F_1) = (n_0, n_1)$, with $E_0(n_0) = F_0$ and $E_0(n_1) =
  F_1$.

  % punt on expression map for P1:
  Let there be some $E_1 : N \to \subexps{P_1}^{*}$ that is defined
  symmetrically for $P_1$.

  % give it a name:
  Then $I$ are \emph{derivation relational invariants} of $P_0$ and
  $P_1$.
\end{defn}
%
The space of all derivation relational invariants for $P_0$ and $P_1$
is denoted $\dersinvs{P_0}{P_1}$.
%
For each $I \in \dersinvs{P_0}{P_1}$, the expression maps $E_0$ and
$E_1$ defined in \autoref{defn:der-rel-invs} are denoted
$\dersexps{P_0}{I}$ and $\dersexps{P_1}{I}$, respectively.
%
\BH{reference running example}

% define inductive derivation relational invariants
Derivation relational invariants are inductive if they define
relational invariants.
%
In particular, for $I \in \derstructs{P_b0}{P_1}$, let $I' \in
\relinvs{P_0}{P_1}$ be such that for all $E_0 \in \subexps{P_0}^{*}$
and $E_1 \in \subexps{P_1}^{*}$,
\begin{align*}
  % the invariant of the sequences of expressions is
  \exprel{I'}(E_0, E_1) = %
  % the conjunction of invariants over all nodes:
  \bigland \setformer{ I(n_0, n_1) }{ %
    n_0, n_1 \in \nodes{I},
    % that are annotated with the expression sequences
    \dersexps{P_0}{I}(n_0) = E_0, \dersexps{P_1}{I}(n_1) = E_1 }
\end{align*}
%
$I \in \derstructs{P_0}{P_1}$ are inductive if they can be decomposed
to form derivation structures that define relational invariants of
$P_0$ and $P_1$.
%
For all $I_0, I_1 \in \derstructs{P_0}{P_1}$, let $I_0 \union I_1 =
(\nodes{I_0} \union \nodes{I_1}, I', %
\stepedges{P_0}{I_0} \union \stepedges{P_0}{I_1}, %
\stepedges{P_1}{I_1} \union \stepedges{P_1}{I_1}, %
\tilesof{P_0}{I_0} \union \tilesof{P_0}{I_1}, %
\tilesof{P_1}{I_1} \union \tilesof{P_1}{I_1})$, where %
for all $n \in \nodes{I_0} \setminus \nodes{I_1}$, 
$\restrict{I'}{N_0 \setminus N_1} = \restrict{I_0}{N_0 \setminus
  N_1}$, %
$\restrict{I'}{N_1 \setminus N_0} = \restrict{I_0}{N_1 \setminus
  N_0}$, and %
for each $n \in N_0 \intersection N_1$, $I'(n) = I_0(n) \land
I_1(n)$.
%
\begin{defn}
  \label{defn:inductive-der-rels}
  For $I_0, I_1 \in \dersrels{P_0}{P_1}$, if $(\exprel{I_0},
  \exprel{I_1})$ are relational invariants of $P_0$ and $P_1$, then
  $I_0 \union I_1$ are \emph{inductive} derivation relational
  invariants.
\end{defn}
%
Derivation relational invariants are evidence of partial equivalence,
by \autoref{lemma:equiv-evidence}.
%
\sys, given programs $P_0$ and $P_1$ attempts to determine their
partial equivalence by synthesizing inductive derivation relational
invariants.

\subsection{Verification algorithm}
\label{sec:verifier}
\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(I)$ \label{line:core-aux-begin} }{ %
      % check if the solution is inductive:
      \Switch{$\chkinductive(I)$ \label{line:core-chkind} }{ %
        \lCase{$\isind$}{ %
          % case: it is. Return that P0, P1 are equivalent.
          \Return{$\true$} \label{line:core-ret-equiv} %
        } %
        \Case{$D_0 \in \dertrees{ \cc{P}_0 }{ P_0 }$, %
          $D_1 \in \dertrees{ \cc{P}_1 }{ P_1 }$ %
          \label{line:core-case-cex}}{ %
          \Switch{$\verifyders(D_0, D_1)$ \label{line:core-vders} }{ %
            \lCase{$\nonequiv$: \label{line:core-subcase-non-equiv} }{ %
              \Return{$\false$} \label{line:core-ret-non-equiv} } %
            \lCase{$I' \in \dersrels{P_0}{P_1}$: %
              \label{line:core-subcase-invs} }{ %
              \Return{ $\verifyaux(\mergeinvs(I, I'))$ } %
              \label{line:core-recurse}
            } %
          } %
        } %
      } %
    } \label{line:core-aux-end} %
    \Return{$\verifyaux(\emptyset)$} \label{line:core-base} } %
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier.
  }
  \label{alg:verify}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:verify}.
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given derivation relational
invariants $I$, attempts to determine if $P_0 \equiv P_1$ by finding
inductive derivation relational invariants built from $I$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the empty map of derivation relational
invariants and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given derivation relational invariants $I$, runs procedure
\chkinductive on $I$ (\autoref{line:core-chkind}; 
%
\chkinductive is given in \autoref{sec:chk-ind}).
%
If \chkinductive determines that some restriction of $I$ are
inductive, then \chkinductive returns the value $\isind$, and
\verifyaux returns that $P_0 \equiv P_1$
(\autoref{line:core-ret-equiv}).

% case: no inductive restriction found:
Otherwise, \chkinductive returns a derivation $D_0$ of $P_0$ and $D_1$
of $P_1$ that do not have derivation relational
invariants in $I$ (\autoref{line:core-case-cex}).
%
\verifyaux then runs a procedure \verifyders on $D_0$ and $D_1$
(\autoref{line:core-vders}; \verifyders is given in
\autoref{sec:verify-ders}).
%
If \verifyders returns the value $\nonequiv$ to denote that $D_0$ and
$D_1$ are not equivalent (\autoref{line:core-subcase-non-equiv}), then
\verifyaux returns that $P_0 \not\equiv P_1$
(\autoref{line:core-ret-non-equiv}).

% subcase: finds path-pair invariants:
Otherwise, \verifyders returns relational derivation invariants $I'$
of $D_0$ and $D_1$ (\autoref{line:core-subcase-invs}).
%
\verifyaux runs a procedure \mergeinvs on $I$ and $I'$, which
generates derivation relational invariants of all pairs of derivations
with relational invariants in both $I$ and $I'$.
%
\verifyaux recurses on the generated invariants and returns the result
(\autoref{line:core-recurse}).

\subsubsection{Determining inductiveness of derivation invariants}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{figure}
  \centering
  \begin{algorithm}[H]
    % Declare IO markers.
    \SetKwInOut{Input}{Input}
    % 
    \SetKwInOut{Output}{Output}
    % Declare sub-program (procedure) markers.
    \SetKwProg{myproc}{Procedure}{}{}
    % Inputs: a program
    \Input{$D \in \dersinvs{P_0}{P_1}$.}
    % Output: decision for safety
    \Output{$\isind$ to denote that some restriction of $D$ is
      inductive, or derivations of $P_0$ and $P_1$ not defined in $D$.}
    % verify: main procedure
    \myproc{$\chkinductive(D)$ \label{line:chkind-begin}} %
    { \myproc{$\chkindaux(n, I)$ %
        \label{line:chkind-aux-begin} } %
      { % n is inductive under D,
        $E_n \assign %
        (\dersexps{P_0}{D}(n), \dersexps{P_1}{D}(n))$ %
        \label{line:bind-exps} \;
        $\varphi_n \assign I(E_n)$ \label{line:bind-invs} \;
        \lIf{$\varphi_n \entails \dersrelinvs{D}(n)$ %
          \label{line:chkind-is-entailed} } {
          % case: node is inductive:
          \Return{$\isind$} } %
        % 
        \Else{ %
          $I' = \upd{I}{ E_n }{ \varphi_n \land \invsof{ I }(n) }$ %
          \label{line:str-invs} \; %
          $\tileind_0 \assign %
          \biglor \setformer{ %
            \chkindaux(n_0, I') = \chkindaux(n_1, I') = \isind }{ %
            n_0, n_1 \in \nodes{D}, E_0, E_0' \in \subexps{P_0}^{*},
            \tilesof{P_0}{D}(n, E_0, E_0') = (n_0, n_1) }$ %
            \label{line:det-is-ind0} \; %
          $\tileind_1 \assign %
          \biglor \setformer{ %
            \chkindaux(n_0, I') = \chkindaux(n_1, I') = \isind }{ %
              n_0, n_1 \in \nodes{D}, E_1, E_1' \in \subexps{P_1}^{*},
              \tilesof{P_1}{D}(n, E_1, E_1') = (n_0, n_1) }$ %
            \label{line:det-is-ind1} \; %
          \lIf{$\tileind_0 \lor \tileind_1$}{ %
            \Return{$\isind$} \label{line:decomp-isind} } %
          \lElse{ %
            \Return{$\chooseres( %
              \unwind{ P_0 }(n, D, I'), %
              \unwind{ P_1 }(n, D, I'))$ %
              \label{line:chkind-unwind} } } } %
      \label{line:chkind-aux-end} } %
    \Return{$\chkindaux(\sinkof{D}, \lambda x.\ \true)$} %
    \label{line:chkind-base} } %
    % 
    \caption{% interface of chkinductive:
      \chkinductive: determines the inductiveness of derivation
      relational invariants. }
    \label{alg:chk-ind}
  \end{algorithm}
\end{figure}
%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given derivation relational invariants $D$
(\autoref{line:chkind-begin}), defines a procedure \chkindaux that
takes $n \in \nodes{D}$ and $I: \subexpseqs \to \symrels{P_0}{P_1}$
and returns either %
\textbf{(1)} $\isind$ to denote that if $I$ are inductive relational
invariants, then $\dersexps{P_0}{D}(n), \dersexps{P_1}{D}(n)$ have
inductive relational invariants that entail $I$ or
%
\textbf{(2)} derivations of the expressions in $\dersexps{P_0}{D}(n)$
that are not defined in $D$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $n$ in $D$ is inductive under
$I$.
%
\chkinductive calls \chkindaux on the head of the $D$ and a map from
each pair of sequences of sub-expressions to $\true$, and returns the
result (\autoref{line:chkind-base}).

% auxiliary function: check entailment in context:
\chkindaux, given $n \in \nodes{D}$, $I : \subexpseqs \to
\symrels{P_0}{P_1}$, collects the pair of sequences of sub-expressions
$E_n$ of $P_0$ and $P_1$ bound to $n$ in $D$
(\autoref{line:bind-exps}), and then collects the relational
invariants $\varphi_n$ bound to $E_n$ in $I$
(\autoref{line:bind-invs}).
%
\chkindaux then tests if $\varphi_n$ entails the relational invariant
of $n$ in $D$;
% 
if so, then \chkindaux returns that $n$ is inductive under $I$
(\autoref{line:chkind-is-entailed}).
% check if some decomposition is entailed
Otherwise, \chkindaux constructs relational invariants $I'$ over
sub-expression sequences that strengthen $I$ at $E_n$ with $\varphi_n$
(\autoref{line:str-invs}).
%
\chkindaux determines if there is some tiling $n_0, n_1 \in N$ of $n$
under either $P_0$ (\autoref{line:det-is-ind0}) or $P_1$
(\autoref{line:det-is-ind1}) such that each of $n_0$ and $n_1$ are
inductive under $I'$.
%
If so, then \chkindaux returns that $n$ is inductive under $I$
(\autoref{line:decomp-isind}).

% case: unwind
Otherwise, \chkindaux runs the procedure $\unwind{P_0}$ and on $n$,
$D$, $I'$, which returns either \textbf{(1)} $\isind$ to denote that
the components under each evaluation rule that can be applied to the
sub-expressions of $P_0$ in $\dersexps{D}(n)$ are inductive or %
\textbf{(2)} returns derivations of $\dersexps{D}(n)$ that do not have
relational invariants in $\invsof{D}$;
%
the implementation of $\unwind{P_0}$ is defined below.
%
\chkindaux runs a similar procedure $\unwind{P_1}$ on $n$, $D$, and
$I'$.
% chooseres:
\chkindaux runs \chooseres on the results of the two calls.
%
If either call returns $\isind$, then \chooseres returns $\isind$.
%
Otherwise, \chooseres returns either the sequence of derivations
returned by the call to $\unwind{P_0}$, or the sequence returned by
the call to $\unwind{P_1}$.

\paragraph{Implementation of \textsc{unwind}}
%
$\unwind{P_0}$, given $D \in \dersinvs{P_0}{P_1}$, $n \in \nodes{D}$,
and $I \in \dersinvs$, determines if $n$ is inductive in $D$ under $I$
by performing the following steps.
% case: empty sequence of derivations:
For $E = \dersexps_0(n)$, first determines if $E = \epsilon$.
%
If so, then $\unwind{P_0}$ returns the empty sequence of derivations.

% case: non-empty sequence of derivations:
Otherwise, let $e \in \subexps{P_0}$, $E' \in \subexps{P_0}^{*}$ be
such that $E = e \cons E'$.
%
For each $r \in \evalrules$ and $E_r \in \subexps{P_0}^{*}$ such that
$E_r$ step to $e$ on $r$ in $P_0$, checks if there is some $n_r \in
\nodes{D}$ such that $\dersexps{P_0}{D} = E_r \concat E'$, and if so,
runs \chkindaux on $n_r$, $D$, and $I'$.
%
If for each $r$ there is such an $n_r$ and $\chkindaux(D, n_r, I') =
\isind$, then $\unwind{P_0}$ returns $\isind$.
%
Otherwise, if there is some $r$ for which there is no such $n_r$, then
\chkindaux returns a sequence of derivations for $E$ consisting of a
derivation for $e$ rooted at $r$, followed by arbitrary derivations of
the expressions in $E'$.
%
Otherwise---in which case there is some $r' \in \evalrules$ with
$n_{r'} \in \nodes{D}$, $D, D' \in \ders{P_0}^{*}$ such that $D$ are
derivations of $E_{r'}$ and $\chkindaux(n_{r'}, D, I') = D \concat
D'$, $\unwind{P_0}$ returns the derivation sequence consisting of $r'$
applied to $D$, followed by $D'$.

% handwave P1:
The implementation of $\unwind{P_1}$ is symmetric to that of
$\unwind{P_0}$.

\subsubsection{Verifying equivalence of derivations}
\label{sec:verify-ders}
%
\BH{maybe simplify this but defining derivation trees inductively,
  instead of as annotated graphs}
%
\verifyders , given $D_0 \in \dertrees{ P_0 }{ P_0 }$, $D_1 \in
\dertrees{P_1}{P_1}$, returns either \textbf{(1)} derivation
relational invariants of $D_0$ and $D_1$ or %
\textbf{(2)} the value $\nonequiv$ to denote that $D_0 \not\equiv
D_1$.
%
\verifyders reduces the problem of determining $D_0 \equiv D_1$ to
solving a recursion-free system of Constrained Horn Clauses
(\autoref{sec:chcs}).

\BH{define cuts of derivation tree}
%
\verifyders constructs a system $\mathcal{S}$, defined as follows.
% define relational predicates per tiling:
The relational predicates of $\mathcal{S}$ are $\cuts{D_0} \times
\cuts{D_1}$.

% define clauses per tiling:
The clauses of $\mathcal{S}$ are defined as follows.
%
$\mathcal{S}$ contains clauses $\stepclauses_0$ that model all steps
of evaluation taken by $P_0$.
%
In particular, for each $n' \in \nodes{D_0}$ with children $N \in
\nodes{D_0}^{*}$, %
$C_0 \in \cuts{D_0}$ such that $n' \cons C_0 \in \cuts{D_0}$,
$C_1 \in \cuts{D_1}$, there is a clause %
\[ (N \concat C_0, C_1)[ \symvars{N}, \symvars{C_0}, \symvars{C_1} ], %
\derstep{D_0}{ n' } \entails %
(n' \cons C_0, C_1) \]
%
\BH{define shorthand, symbolic variables used}
%
$\mathcal{S}$ contains clauses $\stepclauses_1$ that model all steps
of evaluation taken by $P_1$.
%
In particular, for each $n' \in \nodes{D_1}$ with children $N \in
\nodes{D_1}^{*}$, %
$C_0 \in \cuts{D_0}$, and %
$n' \in \nodes{C_1}$, %
$C_1 \in \cuts{D_1}$ such that $n' \cons C_1 \in \cuts{D_1}$, %
there is a clause %
\[ (C_0, N \concat C_1)[ \symvars{C_0}, \symvars{N}, \symvars{C_1} ], %
\derstep{D_1}{ n' } \entails %
(n' \cons C_0, C_1) \]
%
For each tiling in $T'$, there is a clause in the set $\decompclauses$
that constrains that the combination of invariants of a tiling entail
the invariant of the pair of cuts that they tile.
%
I.e., for each $\mathcal{M}_0 \subseteq \cuts{D_0}$, %
$\mathcal{M}_1 \subseteq \cuts{D_1}$, %
$C_0 \in \cuts{D_0}$, and %
$C_1 \in \cuts{D_1}$, there is a clause
%
\[ \setformer{ M_0[ \symvars{ M_0 } ]}{ M_0 \in \mathcal{M}_0 }, %
\setformer{ M_1[ \symvars{ M_1 } ] }{ M_1 \in \mathcal{M}_1 } \entails %
(C_0[ \symvars{C_0} ], C_1[ \symvars{C_1} ])
\]
%
The query relational predicate of $\mathcal{S}$ is $( [ \head{D_0} ],
[ \head{D_1} ])$.

\subsubsection{Merging Derivation Relational Invariants}
% mergeinvs: combine using disjunction:
\BH{notation: project components of invariants}
%
\mergeinvs, given derivation relational invariants $I_0, I_1 \in
\dersinvs{P_0}{P_1}$, generates $I' \in \dersinvs{P_0}{P_1}$ that
represent invariants of all derivations of $I_0$ and $I_1$,
where $I'$ is constructed as follows.
% nodes:
Let $h : N_0 \partto N_1$ be the smallest function such that %
\textbf{(1)} $h(\sinkof{I_0}) = \sinkof{I_1}$; %
\textbf{(2)} for each $n_0 \in N_0$ and $n_1 \in N_1$, if \textbf{(a)}
for each $n_0' \in N_0$ and $r \in \evalrules$ such that $S_0(n_0, r,
n_0')$, it holds that $S_1(n_1, r, h(n_0'))$ and %
\textbf{(b)} for each $n_0' \in N_1$ and $r \in \evalrules$ such that
$S_1(n_1, r, n_0')$, it holds that $S_1(n_1, r, h(n_1'))$, then
$h(n_0) = n_1$; 
% preserves decompositions in P0:
\textbf{(3)} for all $n \in \domain(h)$, $E_0, E_0' \in
\subexps{P_0}^{*}$ such that $(n, E_0, E_1) \in \domain(T_0)$,
$h(T_0^0(n, E_0, E_0')) = T_0^1(h(n), E_0, E_0')$;
% preserves decompositions in P1:
\textbf{(4)} for all $n \in \domain(h)$, $E_1, E_1' \in
\subexps{P_1}^{*}$ such that $(n, E_1, E_1') \in \domain(T_1)$,
$h(T_1^0(n, E_1, E_1')) = T_1^1(h(n), E_1, E_1')$.

% nodes:
\textbf{(1)} Let $N' = N_0 \union N_1'$, where $N_1' = N_1 \setminus
\range(h)$,
% P0 expressions:
\textbf{(2)} let $E_0' = E_0^0 \union E_0^1$, and
% P1 expressions:
\textbf{(3)} let $E_1' = E_1^0 \union E_1^1$.
% invariants:
\textbf{(4)} Let $I' : N' \to \symrels{P_0}{P_1}$ be such that %
\textbf{(a)} $\restrict{I'}{N_0 \setminus N_1} = \restrict{I^0}{N_0
  \setminus N_1}$, %
$\restrict{I'}{N_1 \setminus N_0} = \restrict{I^1}{N_1
  \setminus N_0}$, and %
for each $n \in N_0 \intersection N_1$, $I'(n) = I^0(n) \lor
I^1(n)$.
% P0 steps: 
\textbf{(5)} Let $S_0' = S_0^0 \union \restrict{S_0^1}{N_1'} \union
S_0''$, where for each $n_1 \in N_1$ and $n_0 \in \domain(h)$ such
that $S_0(n_1, h(n_0'))$, it holds that $S_0''(n_1, n_0)$.
% P1 steps:
\textbf{(6)} Let $S_1' = S_1^0 \union \restrict{S_1^1}{N_1'} \union
S_1''$, where for each $n_1 \in N_1$ and $n_0 \in \domain(h)$ such
that $S_1(n_1, h(n))$, it holds that $S_1''(n, n_1)$.
% tilings
\textbf{(7)} Let $T' = T_0 \union T_1$.

% put it all together:
$(N', E_0', E_1', I', S_0', S_1', T')$ are derivation relational
invariants, and are the particular derivation relational invariants
generated by \mergeinvs.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
