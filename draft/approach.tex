% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-types}, we define a type system for proving
equivalence of programs.
%
In \autoref{sec:infer-rel-types}, we present an algorithm for
inferring such types.

\subsection{Relational properties as relational types}
\label{sec:rel-types}
%
In this section, we describe a space of types over collections of
expressions, which can represent proofs of equivalence of functional
programs.
%
In \autoref{sec:rel-type-space}, we give key instances of such types,
and operators for constructing such types.
%
In \autoref{sec:rel-type-sys}, we give a type system for relational
types.

\subsubsection{A space of relational types}
\label{sec:rel-type-space}

\BH{define space of type positions}

\BH{define relational types, parameterizd on base symbols}

\BH{define context relational type: base symbols are variables}

\BH{define context}

\BH{define expression positions: only need to record pairs and base operations}

\BH{define indexed expressions as partial map from expression
  positions to expressions}

\BH{define result relational type: base symbols are expression
  positions}

\subsubsection{Operations over relational types}
\label{sec:rel-type-space}

\subsubsection{A relational type system}
\label{sec:rel-type-sys}

% rules for determining if expression sequences have a relational type:
\begin{figure}
  \centering
  \begin{gather*}
    % empty:
    \inference[ EMPTY ]{ }{
      % the empty map of expressions has relational type true
      \Gamma \judges \emptyset : \emptyset } \qquad
    % vars:
    \inference[ VARS ]{ }{ %
      \Gamma \judges P \mapsto X : %
      \Gamma(x)[ X \mapsto P ] } \\
    % constant:
    \inference[ CONST ]{ %
      % remainder has type tau,
      \Gamma \judges E : \tau }{ %
      \Gamma \judges \upd{ E }{ p }{ c } : \tau \joinctr_p (p = c) } \qquad
    % base operation:
    \inference[ OP ]{ %
      % remainder has type tau,
      \Gamma \judges %
      \upd{ E }{ \leftopchild \cons p, \rightopchild \cons p}{ %
        e_0, e_1 } : \tau }{ %
      \Gamma \judges \upd{ E }{ p }{ e_0 \oplus e_1 } : %
      \tau \joinctr_p %
      (p = \leftopchild \cons p \oplus \rightopchild \cons p) } \\
    % abstraction:
    \inference[ ABS ]{ 
      % extend the context and typecheck the body,
      \Gamma, x : \tau \judges \upd{ E }{ p }{ e } : \tau' }{ %
      % type of abstraction is
      \Gamma \judges \upd{ E }{ p }{ \lambda x. e } : %
      \tau \to_p \tau' } \qquad
    % application:
    \inference[ APP ]{ %
      % get type of abstraction,
      \Gamma \judges \upd{E}{p}{e_0} : \tau \to_p \tau' \\
      % get type of argument that is the parameter type,
      \Gamma \judges \upd{E}{p}{e_1} : \tau }{
      % return the result type
      \Gamma \judges \upd{ E }{ p }{e_0\ e_1} : \tau' } \\
    % pairing:
    \inference[ PAIR ]{
      % get type of both expressions,
      \Gamma \judges %
      \upd{E}{\leftchild \cons p, \rightchild \cons p}{ e_0, e_1 } : %
      \tau }{ % then type of pair is
      \Gamma \judges \upd{E}{p}{ \pair{e_0}{e_1} } : \times_p \tau } \qquad
    % let:
    \inference[ LET ]{
      % get type of bound expression,
      \Gamma \judges \upd{ E }{p}{ e_0 } : \times_p \tau \\
      % get type of result under context that binds to x and y,
      \Gamma, x, y : %
      \replace{ \tau }{ %
        \leftchild \cons p, \rightchild \cons p }{ x, y } \judges %
      e_1 : \tau' }{
      % then complete let expression has type
      \Gamma \judges \upd{E}{p}{ \letexp{x}{y}{e_0}{e_1} } : \tau' } \\
    % left injection:
    \inference[ LEFT ]{
      % get type of the nested exp,
      \Gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma \judges \upd{E}{p}{ \injl\ e} : \tau +_p \tau' } \qquad
    % right injection:
    \inference[ RIGHT ]{
      % get type of the nested exp,
      \Gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma \judges \upd{E}{p}{ \injr\ e} : \tau' +_p \tau } \\
    % match:
    \inference[ MATCH ]{
      % get type of matched exp,
      \Gamma \judges \upd{E}{p}{e_0} : \tau +_p \tau' \\
      % get type of left branch under context that binds x to left op,
      \Gamma, \cc{x} : \replace{ \tau }{p}{ \cc{x} } \judges %
      \upd{E}{p}{e_1} : \tau'' \\
      % get type of right branch under context that binds y to right op,
      \Gamma, \cc{y} : \replace{ \tau' }{p}{ \cc{y} } \judges %
      \upd{E}{p}{e_2} : \tau'' }{
      % then type of match exp is type of both branches,
      \Gamma \judges %
      \upd{E}{p}{ \matchexp{e_0}{\cc{x}}{e_1}{\cc{y}}{e_2} } : %
      \tau'' } \qquad
    % fixpoint:
    \inference[ FIX ]{
      % get type of body under context that binds symbol to tau,
      \Gamma, f : \tau \judges \upd{ E }{ p }{ e } : \tau' \\
      % constrain that tau' with result renamed to f is subtype of tau,
      \replace{ \tau' }{ p }{ f } \subtype \tau }{ %
      \Gamma \judges \upd{ E }{ p }{ \fix{f}{e} }: \tau' } \\
    % unfold:
    \inference[ UNFOLD ]{
      % if expressions have tau unfolded at p,
      \Gamma \judges E : \unfold{\tau}{(p, q)} }{ 
      % then expressions have folded type
      \Gamma \judges E : \tau } \qquad
    % subtype:
    \inference[ SUB ]{
      % if expressions have tau,
      \Gamma \judges E : \tau &
      % and tau subtypes tau',
      \tau \subtype \tau' }{ %
      % then expressions have type tau'
      \Gamma \judges E : \tau' }
  \end{gather*}
  \caption{A typing system for relational types.
    %
    Metavariable %
    $\Gamma$ ranges over constants, %
    $E$ ranges over positional expressions, %
    $p$ ranges over expression positions, %
    $e$ ranges over expressions, %
    $\tau$ ranges over relational types, %
    $P$ ranges over sequences of expression positions, %
    $X$ ranges over sequences of program variables, %
    $c$ ranges over constants, %
    $x$, $y$, and $f$ range over program variables, and %
    $q$ ranges over type positions.}
  \label{fig:reltypes-rules}
\end{figure}

      % % extend assumed type at p and rebind to position
      % \typarampos \cons_p \replace{ \tau }{ x }{ p } \union
      % % combined with relational type that extends result at p with
      % \tyrespos \cons_p \tau' 
    
% define judgment:
\BH{walk through the rules}

% types as proving equivalence:
\BH{deprecated}

\BH{state main soundness result}
% 
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0 \equiv P_1$ as a proof that $\elts{ P_0, P_1 } :
\tau_{\equiv}$.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% structures maintained by inference algorithm. Unfoldings:
\sys attempts to extract a proof that $P_0, P_1 : \tau_{\equiv}$ from
a map from sets of \emph{unfoldings} of sub-expressions of $P_0$
and $P_1$ to candidate relational types.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $f \in \vars$ and $e \in \expr$, the \emph{unfoldings} of
  $\fix{f}{e}$, denoted $\unfoldings{ \fix{f}{e} }$

 are the smallest set of expressions such that:
  %
  \begin{enumerate}
  \item $f \in \unfoldings{ \fix{f}{e} }$;
  \item For each $e' \in \unfoldings{ \fix{f}{e} }$, $\replace{
      \fix{f}{e} }{ f }{ e' } \in \unfoldings{ \fix{f}{e} }$.
  \end{enumerate}
\end{defn}
%
\BH{fix defn of unfoldings above to allow the unfolded expressions to
  occur as subexpressions of the main expressions}
%
\BH{give examples}

% invariant structure:
\BH{rename this}
%
Partial relational invariants assign sets of subexpressions to
relational types.
%
\begin{defn}
  \label{defn:inferred-invs}
  Let
  \begin{itemize}
  \item 
    % subexpressions of unfoldings:
    $\mathcal{E} \subseteq \pset(\subexps{ \unfoldings{P_0} } \union
      \subexps{\unfoldings{P_1} })$;
  \item
    % context types:
    $\Gamma : \mathcal{E} \to \reltypes$;
  \item
    % relational types of subexpressions:
    $T : \mathcal{E} \to \reltypes$
  \end{itemize}
  %
  be such that 
  \begin{itemize}
  \item 
    % set of programs has the equivalence type:
    $T( \elts{ P_0, P_1 } ) \entails \tau_{ \equiv }$; 
  \item 
    % type of set is subtype of type of extension with fixpoint
    % symbol
    For all $E \in \mathcal{E}$ and each $f \in \vars$, $T(E) \subtype
    T(\add{ f }{ E })$.
  \item 
    % relational types are consistent under tiling:
    For each $E \in \mathcal{E}$ and $E_0, E_1 \subseteq E$ such that
    $E = E_0 \union E_1$, it holds that $T(E_0) \land T(E_1) \subtype
    T(E)$.
  \item 
    % relational types are consistent under subtypes:
    For all $e \in \expr$, $E \subseteq \expr$ such that $\add{ e }{ E
    } \in \mathcal{ E }$, $\Gamma(\subexps{e} \union E) \judges
    \subexps{ e } \union E : T( \subexps{e} \union E)$ supports that
    $\Gamma(\add{ e }{ E }) \judges \add{ e }{ E } : T(\add{ e }{ E
    })$.
  \end{itemize}
\end{defn}
%
\BH{patch to account for how predecessors actually work in typing
  rules}
%
\BH{add choice conditions that make invariants evidence}

% define when invariants are inductive:
Unfolded invariants are inductive if they define a proof of the fact
that $P_0$ and $P_1$ have type $\tau_{\equiv}$.
% 
\begin{defn}
  \label{defn:ind-unfolded}
  \BH{complete}
\end{defn}

% evidence is a valid proof of partial equivalence:
If $P_0$ and $P_1$ have relational invariants, then $P_0 \equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are $R \in \relinvs{P_0}{P_1}$, then $P_0 \equiv P_1$.
\end{lemma}
%
\sys, given programs $P_0$ and $P_1$, attempts to determine their
partial equivalence by synthesizing inductive unfolded relational
types.

\subsection{Inferring relational types}
\label{sec:infer-rel-types}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(\cc{P}_0' \in \unfoldings{ \cc{P}_0 }, %
      \cc{P}_1' \in \unfoldings{ \cc{P}_1 })$}{ %
      % try to verify the unfoldings:
      \Switch{$\verifybnd(\cc{P}_0', \cc{P}_1')$ \label{line:ver-bnd} }{
        % if the verifier returns that the unfoldings aren't equivalent
        \lCase{$\nonequiv$}{ 
          % then the top-level returns that the programs aren't
          % equivalent
          \Return{$\false$} \label{line:ret-non-eq} }
        % if the verifier returns relational types of the unfoldings:
        \Case{$T \in \subexptypes{ \cc{P}_0' }{ \cc{P}_1' }$ %
          \label{line:subexp-types} }{ %
          % then check if they're inductive:
          \Switch{$\chkinductive(T)$ \label{line:chk-ind} }{ 
            \lCase{$\isind$}{ \Return{$\true$} \label{line:ret-eq} }
            \lCase{ %
              $\cc{P}_0'' \in \unfoldings{ \cc{P}_0 }, %
              \cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$}{
              \Return{$\verifyaux(\cc{P}_0'', \cc{P}_1'')$ %
                \label{line:ret-rec} }
            }
          }
        }
      }
    }
    \Return{$\verifyaux(\folded(\cc{P}_0), \folded(\cc{P}_1))$ %
      \label{line:core-base} }
  }
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier, which uses procedures
    \verifybnd (\autoref{sec:verify-ders}) and %
    \chkinductive (\autoref{sec:chk-ind}).  }
  \label{alg:infer}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:infer}.
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given $\cc{P}_0' \in
\unfoldings{ \cc{P}_0 }$ and $\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$,
attempts to determine if $P_0 \equiv P_1$ by typed subexpressions of
an unfolding 
%
\BH{fix}
%
of $\cc{P}_0'$ and $\cc{P}_1'$, or determines that $\cc{P}_0
\not\equiv \cc{P}_1$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the complete folding of $\cc{P}_0$ and
$\cc{P}_1$ and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given $\cc{P}_0 \in \unfoldings{\cc{P}_0}$ and $\cc{P}_1
\in \unfoldings{ \cc{P}_1 }$, runs procedure \verifybnd on $\cc{P}_0'$
and $\cc{P}_1'$ (\autoref{line:ver-bnd}).
%
If \verifybnd returns $\nonequiv$, then \verify returns that $\cc{P}_0
\not\equiv \cc{P}_1$ (\autoref{line:ret-non-eq}).

%
Otherwise, if \verifybnd returns $T \in \subexptypes{ \cc{P}_0' }{
  \cc{P}_1' }$,
%
\BH{define sub-expression types}
%
then \verify runs procedure \verifyaux on $T$
(\autoref{line:subexp-types}), then \verifybnd runs procedure
\chkinductive on $T$ (\autoref{line:chk-ind}).
%
If \chkinductive returns $\isind$, then \verify returns that $\cc{P}_0
\equiv \cc{P}_1$ (\autoref{line:ret-eq}).
% subcase: invariants are not inductive:
Otherwise, if \chkinductive returns $\cc{P}_0'' \in \unfoldings{
  \cc{P}_0 }$ and $\cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$, then
\verifyaux runs \verifyaux on $\cc{P}_0''$ and $\cc{P}_1''$ and
returns the result (\autoref{line:ret-rec}).

% overview the rest of the section
\autoref{sec:type-unfoldings} gives an implementation of
\autoref{sec:type-unfoldings};
%
\autoref{sec:chk-ind} gives an implementation of \chkinductive.

\subsubsection{Typing subexpressions of unfoldings}
\label{sec:type-unfoldings}
% give an overview:
\verifybnd, given $\cc{P}_0' \in \unfoldings{ \cc{P}_0 }$ and
$\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$, either returns types of the
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$ or returns $\nonequiv$
to denote that $\cc{P}_0' \not\equiv \cc{P}_1'$.
%
\verifybnd reduces this problem to solving a CHC system
(\autoref{sec:chcs}).
%
Each solution of the system defines types and contexts of
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$.
%
The clauses of the system correspond to rules for establishing types
of expressions (\autoref{fig:reltypes-rules}).

% give the construction in detail:
\BH{update}
%
\verifybnd generates the following CHC system $\mathcal{C}_{
  \cc{P}_0', \cc{P}_1' }$.
% define the space of relational predicates
Let $E \subseteq \subexps{ \cc{P}_0' } \union \subexps{ \cc{P}_1' }$.
% define relational predicates of a set of types:
For typed symbols $T$, let the set of relational predicates
$\symrelpreds{ T }$ be defined as follows.
% base case: T is the empty set of types:
If $T = \emptyset$, then $R_T = \emptyset$.
% inductive case: T is a non-empty set
Otherwise, let $R$ be such that for all $\tau_0, \ldots, \tau_n, \tau'
\in \reftypes$ such that $\tau = \tau_0 \rightarrow \ldots \rightarrow
\tau_n \rightarrow \tau'$, $R$ has variables corresponding to
$\tau_0$, \ldots, $\tau_n$, and $\tau'$.
%
Let $T'$ be collection of typed symbols in which each symbol is a pair
of a typed symbol $f \in T$ and the position of a higher-order
argument type in the type of $f$ in $T$.
%
Then $\symrelpreds{ T } = \add{ \symrelpreds{ T' } }{ R }$.

% define type of a context:
Let $\Gamma : E \times \vars \to \types$ map each $e \in E$ and each
$x \in \freevars(e)$ to its type in $e$, and let $R_E^{\Gamma} =
\symrelpreds( \Gamma )$.
%
Let $T : E \to \types$ map each $e \in E$ to its type under its
context in $\cc{P}_0$ or $\cc{P}_1$.
%
\BH{define all notions of base types in programs correctly}
%
Let $R_E = \symrelpreds(\Gamma \union T)$.
%
The relational predicates of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$
are $\bigunion \setformer{ R_E^{\Gamma} \union R_E }{ E \in
  \antichains{ \cc{P}_0' }{ \cc{P}_1' }}$.

% define clauses
The clauses of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$ are defined as
follows.
%
\BH{define clauses for each relational type}

% define join of relational predicates:
For $\mathcal{R}, \mathcal{R}', \mathcal{R}''$,
%
\BH{patch}
%
, the clauses $\mathcal{R}\andsub(E_0, E_1, E')$ and $\orsub(E_0, E_1,
E')$ constrain that the conjunction (and similarly, disjunction) of
the relational types defined by interpretations of $\symrelpreds(E_0)$
and the interpretations of $\symrelpreds(E_1)$ is a subtype of the
interpretation of the $\symrelpreds(E')$.
%
I.e., if $R$
%
\BH{define clauses for subtype of conjunction (and
  disjunction). Maybe need to structure relational predicates in
  sequences.}
%
Such clauses are denoted $\mathcal{R} \joinctr \mathcal{R}' \subtype
\mathcal{R}''$.

\BH{remove indices}

% enumerate clauses per form of expression:
\verifybnd generates clauses that model each of the syntax-directed
typing rules given in (\autoref{fig:reltype-rules}).
% sets of atomic expressions:
For all $E_0 \subseteq \subexps{ P_0 }$ and $E_1 \subseteq \subexps{
  P_1 }$ such that $E_0$ and $E_1$ contain only atomic expressions,
\verifybnd generates the following clauses:
%
$\mathcal{R} \joinctr %
\bigland \setformer{ c = (c, i) }{ c \in \const, i \in I, (c, i) \in E
} \subtype \mathcal{R}'$.

% clauses for op:
Let $e_0, e_1 \in \subexps{ \cc{P}_0 }$ such that $e_0 \oplus e_1
\in \subexps{ P_0 }$, %
$E_0 \subseteq \subexps{ P_0 }$, and %
$E_1 \subseteq \subexps{ P_1 }$.
%
\verifybnd generates the clauses
\begin{align*}
  % constrain contexts,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % subtyping of expression types:
  \mathcal{R}, %
  \resvar{e_0 \oplus e_1} = \resvar{e_0} \oplus \resvar{e_1} &
  \subtype \mathcal{R}'
\end{align*}
%
\BH{define subtyping constraint syntax over ops}
%
Similar clauses are included for all subexpressions of $P_1$ that are
constructed from binary operations.

% clauses for if-then-else:
For all $e_0, e_1, e_2 \in \subexps{ P_0' }$ and $E \subseteq
\subexps{ P_0 } \union \subexps{ P_1 }$, let $\mathcal{R} =
\symrelpreds(\elts{ e_0, e_1, e_2 } \union E)$ and $\mathcal{R}' =
\symrelpreds(\elts{ \ite{ e_0 }{ e_1 }{ e_2 } } \union E)$.
%
Then \verifybnd generates relational predicates $R_0$ and $R_1$ and
clauses
%
\BH{fix this defn}
\begin{align*}
  % context subtyping,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % copy the then expression to the whole expression:
  \mathcal{R}, \resvar{e_0} = \true & \subtype \mathcal{R}_T &
  % case where guard is true: define the copy predicates:
  \resvar{ e_1 } \equiv \resvar{ e } & \subtype \mathcal{COPY}_T &
  % copy value from the then expression to the whole expression:
  \mathcal{R}_T \joinctr \mathcal{COPY}_T & \subtype \mathcal{R}' &
  % assume that 
  \mathcal{R}_T, \resvar{ e_0 } = \true & \subtype \mathcal{R}'
  % case where guard is false:
\end{align*}
%
\BH{renamesub: remove use}
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_0 }{ \mathcal{ R }' }{ \resvar{ (e_1, i_1) }
}{ \resvar{(e, i)} }$,
%
\BH{define updated sets of relational predicates}
% add constraint for case where the guard is false,
$\ctrclause{ R }{ R_1 }{ \resvar{ (e_0, i) } = \false}$, and
%
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_1 }{ \mathcal{ R }' }{ \resvar{ (e_2, i_2) }
}{ \resvar{ (e, i) } }$.
%
Similar clauses are included for all \cc{if}-\cc{then}-\cc{else}
subexpressions of $P_1$.

% clause for abs
For all $x \in \vars$, %
$e \in \subexps{ P_0' }$ such that $\lambda x. e \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \subseteq \subexps{P_1}'$, \verifybnd adds clauses that solve
for a relational type of $x$, use it to strengthen the context for
typechecking the $e$.
%
I.e., \verifybnd generates a collection of relational predicates
$\mathcal{R}_x$ for $x$ grouped with $E_0$ and $E_1$, %
adds the clauses
% context for typechecking body is strengthen
$\mathcal{R}'_{\Gamma} \joinctr \mathcal{R}_x \subtype
\mathcal{R}_{\Gamma}$, %
% type of body is type of abstraction, after renaming:
$\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ \argnum{e} }$.
%
Similar clauses are included for all abstraction subexpressions of
$P_1$.

% clause for app
For all $e_0, e_1 \in \subexps{P_0'}$ such that $e_0\ e_1 \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \in \subexps{P_1'}$, let $E = E_0 \union \elts{ e_0, e_1 }
\union E_1$, %
let $E' = E_0 \union \elts{ e_0\ e_1 } \union E_1$, and %
let $f$ be a fresh variable with the same type as $x$.
%
\verifybnd adds the clauses 
% type of context is subtype of context over components:
$E_{\Gamma} \subtype E'_{\Gamma}$ and %
$\replace{ E }{ \firstarg{e_0} }{ f } \subtype \replace{ E }{ e_1 }{ f
}$.
%
\BH{define firstarg symbolic variable per expression}
%
Similar clauses are included for all application subexpressions of
$P_1$.

% define clauses for subsets of expressions
For all $E_0, E_0', E_0'' \in \antichains{ P_0' }$ and %
$E_1, E_1', E_1'' \in \antichains{ P_1' }$ such that $E_1 \union E_1'
= E_1''$, \verifybnd generates clauses $(E_0 \union E_1) \joinctr
(E_0' \union E_1') \subtype E_0'' \union E_1''$.

\BH{define the query of the system}

% walk through the other typing rules that aren't used.
\verifybnd does not generate clauses that model the typing rule
\textsc{Fix}, because an unfolding cannot contain a fixpoint
expression.
%
\verifybnd does not explicitly add clauses that model uses of the
\textsc{Sub} rule, given that a CHC solution may choose types for any
set of expressions that satisfy a subtyping relationship.
%
Sets of fixpoint variables are unconstrained, and in particular may be
interpreted as $\false$.

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to \reltypes)$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $\replace{ E }{ f }{ \fix{ f }{ \fixexpr{ f } } }$ 
        } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$\fix{ f }{ e } \in E$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
