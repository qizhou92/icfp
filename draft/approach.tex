% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-invs}, we define the class of proof
structures synthesized by \sys.
%
In \autoref{sec:verifier}, we present the verification algorithm used
by \sys to synthesize such structures.

\subsection{Relational invariants as equivalence proofs}
\label{sec:rel-invs}
%
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0$ is equivalent to $P_1$ that is represented as set of
subexpressions of $P_0$ and $P_1$, each mapped to relational
invariants that relate all evaluations of the subexpressions.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% define symbolic relations:
For each $i \in \elts{0, 1}$ and $n \in nats$, let $\symvarsidx{i}{n}$
denote a distinct set of symbolic variables.
%
Let $\subexpseqs = \subexps(P_0)^{*} \times \subexps(P_1)^{*}$.
%
\begin{defn}
  \label{defn:sym-rels}
  Let $R: \subexpseqs \partto \formulas{ \bigunion_{i \in \elts{0 ,
        1}, n \in \nats } \symvarsidx{i}{n} }$ be such that %
  for all $E_0 \in \subexps{P_0}^{*}$ and $E_1 \in \subexps{P_1}^{*}$,
  $R(E_0, E_1) \in \formulas{ %
    \bigunion_{ 0 \leq i < |P_0|} \symvarsidx{0}{i} \union %
    \bigunion_{0 \leq j < |P_1|} \symvarsidx{1}{j} }$.
  %
  Then $R$ are \emph{symbolic relations}.
\end{defn}
%
The space of symbolic relations of $P_0$ and $P_1$ is denoted
$\symrels{P_0}{P_1}$.

% relational invariants
% define relational invariants
Relational invariants of $P_0$ and $P_1$ are a map from sets of
subexpressions of $P_0$ and $P_1$, with each set $S$ mapped to a
formula that relates the evaluations of all expressions in $S$.
%
Relational invariants soundly describe all steps of evaluation that
can be taken by $P_0$ and $P_1$.
\begin{defn}
  \label{defn:rel-invs}
  Let $R_0, R_1 \in \symrels{P_0}{P_1}$ be such that %
  % condition: relation of empty set is entailed by true:
  \textbf{(1)} $\true \entails R_0(\epsilon, \epsilon) \lor
  R_1(\epsilon, \epsilon)$;
  % condition: steps are valid:
  \textbf{(2)} for all $e_0 \in \subexps{P_0}^{*}$, %
  $E_0 \in \subexps{P_0}^{*}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \evalrules$ that decomposes $e_0$ to $E_0' \in
  \subexps(P_0)^{*}$, %
  there are some $E_0'', E_0''' \in \subexps{P_0}^{*}$ such that $E_0'
  \concat E_0 = E_0'' \concat E_0'''$ and
  \begin{align*}
    R_0(E_0'' \concat E_0''', E_1), %
    \subs{ \symstep{P_0}{ r } }{ \vars[ E_0' ], \vars[ e_0 ] } 
    & \entails R_0(e_0 \cons E_0, E_1) \\
    %
    R_1(E_0'' \concat E_0''', E_1), %
    \subs{ \symstep{P_0}{ r } }{ \vars[ E_0' ], \vars[ e_0 ] }
    & \entails R_0(e_0 \cons E_0, E_1)
  \end{align*}
  % symmetric condition for P1
  \textbf{(3)} for all $E_0 \in \subexps{P_0}^{*}$, %
  $e_1 \in \subexps{P_1}$, %
  $E_1 \in \subexps{P_1}^{*}$, and %
  each $r \in \evalrules$ that decomposes $e_1$ to $E_1' \in
  \subexps(P_1)^{*}$, %
  there are some $E_1'', E_1''' \in \subexps{P_1}^{*}$ such that
  $E_1' \concat E_1 = E_1'' \concat E_1'''$ and
  \begin{align*}
    R_0(E_0, E_1'' \concat E_0'''), %
    \subs{ \symstep{P_1}{ r } }{ \vars[ E_0' ], \vars[ e_0 ] }
    & \entails R_1(E_0, e_1 \cons E_1) \\
    R_1(E_0, E_1'' \concat E_1'''), %
    \subs{ \symstep{P_1}{ r } }{ \vars[ E_1' ], \vars[ e_1 ] }
    & \entails R_1(E_0, e_1 \cons E_1) 
  \end{align*}
  %
  Then $R_0$ and $R_1$ are \emph{relational invariants} of $P_0$ and
  $P_1$.
\end{defn}
%
The space of relational invariants of $P_0$ and $P_1$ is denoted
$\relinvs{P_0}{P_1}$.

% strengthen relational invariants to evidence of equivalence:
If relational invariants $R$ are such that the invariant for $\elts{
  P_0, P_1 }$, combined with the assumption that $P_0$ and $P_1$ are
given equal values, entails that $P_0$ and $P_1$ evaluate to equal
values, then $R$ is evidence of the partial equivalence of $P_0$ and
$P_1$.
%
\begin{defn}
  \label{defn:eq-pf}
  Let $R \in \relinvs{P_0}{P_1}$ be such that $R(P_0, P_1), \alpha^0_0
  = \alpha^1_0 \entails \nu^0 = \nu^1$.
  %
  Then $R$ is \emph{evidence} of $P_0 \equiv P_1$.
\end{defn}

% example of relational invariants:
\begin{ex}
  \label{ex:rel-invs}
  \BH{give example relational invariants}
\end{ex}

% evidence is a valid proof of partial equivalence:
If there is evidence of the equivalence of $P_0$ and $P_1$, then $P_0
\equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are some $R \in \relinvs{P_0}{P_1}$ such that $R$ is
  evidence of $P_0 \equiv P_1$, then $P_0 \equiv P_1$.
\end{lemma}

% define class of invariants that are actually maintained
\sys, given programs $P_0$ and $P_1$ attempts to determine if $P_0
\equiv P_1$ by synthesizing evidence of $P_0 \equiv P_1$ from a map
pairs of sequences of derivations of subexpressions of $P_0$ and $P_1$
to relational invariants.
%
\begin{defn}
  \label{defn:der-rel-invs}
  % nodes:
  Let \textbf{(1)} finite space $N$, %
  % expressions annotations:
  \textbf{(2)} $E_0 : N \to \subexps{P_0}^{*}$, %
  \textbf{(3)} $E_1 : N \to \subexps{P_1}^{*}$, %
  % invariants annotations:
  \textbf{(4)} $I: N \to \relinvs{P_}{P_1}$,
  % step edges in P0 and P1:
  \textbf{(5) \& (6)} $S_0, S_1 \subseteq N \times \evalrules \times
  N$, and
  % tiling relations:
  \textbf{(7)} $T \subseteq N \times N \times N$ be such that 
  % each E0 edge models a step of P0:
  \textbf{(a)} for all $n, n' \in N$ and $r \in \evalrules$ such that
  $S_0(n, r, n')$, there are $E_0^0, E_0^1 \in
  \subexps{P_0}^{*}$, $e' \in \subexps{P_0}$, and $E_1 \in
  \subexps{P_1}^{*}$ such that $E(n) = (E_0^0 \concat E_0^1, E_1)$,
  $E(n') = (e' \cons E_0^1, E_1)$, and
  %
  \[ I(n), \symstep{ P_0 }{ r } \entails I(n')
  \]
  \BH{fix vocab}
  % each E1 edge models a step of P1:
  \textbf{(b)} for all $n, n' \in N$ and $r \in \evalrules$ such that
  $S_1(n, r, n')$, there are $E_0 \in \subexps{P_0}^{*}$, $e' \in
  \subexps{P_1}$, $E_1^0, E_1^1 \in \subexps{P_1}^{*}$ such that $E(n)
  = (E_0, E_1^0 \concat E_1^1)$, $E(n') = (E_0, e' \cons E_1^1)$, and
  %
  \[ I(n), \symstep{ P_1 }{ r } \entails I(n') 
  \]
  \BH{fix vocab}
  % edges for a hyper-DAG H:
  \textbf{(c)} $H = (N, S_0 \union S_1)$ is a hyper-DAG,
  % H has a unique source annotated with empty seqs
  \textbf{(d)} $H$ has a unique source node $n \in N$, where $E_0(n) =
  E_1(n) = \epsilon$ and $\true \entails I(n)$, and
  % H has a unique sink annotated with P0, P1
  \textbf{(e)} $H$ has a unique sink node $n' \in N$, where $E_0(n') =
  [ P_0 ]$, $E_1(n) = [ P_1 ]$, and $I(n), \alpha_0 = \alpha_1
  \entails \nu_0 = \nu_1$, %
  \textbf{(f)} for all $n_0, n_1, n' \in N$ such that $T(n_0, n_1,
  n')$,
  \[ I(n_0), I(n_1) \entails I(n')
  \]
  %
  \BH{fix vocab of invariants}
  %
  Then $(N, E, I, S_0, S_1, T)$ are \emph{derivation relational
    invariants} of $P_0$ and $P_1$.
\end{defn}
%
The space of all derivation relational invariants for $P_0$ and $P_1$
is denoted $\dersinvs{P_0}{P_1}$.
%
For each $I \in \dersinvs{P_0}{P_1}$, the components of $I$ are
denoted $\nodes{I}$, $\dersexps{P_0}{I}$, $\dersexps{P_1}{I}$,
$\invsof{I}$, $\stepedges{P_0}{I}$, $\stepedges{P_1}{I}$, and
$\tilesof{I}$, respectively.
%
The source and sink nodes of $I$ are denoted $\srcof{I}$ and
$\sinkof{I}$, respectively.
%
\BH{reference running example}

% define inductive derivation relational invariants
\BH{fix}
%
Derivation relational invariants are inductive if they define
relational invariants.
%
In particular, for $I \in \dersinvs{P_0}{P_1}$, let $I' \in
\relinvs{P_0}{P_1}$ be such that for all $E_0 \in \subexps{P_0}^{*}$
and $E_1 \in \subexps{P_1}^{*}$,
\begin{align*}
  % the invariant of the sequences of expressions is
  \exprel{I}(E_0, E_1) = %
  % the disjunction over invariants over all nodes 
  \biglor \setformer{ I(n_0, n_1) }{ %
    n_0, n_1 \in \nodes{I},
    % that are annotated with the expression sequences
    \dersexps{P_0}{I}(n_0) = E_0, \dersexps{P_1}{I}(n_1) = E_1 }
\end{align*}
%
Derivation invariants $I$ are inductive for $P_0$ and $P_1$ if they
are the union of two derivation relations that define relational
invariants of $P_0$ and $P_1$.
%
\begin{defn}
  \label{defn:inductive-der-rels}
  For $I_0, I_1 \in \dersrels{P_0}{P_1}$, if $(\exprel{I_0},
  \exprel{I_1})$ are relational invariants of $P_0$ and $P_1$, then
  $I_0 \union I_1$ are \emph{inductive} derivation relational
  invariants.
\end{defn}
%
Derivation relational invariants are evidence of partial equivalence,
by \autoref{lemma:equiv-evidence}.
%
\sys, given programs $P_0$ and $P_1$ attempts to determine their
partial equivalence by synthesizing inductive derivation relational
invariants.

\BH{integrate this, define space of cuts, define space of tilings}
%
Let $\mathcal{C}_0 \subseteq \nodes{D_0}^{*}$ and $\mathcal{C}_1
\subseteq \nodes{D_1}^{*}$ be the cuts of $D_0$ and $D_1$,
respectively, and let $\mathcal{C}_0' \subseteq \nodes{D_0}$ and
$\mathcal{C}_1' \subseteq \nodes{D_1}$ be the subsequences of
$\mathcal{C}_0$ and $\mathcal{C}_1$, respectively.
%
For $C \in \mathcal{C}_0$ and $T \subseteq \mathcal{C}_0$, if $C$ is
the union of $T$, then $T$ is a \emph{tiling} of $C$, and similarly
for $\mathcal{C}_1$.

\subsection{Verification algorithm}
\label{sec:verifier}
\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(I)$ \label{line:core-aux-begin} }{ %
      % check if the solution is inductive:
      \Switch{$\chkinductive(I)$ \label{line:core-chkind} }{ %
        \lCase{$\isind$}{ %
          % case: it is. Return that P0, P1 are equivalent.
          \Return{$\true$} \label{line:core-ret-equiv} %
        } %
        \Case{$D_0 \in \dertrees{ \cc{P}_0 }$, %
          $D_1 \in \dertrees{ \cc{P}_1 }$ %
          \label{line:core-case-cex}}{ %
          \Switch{$\verifyders(D_0, D_1)$ \label{line:core-vders} }{ %
            \lCase{$\nonequiv$: \label{line:core-subcase-non-equiv} }{ %
              \Return{$\false$} \label{line:core-ret-non-equiv} } %
            \lCase{$I' \in \dersrels{P_0}{P_1}$: %
              \label{line:core-subcase-invs} }{ %
              \Return{ $\verifyaux(\mergeinvs(I, I'))$ } %
              \label{line:core-recurse}
            } %
          } %
        } %
      } %
    } \label{line:core-aux-end} %
    \Return{$\verifyaux(\emptyset)$} \label{line:core-base} } %
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier.
  }
  \label{alg:verify}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:verify}.
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given derivation relational
invariants $I$, attempts to determine if $P_0 \equiv P_1$ by finding
inductive derivation relational invariants built from $I$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the empty map of derivation relational
invariants and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given derivation relational invariants $I$, runs procedure
\chkinductive on $I$ (\autoref{line:core-chkind}; 
%
\chkinductive is given in \autoref{sec:chk-ind}).
%
If \chkinductive determines that some restriction of $I$ are
inductive, then \chkinductive returns the value $\isind$, and
\verifyaux returns that $P_0 \equiv P_1$
(\autoref{line:core-ret-equiv}).

% case: no inductive restriction found:
Otherwise, \chkinductive returns a derivation $D_0$ of $P_0$ and $D_1$
of $P_1$ that do not have derivation relational
invariants in $I$ (\autoref{line:core-case-cex}).
%
\verifyaux then runs a procedure \verifyders on $D_0$ and $D_1$
(\autoref{line:core-vders}; \verifyders is given in
\autoref{sec:verify-ders}).
%
If \verifyders returns the value $\nonequiv$ to denote that $D_0$ and
$D_1$ are not equivalent (\autoref{line:core-subcase-non-equiv}), then
\verifyaux returns that $P_0 \not\equiv P_1$
(\autoref{line:core-ret-non-equiv}).

% subcase: finds path-pair invariants:
Otherwise, \verifyders returns relational derivation invariants $I'$
of $D_0$ and $D_1$ (\autoref{line:core-subcase-invs}).
%
\verifyaux runs a procedure \mergeinvs on $I$ and $I'$, which
generates derivation relational invariants of all pairs of derivations
with relational invariants in both $I$ and $I'$.
%
\verifyaux recurses on the generated invariants and returns the result
(\autoref{line:core-recurse}).

% mergeinvs: combine using disjunction:
\mergeinvs, given derivation relational invariants $I, I' \in
\dersinvs{P_0}{P_1}$, generates 
%
\BH{complete}

\subsubsection{Determining inductiveness of derivation invariants}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{figure}
  \centering
  \begin{algorithm}[H]
    % Declare IO markers.
    \SetKwInOut{Input}{Input}
    % 
    \SetKwInOut{Output}{Output}
    % Declare sub-program (procedure) markers.
    \SetKwProg{myproc}{Procedure}{}{}
    % Inputs: a program
    \Input{$D \in \dersinvs{P_0}{P_1}$.}
    % Output: decision for safety
    \Output{$\isind$ to denote that some restriction of $D$ is
      inductive, or derivations of $P_0$ and $P_1$ not defined in $D$.}
    % verify: main procedure
    \myproc{$\chkinductive(D)$ \label{line:chkind-begin}} %
    { \myproc{$\chkindaux(n, I)$ %
        \label{line:chkind-aux-begin} } %
      { % n is inductive under D,
        $E_n \assign %
        (\dersexps{P_0}{D}(n), \dersexps{P_1}{D}(n))$ %
        \label{line:bind-exps} \;
        $\varphi_n \assign I(E_n)$ \label{line:bind-invs} \;
        \lIf{$\varphi_n \entails \dersrelinvs{D}(n)$ %
          \label{line:chkind-is-entailed} } {
          % case: node is inductive:
          \Return{$\isind$} } %
        % 
        \Else{ %
          $I' = \upd{I}{ E_n }{ \varphi_n \land \invsof{ I }(n) }$ %
          \label{line:str-invs} \; %
          $\tileind \assign %
          \biglor \setformer{ %
            \chkindaux(n_0, I') = \chkindaux(n_1, I') = \isind }{ %
              n_0, n_1 \in \nodes{D}, \tilesof{D}(n_0, n_1, n') }$ %
            \label{line:det-is-ind} \; %
          \lIf{$\tileind$}{ %
            \Return{$\isind$} \label{line:decomp-isind} } %
          \lElse{ %
            \Return{$\chooseres( %
              \unwind{ P_0 }(n, D, I'), %
              \unwind{ P_1 }(n, D, I'))$ %
              \label{line:chkind-unwind} } } } %
      \label{line:chkind-aux-end} } %
    \Return{$\chkindaux(\sinkof{D}, \lambda x.\ \true)$} %
    \label{line:chkind-base} } %
    % 
    \caption{% interface of chkinductive:
      \chkinductive: determines the inductiveness of derivation
      relational invariants. }
    \label{alg:chk-ind}
  \end{algorithm}
\end{figure}
%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:verify-ders}.
%
\chkinductive, given derivation relational invariants $D$
(\autoref{line:chkind-begin}), defines a procedure \chkindaux that
takes $n \in \nodes{D}$ and $I: \subexpseqs \to \symrels{P_0}{P_1}$
and returns either %
\textbf{(1)} $\isind$ to denote that if $I$ are inductive relational
invariants, then $\dersexps{P_0}{D}(n), \dersexps{P_1}{D}(n)$ have
inductive relational invariants that entail $I$ or
%
\textbf{(2)} derivations of the expressions in $\dersexps{P_0}{D}(n)$
that are not defined in $D$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $n$ in $D$ is inductive under
$I$.
%
\chkinductive calls \chkindaux on the head of the $D$ and a map from
each subcut pair to $\true$, and returns the result
(\autoref{line:chkind-base}).

% auxiliary function: check entailment in context:
\chkindaux, given $n \in \nodes{D}$, $I : \subexpseqs \to
\symrels{P_0}{P_1}$, collects the pair of sequences of sub-expressions
$E_n$ of $P_0$ and $P_1$ bound to $n$ in $D$
(\autoref{line:bind-exps}), and then collects the relational
invariants $\varphi_n$ bound to $E_n$ in $I$
(\autoref{line:bind-invs}).
%
\chkindaux then tests if $\varphi_n$ entails the relational invariant
of $n$ in $D$;
% 
if so, then \chkindaux returns that $n$ is inductive under $I$
(\autoref{line:chkind-is-entailed}).
% check if some decomposition is entailed
Otherwise, \chkindaux constructs relational invariants $I'$ over
sub-expression sequences that strengthen $I$ at $E_n$ with $\varphi_n$
(\autoref{line:str-invs}).
%
\chkindaux determines if there is some decomposition tiling $n_0, n_1
\in N$ of $n$ such that $n_0$ and $n_1$ are inductive under $I'$;
%
if so, then \chkindaux returns that $n$ is inductive under $I$
(\autoref{line:decomp-isind}).

% case: unwind
Otherwise, \chkindaux runs the procedure $\unwind{P_0}$ and on $n$,
$D$, $I'$, which returns either \textbf{(1)} $\isind$ to denote that
the components under each evaluation rule that can be applied to the
sub-expressions of $P_0$ in $\dersexps{D}(n)$ are inductive or %
\textbf{(2)} returns derivations of $\dersexps{D}(n)$ that do not have
relational invariants in $\invsof{D}$;
%
the implementation of $\unwind{P_0}$ is defined below.
%
\chkindaux runs a similar procedure $\unwind{P_1}$ on $n$, $D$, and
$I'$.
% chooseres:
\chkindaux runs \chooseres on the results of the two calls.
%
If either call returns $\isind$, then \chooseres returns $\isind$.
%
Otherwise, \chooseres returns either the sequence of derivations
returned by the call to $\unwind{P_0}$, or the sequence returned by
the call to $\unwind{P_1}$.

\paragraph{Implementation of \textsc{unwind}}
%
$\unwind{P_0}$, given $D \in \dersinvs{P_0}{P_1}$, $n \in \nodes{D}$,
and $I \in \dersinvs$, determines if $n$ is inductive in $D$ under $I$
by performing the following steps.
% case: empty sequence of derivations:
For $E = \dersexps_0(n)$, first determines if $E = \epsilon$.
%
If so, then $\unwind{P_0}$ returns the empty sequence of derivations.

% case: non-empty sequence of derivations:
Otherwise, let $e \in \subexps{P_0}$, $E' \in \subexps{P_0}^{*}$ be
such that $E = e \cons E'$.
%
For each $r \in \evalrules$ and $E_r \in \subexps{P_0}^{*}$ such that
$E_r$ step to $e$ on $r$ in $P_0$, checks if there is some $n_r \in
\nodes{D}$ such that $\dersexps{P_0}{D} = E_r \concat E'$, and if so,
runs \chkindaux on $n_r$, $D$, and $I'$.
%
If for each $r$ there is such an $n_r$ and $\chkindaux(D, n_r, I') =
\isind$, then $\unwind{P_0}$ returns $\isind$.
%
Otherwise, if there is some $r$ for which there is no such $n_r$, then
\chkindaux returns a sequence of derivations for $E$ consisting of a
derivation for $e$ rooted at $r$, followed by arbitrary derivations of
the expressions in $E'$.
%
Otherwise---in which case there is some $r' \in \evalrules$ with
$n_{r'} \in \nodes{D}$, $D, D' \in \ders{P_0}^{*}$ such that $D$ are
derivations of $E_{r'}$ and $\chkindaux(n_{r'}, D, I') = D \concat
D'$, $\unwind{P_0}$ returns the derivation sequence consisting of $r'$
applied to $D$, followed by $D'$.

% handwave P1:
The implementation of $\unwind{P_1}$ is symmetric to that of
$\unwind{P_0}$.

\subsubsection{Verifying equivalence of derivations}
\label{sec:verify-ders}
\begin{figure}
  \centering
  \begin{algorithm}[H]
    % Declare IO markers.
    \SetKwInOut{Input}{Input}
    % 
    \SetKwInOut{Output}{Output}
    % Declare sub-program (procedure) markers.
    \SetKwProg{myproc}{Procedure}{}{}
    % Inputs: a program
    \Input{$D_0 \in \dertrees{P_0}$, $D_1 \in \dertrees{P_1}$, %
      $T \in \tilings{D_0}{D_1}$.}
    % Output: decision for safety
    \Output{Some $I \in \dersinvs{D_0}{D_1}$ or the value
      $\nonequiv$.}
    % verify: main procedure
    \myproc{$\verifyders(D_0, D_1, T)$ \label{line:vders-begin}} %
    { \myproc{$\verifydersaux(T')$ \label{line:vders-aux-begin} } %
      { % construct CHC for pair of derivation and tilings:
        $\mathcal{S} \assign \derschc(D_0, D_1, T')$ %
        \label{line:vders-cons-chc} \;
        % try to solve system:
        \Switch{$\solvechc(\mathcal{S})$ %
          \label{line:vders-solve-chc} }{ %
          \lCase{$\sigma \in \interps{ \mathcal{S} }$ %
            \label{line:vders-case-soln} }{ %
            % case: system is solvable. Return solution:
            \Return{$(T, \sigma)$} \label{line:vders-ret-invs} %
          } %
          \Case{$D \in \ders{ \mathcal{S} }$ %
            \label{line:vders-case-cex}}{ %
            % check if D is valid counter-example:
            \Switch{$\isvalidcex(D)$ \label{line:vders-chk-cex}}{
              \lCase{$\isvalid$ \label{line:vders-subcase-valid} }{
                % subcase: the counterexample is valid:
                \Return{$\nonequiv$} \label{line:vders-ret-nonequiv} } %
              \lCase{$C \in \mathcal{S}$ %
                \label{line:vders-subcase-extra} }{ %
                \Return{ $\verifydersaux(\remove{ T' }{ \decomp(C) })$ %
                  \label{line:vders-recurse} } %
              }
            } %
          } %
        } %
        \label{line:vders-aux-end} } %
      \Return{ $\verifydersaux(T)$ } \label{line:vders-base} \;
    } %
    % 
    \caption{% interface of verifyders:
      \verifyders: given a pair of derivations, determines their
      equivalence, using procedures \solvechc and \isvalidcex, given
      in \autoref{sec:verify-ders}.
    }
    \label{alg:verify-ders}
  \end{algorithm}
\end{figure}

%
\verifyders (\autoref{alg:verify-ders}), given $D_0 \in
\dertrees{P_0}$, $D_1 \in \dertrees{P_1}$, and $T \in
\tilings{D_0}{D_1}$, returns either \textbf{(1)} relational derivation
invariants of $D_0$ and $D_1$ with a tiling relation contained by $T$
or %
\textbf{(2)} the value $\nonequiv$ to denote that $D_0 \not\equiv
D_1$.
%
\verifyders reduces the problem of determining $D_0 \equiv D_1$ to
solving a series of recursion-free systems of Constrained Horn Clauses
(\autoref{sec:chcs}).

% introduce aux function:
$\verifyders$ defines a procedure $\verifydersaux$
(\autoref{line:vders-aux-begin}---\autoref{line:vders-aux-end}) that,
given tilings $T' \in \tilings{D_0}{D_1}$, either returns derivation
relational invariants of $D_0$ and $D_1$ with a tiling contained by
$T'$ or the value $\nonequiv$ to denote that $D_0$ and $D_1$ have no
such relational invariants.
%
$\verifyders$ calls $\verifydersaux$ on $T$ and returns the result
(\autoref{line:vders-base}).

% walk through verifydersaux
\verifydersaux, given tilings $T'$ (\autoref{line:vders-cons-chc}),
constructs a CHC system $\mathcal{S}$ for which each solution defines
relational invariants that combined, with $T'$, are derivation
relational invariants of $D_0$ and $D_1$ by running the procedure
$\derschc$ on $D_0$, $D_1$, and $T'$ (\autoref{line:vders-cons-chc};
%
the definition of $\derschc$ is given below).
%
\verifydersaux then runs \solvechc on $\mathcal{S}$
(\autoref{line:vders-solve-chc}).
% case: system has solution:
If \solvechc returns a solution $\sigma \in \interps{ \mathcal{S} }$
(\autoref{line:vders-case-soln}), then \verifydersaux returns $(T,
\sigma)$ as derivation relational invariants of $D_0$ and $D_1$.

% case: system has counter-derivation:
Otherwise, if \solvechc returns a counter-derivation $D \in \ders{
  \mathcal{S} }$ (\autoref{line:vders-case-cex}), then \verifydersaux
determines if $D$ is valid evidence that $D_0 \not\equiv D_1$ by
running a procedure \isvalidcex on $D$ (\autoref{line:vders-chk-cex};
%
\isvalidcex is defined below).
% subcase: counterexample is valid:
If \isvalidcex returns the value $\isvalid$, then \verifydersaux
returns $\nonequiv$.

% subcase: counterexample is not valid:
Otherwise, \isvalidcex returns $C \in \mathcal{S}$ such that each
solution to $\remove{T'}{C}$ defines derivation relational invariants
of $D_0$ and $D_1$ (\autoref{line:vders-subcase-extra}).
%
\verifydersaux recurses on $\remove{T'}{C}$ and returns the result
(\autoref{line:vders-recurse}).

% give DersCHC:
\paragraph{Relational Invariants as CHC solutions}
% introduce tiling relation:
The CHC system $\mathcal{S} = \derschc(D_0, D_1, T')$ is defined as
follows.
% define relational predicates per tiling:
The relational predicates of $\mathcal{S}$ are $\cuts{D_0} \times
\cuts{D_1}$.

% define clauses per tiling:
The clauses of $\mathcal{S}$ are defined as follows.
%
$\mathcal{S}$ contains clauses $\stepclauses_0$ that model all steps
of evaluation taken by $P_0$.
%
In particular, for each $n' \in \nodes{D_0}$ with children $N \in
\nodes{D_0}^{*}$, %
$C_0 \in \cuts{D_0}$ such that $n' \cons C_0 \in \cuts{D_0}$,
$C_1 \in \cuts{D_1}$, there is a clause %
\[ (N \concat C_0, C_1)[ \symvars{N}, \symvars{C_0}, \symvars{C_1} ], %
\derstep{D_0}{ n' } \entails %
(n' \cons C_0, C_1) \]
%
\BH{define shorthand, symbolic variables used}
%
$\mathcal{S}$ contains clauses $\stepclauses_1$ that model all steps
of evaluation taken by $P_1$.
%
In particular, for each $n' \in \nodes{D_1}$ with children $N \in
\nodes{D_1}^{*}$, %
$C_0 \in \cuts{D_0}$, and %
$n' \in \nodes{C_1}$, %
$C_1 \in \cuts{D_1}$ such that $n' \cons C_1 \in \cuts{D_1}$, %
there is a clause %
\[ (C_0, N \concat C_1)[ \symvars{C_0}, \symvars{N}, \symvars{C_1} ], %
\derstep{D_1}{ n' } \entails %
(n' \cons C_0, C_1) \]
%
For each tiling in $T'$, there is a clause in the set $\decompclauses$
that constrains that the combination of invariants of a tiling entail
the invariant of the pair of cuts that they tile.
%
I.e., for each $\mathcal{M}_0 \subseteq \cuts{D_0}$, %
$\mathcal{M}_1 \subseteq \cuts{D_1}$, %
$C_0 \in \cuts{D_0}$, and %
$C_1 \in \cuts{D_1}$, there is a clause
%
\[ \setformer{ M_0[ \symvars{ M_0 } ]}{ M_0 \in \mathcal{M}_0 }, %
\setformer{ M_1[ \symvars{ M_1 } ] }{ M_1 \in \mathcal{M}_1 } \entails %
(C_0[ \symvars{C_0} ], C_1[ \symvars{C_1} ])
\]
%
The query node of $\mathcal{S}$ is $( [ \head{D_0} ], [ \head{D_1}
])$.
%

\paragraph{Checking validity of a counter-derivation as a
  counterexample to equivalence}
%
The procedure \isvalidcex, given $D_0 \in \dertrees{P_0}$, $D_1 \in
\dertrees{P_1}$, $T \in \tilings{D_0}{D_1}$ and $D \in \ders{
  \mathcal{S} = \derschc(D_0, D_1, T)}$, collects the union $D'
\subseteq \mathcal{S}$ of the instances
%
\BH{background: define instances of clauses in a CHC derivation}
%
of clauses $\decompclauses \subseteq \mathcal{S}$ that occur in $D$.
%
If $D' = \emptyset$, then \isvalidcex returns $\isvalid$ to denote
that $D_0 \not\equiv D_1$.
%
Otherwise, \isvalidcex returns an element in $D'$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
