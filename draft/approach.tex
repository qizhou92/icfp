% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-types}, we define a type system for proving
equivalence of programs.
%
In \autoref{sec:verifier}, we present an algorithm for inferring such
types.

\subsection{Equivalence proofs as relational types}
\label{sec:rel-types}
%
In this section, we describe a space of types over collections of
expressions, which can represent proofs of equivalence of functional
programs.
%
In \autoref{sec:rel-type-space}, we give key instances of such types,
and operators for constructing such types.
%
In \autoref{sec:rel-type-sys}, we give a type system for relational
types.

\subsubsection{A space of relational types}
\label{sec:rel-type-space}
%
\sys, given programs $P_0$ and $P_1$, attempts to verify that $P_0
\equiv P_1$ by synthesizing a proof that $(P_0, P_1)$ has a relational
type of equivalent programs.

% define relational types:
Relational types describe sets of tuples of values, each of which may
be a higher-order values.
%
\BH{define type positions (in background?)}
%
\begin{defn}
  \label{defn:rel-type}
  For $T \in \types^{*}$, $P_0, P_1 \subseteq ?? \times \typepos$, the
  space of relational types of $P_0$ in $T$ over $P_1$, denoted
  $\reltypes{ T }{ P_0 }{ P_1 }$, is the smallest space that satisfies
  the following conditions:
  % case: nil type is a relational type
  \textbf{(1)} $\nilrel \in \reltypes{ T }{ P_0 }{ P_1 }$;
  % case: constructed relational types from relational types:
  \textbf{(2)} for $P_B, P_F \subseteq \typepos{ T }$ the extensions
  of $P_0$ that are positions of base and function types, %
  $\tau \in \reltypes{ T }{ P_F }{ P_1 \union P_B }$, and %
  $\varphi \in \formulas{ P_1 \union P_B \union P_F }$, it holds that
  $(\tau, \varphi) \in \reltypespos{ T }{ P_0 }{ P_1 }$.
\end{defn}
%
For $T \in \types^{*}$, the relational types over $T$ are denoted
$\reltypestypes{ T } = \reltypespos{ T }{ ?? \times \epsilon }{
  \emptyset }$.
%
\BH{clean up so that type position only points into a type that
  actually has the position}
%
The space of relational types over all sequences of types is denoted
$\reltypes = \bigunion_{T \in \types^{*} } \reltypestypes{T}$.

\BH{give relational type of higher-order expressions from running
  example}

\BH{define the equivalence for any pair of base types}
%
For each $\tau \in \types$, there is a relational type $\tau_{\equiv}
\in \reltypestypes{ [ \tau, \tau] }$ such that for all $e_0, e_1 \in
\stlc$, if $e_0 \equiv e_1$, then $e_0$ paired with $e_1$ have type
$\tau_{\equiv}$.
%
\BH{define the equivalence type for each type}

% 
The definition of when a collection of expressions has a relational
type, and the connection between equivalence the each base type's
equivalence type, is given in \autoref{sec:rel-type-sys}.

\BH{define intersection of relational types}

\subsubsection{A system for relational types}
\label{sec:rel-type-sys}
% rules for determining if expression sequences have a relational type:
\begin{figure}
  \centering
  \begin{gather*}
    % rule for a constant:
    \inference[ CONST ]{ %
      \Gamma \judges E : \tau }{ %
      \Gamma \judges \elts{ c } \disjunion E : %
      \tau \land \resvar{c} = c }
    % rule for a variable:
    \inference[ VAR ]{ %
      \Gamma \judges E : \tau }{ %
      \Gamma \judges \elts{ x } \disjunion E : %
      \tau \land \resvar{x} \equiv x } \\
    % rule: expression is an op:
    \inference[ OP ]{ 
      \Gamma \judges %
      \elts{ e_0, e_1 } \disjunion E : \tau }{ %
      \Gamma \judges \elts{ e \equiv e_0 \oplus e_1 } \disjunion E : %
      \tau \land (\resvar{e} = \resvar{e_0} \oplus \resvar{e_1}) } \\
    % rule: expression is an if-then-else:
    \inference[ ITE ]{ %
      \Gamma \judges %
      \elts{ e_0, e_1, e_2 } \disjunion E : \tau }{ %
      \Gamma \judges \disjadd{ %
        e \equiv \ite{ e_0 }{ e_1 }{ e_2 } }{ E } : %
      \tau \land ((\resvar{e_0} = \true \land %
      \resvar{e} \equiv \resvar{e_1}) \lor %
      (\resvar{e_0} = \false \land %
      \resvar{e} \equiv \resvar{e_2})) } \\
    % rule: multiset contains an expression that is an abstraction
    \inference[ ABS ]{ \Gamma, \tau \judges %
      \disjadd{ e' }{ E } : \tau' }{ %
      \Gamma \judges \disjadd{ e \equiv \lambda x.\ e' }{ E } : %
      (\tau \rightarrow \tau') \land \param{ e } = x }
    % rule: expression is an application:
    \inference[ APP ]{ %
      % get type of all component expressions,
      \Gamma \judges \disjadd{ e_0, e_1 }{ E } : \tau }{ %
      \Gamma \disjadd{ e \equiv e_0\ e_1 }{ E } \judges %
      \tau \land \param{ e_0 } = \resvar{ e_1 } \land %
      \resvar{e} = \resvar{e_0} } \\
    % rule: expression is a fixpoint:
    \inference[ FIX ]{ %
      \Gamma, \tau \judges \disjadd{ e' }{ E } : \tau }{ %
      \Gamma \judges \disjadd{ e \equiv \fix{ f }{ e' } }{ E } : %
      \tau \land \resvar{e} = f } \\
    % rule: subtyping:
    \inference[ SUB ]{ %
      \Gamma \judges E : \tau & \tau \subtype \tau'
    }{ \Gamma \judges E : \tau' } 
    % rule: empty set of expressions:
    \inference[ EMPTY ]{ }{ %
      \Gamma \judges \emptyset : \Gamma } %
  \end{gather*}
  \caption{A proof system for relational types.}
  \label{fig:reltypes-rules}
\end{figure}
%
\BH{define subtyping relation}
%
Relational types are associated with multisets of program expressions
to prove that the expressions satisfy relational properties, such as
functional equivalence.
%
\autoref{fig:reltypes-rules} contains a set of inference rules that
define a proof system for establishing that a multiset of expressions
has a relational type.
%
For $\Gamma, \tau \in \reltypes$ and $E \multiset{ \expr }$, the fact
that under $\Gamma$, $E$ has type $\tau$ is denoted $\Gamma \judges E
: \tau$.

% types as proving equivalence:
\BH{state main soundness result}
% 
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0 \equiv P_1$ as a proof that $\elts{ P_0, P_1 } :
\tau_{\equiv}$.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs.

% structures maintained by inference algorithm. Unfoldings:
\sys attempts to extract a proof that $P_0, P_1 : \tau_{\equiv}$ from
a map from sets of \emph{unfoldings} of sub-expressions of $P_0$
and $P_1$ to candidate relational types.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $f \in \vars$ and $e \in \expr$, the \emph{unfoldings} of
  $\fix{f}{e}$, denoted $\unfoldings{ \fix{f}{e} }$

 are the smallest set of expressions such that:
  %
  \begin{enumerate}
  \item $f \in \unfoldings{ \fix{f}{e} }$;
  \item For each $e' \in \unfoldings{ \fix{f}{e} }$, $\replace{
      \fix{f}{e} }{ f }{ e' } \in \unfoldings{ \fix{f}{e} }$.
  \end{enumerate}
\end{defn}
%
\BH{fix defn of unfoldings above to allow the unfolded expressions to
  occur as subexpressions of the main expressions}
%
\BH{give examples}

% invariant structure:
Partial relational invariants are a map from multisets of unfoldings
to relational types.
%
\begin{defn}
  \label{defn:inferred-invs}
  Let
  \begin{itemize}
  \item 
    % subexpressions of unfoldings:
    $\mathcal{E} \subseteq \pset(\subexps{ \unfoldings{P_0} } \union
      \subexps{\unfoldings{P_1} })$;
  \item
    % context types:
    $\Gamma : \mathcal{E} \to \reltypes$;
  \item
    % relational types of subexpressions:
    $T : \mathcal{E} \to \reltypes$
  \end{itemize}
  %
  be such that 
  \begin{itemize}
  \item 
    % multiset of programs has the equivalence type:
    $T( \elts{ P_0, P_1 } ) \entails \tau_{ \equiv }$; 
  \item 
    % type of set is subtype of type of extension with fixpoint
    % symbol
    For all $E \in \mathcal{E}$ and each $f \in \vars$, $T(E) \subtype
    T(\disjadd{ f }{ E })$.
  \item 
    % relational types are consistent under tiling:
    For each $E \in \mathcal{E}$ and $E_0, E_1 \subseteq E$ such that
    $E = E_0 \union E_1$, it holds that $T(E_0) \land T(E_1) \subtype
    T(E)$.
  \item 
    % relational types are consistent under subtypes:
    For all $e \in \expr$, $E \subseteq \expr$ such that
    $\disjadd{e}{E} \in \mathcal{E}$, $\Gamma(\subexps{e} \union E)
    \judges \subexps{ e } \union E : T( \subexps{e} \union E)$
    supports that $\Gamma(\disjadd{e}{E}) \judges \disjadd{e}{E} :
    T(\disjadd{e}{E})$.
  \end{itemize}
\end{defn}
%
\BH{patch to account for how predecessors actually work in typing
  rules}
%
\BH{add choice conditions that make invariants evidence}

% define when invariants are inductive:
Unfolded invariants are inductive if they define a proof of the fact
that $P_0$ and $P_1$ have type $\tau_{\equiv}$.
% 
\begin{defn}
  \label{defn:ind-unfolded}
  \BH{complete}
\end{defn}

% evidence is a valid proof of partial equivalence:
If $P_0$ and $P_1$ have relational invariants, then $P_0 \equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are $R \in \relinvs{P_0}{P_1}$, then $P_0 \equiv P_1$.
\end{lemma}
%
\sys, given programs $P_0$ and $P_1$, attempts to determine their
partial equivalence by synthesizing inductive unfolded relational
types.

\subsection{Verification algorithm}
\label{sec:verifier}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(\cc{P}_0' \in \unfoldings{ \cc{P}_0 }, %
      \cc{P}_1' \in \unfoldings{ \cc{P}_1 })$}{ %
      % try to verify the unfoldings:
      \Switch{$\verifybnd(\cc{P}_0, \cc{P}_1)$}{
        % if the verifier returns that the unfoldings aren't equivalent
        \lCase{$\nonequiv$}{ 
          % then the top-level returns that the programs aren't
          % equivalent
          \Return{$\false$} }
        % if the verifier returns relational types of the unfoldings:
        \lCase{$T \in \reltypes{ P_0 }{ P_1 }$}{ %
          % then check if they're inductive:
          \Switch{$\chkinductive(T)$}{ 
            \lCase{$\isind$}{ \Return{$\true$} }
            \lCase{ %
              $\cc{P}_0'' \in \unfoldings{ \cc{P}_0 }, %
              \cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$}{
              \Return{$\verifyaux(\cc{P}_0'', \cc{P}_1'')$}
            }
          }
        }
      }
    }
    \Return{$\verifyaux(\onestep(\cc{P}_0), \onestep(\cc{P}_1))$ %
      \label{line:core-base} }
  }
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier, which uses procedures
    \chkinductive (\autoref{sec:chk-ind}), \verifybnd
    (\autoref{sec:verify-ders}), and %
    \mergeinvs (\autoref{sec:merge}).  }
  \label{alg:verify}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:verify}.
%
\BH{update}
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given $T \in
\unfoldreltypes{P_0}{P_1}$, attempts to determine if $P_0 \equiv P_1$ by
finding inductive derivation relational invariants built from $T$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the empty map of derivation relational
invariants and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given $T \in \unfoldreltypes{P_0}{P_1}$, runs procedure
\chkinductive on $T$ (\autoref{line:core-chkind};
%
\chkinductive is given in \autoref{sec:chk-ind}).
%
If \chkinductive determines that some restriction of $T$ are
inductive, then \chkinductive returns the value $\isind$, and
\verifyaux returns that $P_0 \equiv P_1$
(\autoref{line:core-ret-equiv}).

% case: no inductive restriction found:
Otherwise, \chkinductive returns $d_0 \in \evalders{ P_0 }$ and $d_1
\in \evalders{ P_1 }$ that do not have derivation relational
invariants in $T$ (\autoref{line:core-case-cex}).
%
\verifyaux then runs a procedure \verifybnd on $d_0$ and $d_1$
(\autoref{line:core-vders}; \verifybnd is given in
\autoref{sec:verify-ders}).
%
If \verifybnd returns the value $\nonequiv$ to denote that $d_0
\not\equiv d_1$ (\autoref{line:core-subcase-non-equiv}), then
\verifyaux returns that $P_0 \not\equiv P_1$
(\autoref{line:core-ret-non-equiv}).

% subcase: finds path-pair invariants:
Otherwise, \verifybnd returns $T' \in \unfoldreltypes{d_0}{d_1}$
(\autoref{line:core-subcase-invs}).
%
\verifyaux runs a procedure \mergeinvs on $T$ and $T'$, which
generates derivation relational invariants of all pairs of derivations
with relational invariants in $T$ or $T'$;
%
\mergeinvs is given in \autoref{sec:merge}.
%
\verifyaux recurses on the generated invariants and returns the result
(\autoref{line:core-recurse}).

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to \reltypes)$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $\replace{ E }{ f }{ \fix{ f }{ \fixexpr{ f } } }$ 
        } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$\fix{ f }{ e } \in E$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...

\subsubsection{Verifying equivalence of bounded expressions}
\label{sec:verify-ders}
% give an overview:
$\verifybnd$, given an unfolding $\cc{P}_0'$ of $\cc{P}_0$ and
an unfolding $\cc{P}_1'$ of $\cc{P}_1$, either returns proofs that
$\cc{P}_0'$ and $\cc{P}_1'$ are equivalent, or returns $\nonequiv$ to
denote that $\cc{P}_0'$ and $\cc{P}_1'$ are not equivalent.
%
$\verifybnd$ reduces this problem to solving a CHC system
(\autoref{sec:chcs}).
%
The relational predicates of the system correspond to contexts and
types of subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$.
%
The clauses of the system correspond to the proof values for
establishing valid types of sets of expressions
(\autoref{fig:reltype-rules}).

% give the construction in detail:
$\verifybnd$ constructs the following CHC system $\mathcal{C}_{
  \cc{P}_0', \cc{P}_1' }$.
% define the space of relational predicates
Let $E \in \antichains{ \cc{P}_0' }{ \cc{P}_1' }$ be an arbitrary
anti-chain of $\cc{P}_0'$ and $\cc{P}_1'$.
% define relational predicates of a set of types:
For typed symbols $T$, let the set of relational predicates
$\symrelpreds{T}$ be defined as follows.
% base case: T is the empty set of types:
If $T = \emptyset$, then $R_T = \emptyset$.
% inductive case: T is a non-empty set
Otherwise, let $R$ be such that for each type $\tau = \tau_0
\rightarrow \ldots \rightarrow \tau_n \rightarrow \tau'$, $R$ has
variables corresponding to $\tau_0$, \ldots, $\tau_n$, and $\tau'$.
%
Let $T'$ be collection of typed symbols in which each symbol is a pair
of a typed symbol $f \in T$ and the position of a higher-order
argument type in the type of $f$ in $T$.
%
Then $\symrelpreds{T} = \add{ \symrelpreds{ T' } }{ R }$.

% define type of a context:
Let $\Gamma : E \times \vars \to \types$ map each $e \in E$ and each
$x \in \freevars(e)$ to its type in $e$, and let $R_E^{\Gamma} =
\symrelpreds(\Gamma)$.
%
Let $T: E \to \types$ map each $e \in E$ to its type under its context
in $\cc{P}_0$ or $\cc{P}_1$.
%
\BH{define all notions of base types in programs correctly}
%
Let $R_E = \symrelpreds(\Gamma \union T)$.
%
The relational predicates of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$
are $\bigunion \setformer{ R_E^{\Gamma} \union R_E }{ E \in
  \antichains{ \cc{P}_0' }{ \cc{P}_1' }}$.

% define clauses
The clauses of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$ are synthesized
as follows.
% define join families of relational predicates:
For $\mathcal{R}, \mathcal{R}', \mathcal{R}''$,
%
\BH{deprecated. Clean up.}
%
, the
clauses $\mathcal{R}\andsub(E_0, E_1, E')$ and $\orsub(E_0, E_1, E')$ constrain
that the conjunction (and similarly, disjunction) of the relational
types defined by interpretations of $\symrelpreds(E_0)$ and the
interpretation of $\symrelpreds(E_1)$ is a subtype of the
interpretation of the $\symrelpreds(E')$.
%
I.e., if $R$
%
\BH{define clauses for subtype of conjunction (and
  disjunction). Maybe need to structure relational predicates in
  sequences.}
%
Such clauses are denoted $\mathcal{R} \joinctr \mathcal{R}' \subtype
\mathcal{R}''$.

%
of relational predicates $\mathcal{R}$ over typed variables $X$,
relational predicates $\mathcal{R}'$ over typed variables $X$ and
variables $X' \in X^{*}$ and $Y' \in Y^{*}$ with identical
corresponding types, the clauses $\renamesub{ \mathcal{R} }{
  \mathcal{R'} }{ X' }{ Y' }$ constrain that each interpretation of
$\mathcal{R}$ is a subtype of each interpretation of $\mathcal{R}'$,
with variables that model component types of symbols in $X'$ in
$\mathcal{R}$ replaced with variables that model corresponding
component types of symbols in $Y'$.
%
Let $\mathcal{R}$ be a collection of relational predicates over $X'
\union Y'$.
%
Let the \emph{renaming type} from $X'$ to $Y'$ over $\mathcal{R}$,
denoted $\renameclauses{ X' }{ Y' }{ \mathcal{R} }$ contain the
following clauses.
%
For all $x \in X'$ and $y \in Y'$, let the fact that $x$ and $y$ occur
in identical positions in $X'$ and $Y'$ be denoted $x \sim y$.
%
For each relational predicate $R \in \mathcal{R}$, there is a clause 
%
\[ \bigland \setformer{ \bigland (x, s) = (y, s) }{ %
  x \sim y, s \in , (x, s), (y, s) \in \vars(R)}
\]
%
Then for relational predicates $\mathcal{R}''$ of $X'$ and $Y'$,
$\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ y }$ consists of the
clauses $\renameclauses{X'}{Y'}{ \mathcal{R}''}$ and $\mathcal{R}
\joinctr \mathcal{R}'' \subtype \mathcal{R}'$.
%
Such clauses are denoted $\replace{ \mathcal{R} }{ X' }{ Y' } \subtype
\mathcal{R}'$.

% define constraint clauses:
For relational predicate $R$ over logical variables $X$, %
relational predicate $R'$ over logical vocabulary $X'$ and constraint
$\varphi$ over $X \union X'$, the \emph{constraint clauses} of $R$,
$R'$, and $\varphi$ is defined as follows.
%
Let $R_{\varphi}$ be a fresh relational predicate over logical
vocabulary $X \union X'$.
%
Then the constraint clauses consist of
% constrain the R-varphi relational predicate of 
$\varphi \entails R(X \concat X')$ and %
$\mathcal{R} \joinctr [ R ] \subtype \mathcal{R}'$.
%
The clauses are denoted $\ctrclause{ \mathcal{R} }{ \varphi }{
  \mathcal{R}' }$.

% enumerate all of the actual clauses generated:
$\verifybnd$ generates clauses that model each of the syntax-directed
typing rules given in (\autoref{fig:reltype-rules}).
%
For all $E_0 \subseteq \subexps{ P_0 }$ and $E_1 \subseteq \subexps{
  P_1 }$ such that $E_0$ and $E_1$ contain only atomic expressions,
$\verifybnd$ generates the following clauses:
%
$\mathcal{R} \joinctr %
\bigland \setformer{ c = (c, i) }{ c \in \const, i \in I, (c, i) \in E
} \subtype \mathcal{R}'$.

% clause for op:
For all $e_0, e_1 \in \subexps{ \cc{P}_0 }$ such that $e_0 \oplus e_1
\in \subexps{ P_0 }$, %
$E_0 \subseteq \subexps{ P_0 }$, and %
$E_1 \subseteq \subexps{ P_1 }$.
%
$\verifybnd$ generates the clauses
% subtyping over contexts,
$\mathcal{R}'_{\Gamma} \subtype \mathcal{R}_{\Gamma}$ and 
% subtyping over results
$\mathcal{R} \joinctr \resvar{ (e_0, i_0) } \oplus \resvar{ (e_1, i_1)
} = \resvar{ (e_0 \oplus e_1, i') } \subtype \mathcal{R}'$.
%
Similar clauses are included for all subexpressions of $P_1$ that are
constructed from binary operations.

% clauses for if-then-else:
For all $e_0, e_1, e_2 \in \subexps{ P_0' }$ and $E \subseteq
\subexps{ P_0 } \union \subexps{ P_1 }$, let $\mathcal{R} =
\symrelpreds(E \disjunion \elts{ e_0, e_1, e_2 })$ and $\mathcal{R}' =
\symrelpreds(E \disjunion \elts{ \ite{e_0}{e_1}{e_2} })$.
%
Then $\verifybnd$ generates relational predicates $R_0$ and $R_1$ and
clauses
% context subtyping,
$\mathcal{R}'_{\Gamma} \subtype \mathcal{R}_{\Gamma}$,
% add constraint for case where the guard is true,
$\ctrclause{ R }{ R_0 }{ \resvar{ (e_0, i) } = \true}$,
%
\BH{define R}
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_0 }{ \mathcal{ R }' }{ \resvar{ (e_1, i_1) }
}{ \resvar{(e, i)} }$,
%
\BH{define updated sets of relational predicates}
% add constraint for case where the guard is false,
$\ctrclause{ R }{ R_1 }{ \resvar{ (e_0, i) } = \false}$, and
%
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_1 }{ \mathcal{ R }' }{ \resvar{ (e_2, i_2) }
}{ \resvar{ (e, i) } }$.
%
Similar clauses are included for all \cc{if}-\cc{then}-\cc{else}
subexpressions of $P_1$.

% clause for abs
For all $x \in \vars$, %
$e \in \subexps{ P_0' }$ such that $\lambda x. e \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \subseteq \subexps{P_1}'$, $\verifybnd$ adds clauses that solve
for a relational type of $x$, use it to strengthen the context for
typechecking the $e$.
%
I.e., $\verifybnd$ generates a collection of relational predicates
$\mathcal{R}_x$ for $x$ grouped with $E_0$ and $E_1$, %
adds the clauses
% context for typechecking body is strengthen
$\mathcal{R}'_{\Gamma} \joinctr \mathcal{R}_x \subtype
\mathcal{R}_{\Gamma}$, %
% type of body is type of abstraction, after renaming:
$\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ \argnum{e} }$.
%
Similar clauses are included for all abstraction subexpressions of
$P_1$.

% clause for app
For all $e_0, e_1 \in \subexps{P_0'}$ such that $e_0\ e_1 \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \in \subexps{P_1'}$, let $E = E_0 \disjunion \elts{ e_0, e_1 }
\union E_1$, %
let $E' = E_0 \disjunion \elts{ e_0\ e_1 } \union E_1$, and %
let $f$ be a fresh variable with the same type as $x$.
%
$\verifybnd$ adds the clauses 
% type of context is subtype of context over components:
$E_{\Gamma} \subtype E'_{\Gamma}$ and %
$\replace{ E }{ \firstarg{e_0} }{ f } \subtype \replace{ E }{ e_1 }{ f
}$.
%
\BH{define firstarg symbolic variable per expression}
%
Similar clauses are included for all application subexpressions of
$P_1$.

% define clauses for subsets of expressions
For all $E_0, E_0', E_0'' \in \antichains{ P_0' }$ and %
$E_1, E_1', E_1'' \in \antichains{ P_1' }$ such that $E_1 \union E_1'
= E_1''$, $\verifybnd$ generates clauses $(E_0 \union E_1) \joinctr
(E_0' \union E_1') \subtype E_0'' \union E_1''$.
%
Such clauses ensure that each solution of $\mathcal{C}$ can be used in
arbitrary applications of rule \textsc{Union}.

\BH{define the query of the system}

% walk through the other typing rules that aren't used.
$\verifybnd$ does generate clauses that model the typing rule
\textsc{Fix}, because a bounded expression cannot contain a fixpoint
expression.
%
$\verifybnd$ does not explicitly add clauses that model uses of the
\textsc{Sub} rule, given that a CHC solution may choose types for any
set of expressions that satisfy a subtyping relationship.
%
Sets of fixpoint variables are unconstrained, and in particular may be
interpreted as $\false$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
