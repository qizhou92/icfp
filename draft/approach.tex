% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-invs}, we define the class of proof
structures synthesized by \sys.
%
In \autoref{sec:verifier}, we present the verification algorithm used
by \sys to synthesize such structures.

\subsection{Relational invariants as equivalence proofs}
\label{sec:rel-invs}
%
\sys, given programs $P_0$ and $P_1$, attempts to synthesize a proof
that $P_0$ is equivalent to $P_1$ that is represented as set of
subexpressions of $P_0$ and $P_1$, each mapped to relational
invariants that relate all evaluations of the subexpressions.
%
For the rest of this section, let $P_0, P_1 \in \stlc$ be two fixed,
arbitrary $\stlc$ programs, and let $E_{0, 1} = \subexps(P_0) \union
\subexps(P_1)$.

% define symbolic relations:
\begin{defn}
  \label{defn:sym-rels}
  Let $R: \pset(E) \to \formulas{ E_{0, 1} }$ be such that %
  for each $E \subseteq E_{0, 1}$, %
  it holds that $R(E) \in \formulas{ \symvars{E} }$.
  %
  Then $R$ are \emph{symbolic relations}.
\end{defn}
%
The space of symbolic relations is denoted $\symrels$.

% relational invariants
% define relational invariants
Relational invariants of $P_0$ and $P_1$ are a map from sets of
subexpressions of $P_0$ and $P_1$, with each set $S$ mapped to a
formula that relates the evaluations of all expressions in $S$.
%
Relational invariants soundly describe all steps of evaluation that
can be taken by $P_0$ and $P_1$.
\begin{defn}
  \label{defn:rel-invs}
  For $P_0, P_1 \in \stlc$, let $R \in \symrels$ be such that %
  % condition: relation of empty set is entailed by true:
  \textbf{(1)} $\true \entails R(\emptyset)$;
  % condition: steps are valid:
  \textbf{(2)} for each $E \not= \emptyset \in \domain(R)$, %
  there is some $e \in E$ such that either %
  % subcase: P0 takes a step: 
  \textbf{(a)} $e \in \subexps(P_0)$ and for each $r \in
  \evalrules$ that decomposes $e$ to $e_0, \ldots, e_n \in
  \subexps(P_0)$ in $P_0$,
  %
  there are some $\mathcal{E} \subseteq \pset(E_{0, 1})$ with
  $\remove{ E }{ e } \union \elts{ e_0, \ldots, e_n } = \bigunion
  \mathcal{E}$ such that
  % 
  \[ \setformer{ R(E') }{ E' \in \mathcal{E} }, %
  \subs{ \symstep{P_0}{ r } }{ %
    \vars[ e_0 ], \ldots, \vars[ e_n ], \vars[ e ] } %
  \entails R( E )
  \]
  or
  % symmetric condition for P1
  \textbf{(b)} $e \in \subexps(P_1)$ for each evaluation rule $r$ that
  decomposes $e$
  %
  to $e_0, \ldots, e_n \in \subexps(P_1)$ in $P_1$,
  %
  there are some $\mathcal{E} \subseteq \pset(E_{0, 1})$ with $\elts{
    e_0, \ldots, e_n } = \bigunion \mathcal{E}$ such that
  % 
  \[ \setformer{ R(E') }{ E' \in \mathcal{E} }, %
  \subs{ \symstep{P_1}{ r } }{ %
    \vars[ e_0 ], \ldots, \vars[ e_n ], \vars[ e ] } %
  \entails R(E)
  \]
  %
  Then $R$ are \emph{relational invariants} of $P_0$ and $P_1$.
\end{defn}
%
The space of relational invariants of $P_0$ and $P_1$ is denoted
$\relinvs{P_0}{P_1}$.

% strengthen relational invariants to evidence of equivalence:
If relational invariants $R$ are such that the invariant for $\elts{
  P_0, P_1 }$, combined with the assumption that $P_0$ and $P_1$ are
given equal values, entails that $P_0$ and $P_1$ evaluate to equal
values, then $R$ is evidence of the partial equivalence of $P_0$ and
$P_1$.
%
\begin{defn}
  \label{defn:eq-pf}
  Let $R \in \relinvs{P_0}{P_1}$ be such that $R(P_0, P_1), \alpha^0_0
  = \alpha^1_0 \entails \nu^0 = \nu^1$.
  %
  Then $R$ is \emph{evidence} of $P_0 \equiv P_1$.
\end{defn}

% example of relational invariants:
\begin{ex}
  \label{ex:rel-invs}
  \BH{give example relational invariants}
\end{ex}

% evidence is a valid proof of partial equivalence:
If there is evidence of the equivalence of $P_0$ and $P_1$, then $P_0
\equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are some $R \in \relinvs{P_0}{P_1}$ such that $R$ is
  evidence of $P_0 \equiv P_1$, then $P_0 \equiv P_1$.
\end{lemma}

\BH{define class of invariants that are actually maintained}
%
\sys, given programs $P_0$ and $P_1$ attempts to determine if $P_0
\equiv P_1$ by synthesizing evidence of $P_0 \equiv P_1$ from a map
from sets of derivations to relational invariants.
%
Let the space of such maps be denoted $\dersrels = \subexps(P_0)^{*}
\times \subexps(P_1)^{*} \to \symrels$.
%
\begin{defn}
  \label{defn:der-rel-invs}
  Let $I \in \dersrels$ be such that %
  \begin{enumerate}
  \item 
    % supports relational invariants of complete derivations:
    For all $D_0 \in \dertrees{P_0}$ and $D_1 \in \dertrees{P_1}$,
    \[ I([ D_0 ], [ D_1 ]), \alpha_0 = \alpha_1 \entails %
    \nu_0 = \nu_1 \]
  \item 
    % soundly models each step of P0:
    For all $d_0 \in \dertrees{P_0}$, %
    $D_0 \in \dertrees{P_0}^{*}$, %
    $D_1 \in \dertrees{P_1}^{*}$ such that $(d_0 \cons D_0, D_1) \in
    \domain(I)$, %
    there are some $D_0', D_0'' \in \dertrees{P_0}^{*}$ such that
    $\immsubtrees{d_0} \concat D_0 = D_0' \concat D_0''$ and %
    \[ I(D_0', D_1), I(D_0'', D_1), \symstep{ \immsubtrees{ d_0 } }{
      d_0 } \entails I(D_0, D_1) \]
  \item 
    % soundly models each step of P1:
    For all $D_0 \in \dertrees{P_0}^{*}$, %
    $d_1 \in \dertrees{P_1}$, %
    $D_1 \in \dertrees{P_1}^{*}$ such that $(D_0, d_1 \cons D_1) \in
    \domain(I)$, %
    there are some $D_1', D_1'' \in \dertrees{P_1}^{*}$ such that
    $\immsubtrees{d_1} \concat D_1 = D_1' \concat D_1''$ and %
    \[ I(D_0, D_1'), I(D_0, D_1''), \symstep{ \immsubtrees{ d_1 } }{
      d_1 } \entails I(D_0, D_1) \]
  \end{enumerate}
  %
  Then $I$ are \emph{derivation relational invariants} of $P_0$ and
  $P_1$.
\end{defn}
%
The space of all derivation relational invariants for $P_0$ and $P_1$
is denoted $\dersinvs{P_0}{P_1}$.
%
\BH{add a running example}

\BH{define inductive derivation relational invariants}
%
Derivation relational invariants are inductive if they define
relational invariants.
%
In particular, for $I \in \dersinvs{P_0}{P_1}$, let $I' \in
\relinvs{P_0}{P_1}$ be such that for all $e_0 \in \subexps(P_0)$ and
$e_1 \in \subexps(P_1)$,
\[ I(e_0, e_1) = %
\biglor \setformer{}{ D_0 \in \dertrees{P_0}, %
  \explabel{D_0}(\head(D_0)) = e_0, %
  D_1 \in \dertrees{P_1}, %
  \explabel(\head(D_1)) = e_1 } \]

\subsection{Verification algorithm}
\label{sec:verifier}
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:verify-begin}} %
  { \myproc{$\verifyaux(D_0, D_1, R)$ \label{line:aux-begin} }{ %
      % check if the solution is inductive:
      \Switch{$\chkinductive(D_0, D_1, R)$ \label{line:chkind} }{ %
        \lCase{$\isind$}{ %
          % case: it is. Return that P0, P1 are equivalent.
          \Return{$\true$} \label{line:ret-equiv} %
        } %
        \Case{$D_0' \in \dertrees{ \cc{P}_0 }, %
          D_1' \in \dertrees{ \cc{P}_1 }$ %
          \label{line:case-cex}}{ %
          \Switch{$\verifyders(D_0, D_1)$ %
            \label{line:refine} }{ %
            \lCase{$\nonequiv$:}{ %
              \Return{$\false$} \label{line:ret-inequiv} %
            } %
            \Case{$R'$:}{ %
              \Return{\BH{fix} $\verifyaux(\mergeinvs(I, I'))$} %
              \label{line:recurse}
            } %
          } %
        } %
      } %
    } \label{line:aux-end} %
    \Return{$\verifyaux((\emptyset, \emptyset), %
      (\emptyset, \emptyset), \emptyset)$} \label{line:base-call} } %
  %
  \caption{% interface of verify:
    \verify: given $P_0, P_1 \in \stlc$, decides if $P_0 \equiv P_1$.
    % procedures used: 
    \verify uses procedures \mergeinvs (\autoref{sec:verifier}), %
    \chkinductive (\autoref{sec:chk-ind}), and %
    \verifyders (\autoref{sec:verify-ders}).
  }
  \label{alg:verify}
\end{algorithm}
%
\BH{derdags: replace with derivation trees}
%
\BH{walk through verification algorithm}

%
\BH{define equivalence verifier. Maintains two unrollings of sets of
  program derivations, represented as hyper-DAG's, and map from pairs
  of cuts in the DAGs to relational invariants.}

\BH{iteration: check that DAGs and relational invariants define valid
  proof of equivalence. If so, done.}

\BH{if not, extend one of the DAG's. If extension creates a new pair
  of complete derivations, then pass these to the refutation
  procedure.}

\subsubsection{Checking inductiveness of derivation invariants}
\label{sec:chk-ind}
%
\BH{define the inductiveness over derivation relational invariants}

\subsubsection{Verifying equivalence of derivations}
\label{sec:verify-ders}

\BH{derivation refutation: define relational invariants over sets of
  subderivations that form a frontier in the pair of
  derivations. Start from the set of all leaves. Get the relational
  invariant for each set by taking disjunction over its predecessors
  along every step, and then some context formula that will be
  non-trivial to define.}

\BH{after solving for relational invariants over sets of derivations,
  some derivations may occur more than once in a pair of
  derivations. The invariants for these get folded together using
  conjunction. This normalizes the result into a relational invariant
  per set of derivation}

\BH{sets of derivations play the role of sets of paths in path-based
  analysis. Entailment is checked over sets derivations that derive
  the same set of expressions. Search for a sufficient set can branch:
  we just need to find an inductive set along some expression.}

\BH{sets of derivation nodes that we're interested in are maximal
  anti-chains of nodes under the dependence relation.}

\BH{get the relational invariant for each set of expressions as
  interpolant. Pre-formula: disjunction of cases, one for each
  expression. Post-formula: conjunction of rule constraints for all
  steps left. Note that we don't need to use the other relational
  invariants.}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
