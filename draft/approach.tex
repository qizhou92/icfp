% give the real meat of the thing
\section{Technical Approach}
%
In this section, we describe our technical approach in detail.
%
In \autoref{sec:rel-types}, we define a type system for proving
equivalence of programs.
%
In \autoref{sec:infer-rel-types}, we present an algorithm for
inferring such types.

\subsection{Relational properties as relational types}
\label{sec:rel-types}
%
In this section, we describe a space of types over collections of
expressions, which can represent proofs of equivalence of functional
programs.
%
\autoref{sec:rel-type-space} defines the space of types, %
\autoref{sec:rel-type-ops} defines key operations and relations over
the types, and %
\autoref{sec:rel-type-sys} defines a typing relation from indexed
expressions to the types.

\subsubsection{A space of relational types}
\label{sec:rel-type-space}
% give overview:
A relational type is a set of refinement predicates that relate data
within components of algebraic types, combined with information that
defines mutual inductive definitions of data.
%
Relational types are defined partially over a space of type positions,
which represent component types within algebraic types.
%
Relational positions are a class of sequences of type fields, which
are symbols that denote component types to which algebraic type
constructors are applied.
%
The space of such fields consists of $\typaramfield$, $\tyresfield$,
$\tyleftprod$, $\tyrightprod$, $\tyleftsum$, $\tyrightsum$, and for
each $X \in \lfpvars$, $\mu_X$.
%
The space of positions is denoted $\typos = \typosfields^{*}$.
%
\begin{defn}
  \label{defn:ty-at-pos}
  For $\tau, \tau' \in T$ and $p \in \typos$, the fact that $\tau'$ is
  the type in $\tau$ at $p$ is defined by induction on $p$ as follows.
  %
  $\tau$ is the type in $\tau$ at $\epsilon$. Furthermore,
  %
  \begin{itemize}
  \item % function:
    For all $\tau, \tau', \tau'' \in T$ and each $p \in \typos$ such
    that $\tau' \to \tau''$ is in $\tau$ at $p$, $\tau'$ is in $\tau$
    at $\typaramfield \cons p$ and $\tau''$ is in $\tau$ at
    $\tyresfield \cons p$.
  \item % sum:
    For all $\tau, \tau_l, \tau_r \in T$ and each $p \in \typos$ such
    that $\tau_l + \tau_r$ is in $\tau$ at $p$, $\tau_l$ is in $\tau$
    at $\tyleftsum \cons p$ and $\tau_r$ is in $\tau$ at
    $\tyrightsum \cons p$.
  \item % prod:
    For all $\tau, \tau_l, \tau_r \in T$ and each $p \in \typos$ such
    that $\tau_l \times \tau_r$ is in $\tau$ at $p$, $\tau_l$ is in
    $\tau$ at $\tyleftprod \cons p$ and $\tau_r$ is in $\tau$ at
    $\tyrightprod \cons p$.
  \item % lfp:
    For all $\tau, \tau' \in T$, each $X \in \lfpvars$ and each
    $p \in \typos$ such that $\mu X. \tau'$ is in $\tau$ at $p$,
    $\tau'$ is in $\tau$ at $\mu_X \cons p$.
  \end{itemize}
\end{defn}
%
For each $\tau \in T$, the space of all $p \in \typos$ such that there
is some $\tau' \in T$ in $\tau$ at $p$ is denoted $\typosty{\tau}$.
% define data positions.
For each $\tau \in T$ and $p \in \typosty{\tau}$, if $D$ is in $\tau$
at $p$, $p$ is a \emph{data} position of $\tau$;
% define variable positions,
for each $X \in \lfpvars$ in $\tau$ at $p$, $p$ is a \emph{variable}
position of $\tau$; %
% define lfp positions,
for each $X \in \lfpvars$ and $\tau' \in T$ such that $\mu X. \tau$ is
in $\tau$ at $p$, $p$ is a \emph{least-fixed point} position of
$\tau$.

% define relatable type positions:
Type positions are relatable if they are identical or are positions of
distinct factors of a component product type.
%
\begin{defn}
  \label{defn:relatable}
  For each $\tau \in T$ and all $p, q \in \typosty{\tau}$, $p$ and $q$
  are \emph{relatable in $\tau$} if:
  \begin{itemize}
  \item % identity:
    Each $p \in \typosty{\tau}$ is relatable with itself as a position
    of $\tau$;
  \item % distinct factors:
    For all $\tau_l, \tau_r \in T$ and all $p, q_l, q_r \in \typos$
    such that $\tau_l \times \tau_r$ is in $\tau$ at $p$ and
    $q_l \concat [ \tyleftprod ] \concat p, q_r \concat [ \tyrightprod
    ] \concat p \in \typosty{\tau}$,
    $q_l \concat [ \tyleftprod ] \concat p$ and
    $q_r \concat [ \tyrightprod ] \concat p$ are relatable positions
    of $\tau$.
  \end{itemize}
\end{defn}
%
The fact that $p, q \in \typos$ are relatable positions of
$\tau \in T$ is denoted $\relatable{\tau}{p}{q}$.

% define induction structure. Partial induction set:
Each relational refinement type defines a property of a map from
indices to types.
%
For finite space of indices $I$, the type positions \emph{indexed} by
$I$ are $\idxpos{I} = I \times \typos$.
% define relational refinement predicates of indexed types
Each relational refinement type contains predicates that relate data
components of types identified by indices.
%
\begin{defn}
  \label{defn:ref-refinements}
  For indices $I$ and $t : I \to T$,
  $\varphi \in \refpreds{ \idxpos{I} }$ is a \emph{relational
    refinement predicate} of $t$ if the following conditions hold:
  \begin{itemize}
  \item % vocab are all positions of their indexed types,
    For each $i \in I$ and $p \in \typos$ such that
    $(i, p) \in \vocab(\varphi)$, $p$ is a data position of $t(i)$.
  \item % vocab are all relatable,
    For each $i \in I$ and all $p, q \in \typos$ such that
    $(i, p), (i, q) \in \vocab(\varphi)$, it holds that
    $\relatable{\tau}{p}{q}$.
  \end{itemize}
\end{defn}

% introduce inductive defns:
Each relational refinement type also contains directives for how
inductive definitions at distinct indices are mutually unfolded in
order to express a property.
%
A partial mutual induction definition relates some inductive types
that are components of given indexed types.
%
\begin{defn}
  \label{defn:part-mut-unfold}
  For indices $I$, $t : I \to T$, and $P \subseteq \idxpos{I}$, $P$
  are a \emph{partial mutual induction set} of $t$ if
  \begin{itemize}
  \item % all positions are of type variables,
    For each $i \in I$ and $p \in \typos$ such that $(i, p) \in P$, it
    holds that $p$ is a variable position of $t(i)$.
  \item % all positions are relatable,
    For each $i \in I$ and all $p, q \in \typos$ such that
    $(i, p), (i, q) \in P$, it holds that $p \sim q$.
  \item % no distinct positions that extend an inductive type:
    For each $i \in I$, $p \in \typos$ a least-fixed point position of
    $t(i)$, and $q_0, q_1 \in \typos$ such that
    $(i, q_0 \concat p), (i, q_1 \concat p) \in P$, it holds that
    $q_0 = q_1$.
  \end{itemize}
\end{defn}

% complete induction set:
A complete mutual induction set relates all inductive types that are
components of a given vector of indexed types.
%
\begin{defn}
  \label{defn:compl-mut-unfold}
  For indices $I$ and $t : I \to T$,
  $\mathcal{Q} \subseteq \pset(\idxpos{I})$ are a \emph{complete}
  mutual induction set of $t$ if
  \begin{itemize}
  \item % each entry is a partial mutual induction defn:
    Each $P \in \mathcal{Q}$ is a partial mutual induction definition
    of $P$;
  \item % covers positions of variables:
    For each $i \in I$ and $p \in \typos$ a variable position of
    $t(i)$, there is some $P \in \mathcal{Q}$ such that
    $(i, p) \in P$.
  \end{itemize}
\end{defn}

% define relational types:
Relational refinement types relate data components of tuples of types
defined by mutual induction.
%
\begin{defn}
  \label{defn:rel-types}
  For indices $I$, a \emph{relational refinement type} over $I$ is a
  pair $(\Phi, M)$ where for some $t : I \to T$,
  % 
  \begin{itemize}
  \item % refinement predicates,
    $\Phi \subseteq \refpreds{ \idxpos{I} }$ are relational refinement
    predicates of $t$.
  \item % mutual induction defn,
    $M \subseteq \pset( \idxpos{I} )$ are a complete mutual induction
    set of $t$.
  \end{itemize}
\end{defn}
%
The space of relational types over $I$ is denoted $\reltypes{I}$.

% declare typing relation:
A key contribution of our work is the definition of a typing relation
from finite tuples of expressions to relational types.
%
For $e_0, \ldots, e_n \in \expr$ and
$\tau \in \reltypes{e_0, \ldots, e_n}$ (in which the indices are the
expressions $e_0, \ldots, e_n$ themselves), the fact that
$e_0, \ldots, e_n$ have type $\tau$ will be denoted
$e_0, \ldots, e_n : \tau$.
%
The typing relation is defined in \autoref{sec:rel-type-sys}.

% walkthrough the operations over types:
\subsubsection{Operations and relations over relational refinement types}
\label{sec:rel-type-ops}
The relational typing relation is defined using operators over
relational types.
%
The operators include generalizations of the type constructors and
operators over structural types, generalizations of type operators
used in refinement type systems, and operators introduced to operate
over features unique to relational types.

\paragraph{Relational refinement function types}
%
The relational function from type $\tau$ to $\tau'$ at index $i$ is a
relational refinement type in which the type at $i$ is a function from
the type at $i$ in $\tau$ to the type at $i$ in $\tau'$.
%
I.e., for the space of indices $I$, index $i \in I$, %
$\Phi, \Phi' \subseteq \refpreds{ \idxpos{I} }$, and %
$\mathcal{M}, \mathcal{M}' \subseteq \pset(\idxpos{I})$, the function
from $(\Phi, \mathcal{M})$ to $(\Phi', \mathcal{M}')$ at $i$, denoted
$(\Phi, \mathcal{M}) \to_i (\Phi', \mathcal{M}')$, is
$(\Phi'', \mathcal{M}'')$, where %
\begin{align*}
  \Phi'' \equiv & %
  \setformer{ \replace{ \varphi }{ (i, p) }{ (k, \typaramfield \cons p) } }{ %
    \varphi \in \Phi, p \in \typos } \union %
  \setformer{ \replace{ \varphi }{ (j, p) }{(k, \tyresfield \cons p)} }{ %
                  \varphi \in \Phi', p \in \typos } \\
  \mathcal{M}'' \equiv & %
  \setformer{ \replace{ M }{ (i, p) }{ (k, \typaramfield \cons p) } }{ %
  M \in \mathcal{M}, p \in \typos } \union
  \setformer{ \replace{ M }{ (j, p) }{ (k, \tyresfield \cons p) } }{ %
  M \in \mathcal{M}', p \in \typos }
\end{align*}
It is straightforward to prove that if $(\Phi, \mathcal{M})$ and
$(\Phi', \mathcal{M}')$ are relational refinement types, then
$(\Phi'', \mathcal{M}'')$ is a relational refinement type.

% define relational sum:
\paragraph{Relational refinement sum types} The relational sum of
types $\tau$ and $\tau'$ from indices $i$ and $j$ to index $k$ is a
relational refinement type in which the type at $k$ is the sum of
types at $i$ in $\tau$ and at $j$ in $\tau'$.
%
I.e., for space of indices $I$, indices $i, j, k \in I$,
$\Phi, \Phi' \subseteq \refpreds{ \idxpos{I} }$, and
$\mathcal{M}, \mathcal{M}' \subseteq \pset(\idxpos{I})$, the sum of
$(\Phi, \mathcal{M})$ and $(\Phi', \mathcal{M}')$ from $i$ and $j$ to
$k$, denoted $(\Phi, \mathcal{M}) +_{i, j}^k (\Phi', \mathcal{M}')$ is
$(\Phi'', \mathcal{M}'')$, where $\Phi''$ is
\begin{align*}
  \Phi'' \equiv & %
  \setformer{ \replace{ \varphi }{ (i, p) }{ (k, \tyleftsum \cons p) } }{ %
    \varphi \in \Phi, p \in \typos } \union %
  \setformer{ \replace{ \varphi }{ (j, p) }{(k, \tyrightsum \cons p)} }{ %
                  \varphi \in \Phi', p \in \typos } \\
  \mathcal{M}'' \equiv & %
  \setformer{ \replace{ M }{ (i, p) }{ (k, \tyleftsum \cons p) } }{ %
  M \in \mathcal{M}, p \in \typos } \union
  \setformer{ \replace{ M }{ (j, p) }{ (k, \tyrightsum \cons p) } }{ %
  M \in \mathcal{M}', p \in \typos }
\end{align*}
%
It is straightforward to prove that if $(\Phi, \mathcal{M})$ and
$(\Phi', \mathcal{M}')$ are relational refinement types, then
$(\Phi'', \mathcal{M}'')$ is a relational refinement type.

% define relational product:
\paragraph{Relational refinement product types}
The relational product of relational type $\tau$ from indices $i$ and
$j$ to index $k$ is a relational type in which the type at $k$ is the
product of types at $i$ and $j$.
%
I.e., for space of indices $I$, indices $i, j, k \in I$,
$\Phi \subseteq \refpreds{ \idxpos{I} }$, and
$\mathcal{M} \subseteq \pset(\idxpos{I})$, the relational product of
$(\Phi, \mathcal{M})$ from $i$ and $j$ to $k$, denoted
$\times_{i, j}^k (\Phi, \mathcal{M})$, is $(\Phi', \mathcal{M}')$,
where
\begin{align*}
  \Phi' = & \setformer{ %
    \replace{ \varphi }{ %
      (i, p), (j, q) }{ %
      (k, \tyleftprod \cons p), (k, \tyrightprod \cons q) } }{ %
    \varphi \in \Phi, p, q \in \typos } \\
  \mathcal{M}' = & \setformer{ %
    \replace{ M }{ %
    (i, p), (j, q) }{ %
    (k, \tyleftprod \cons p), (k, \tyrightprod \cons q) } }{ %
    M \in \mathcal{M}, p, q \in \typos }
\end{align*}
%
It is straightforward to prove that if $(\Phi, \mathcal{M})$ is a
relational refinement types, then $(\Phi', \mathcal{M}')$ is a
relational refinement type.

\paragraph{Relational refinement unfoldings}
\BH{define unfolding of fixpoint type}
%

% define refinement predicates, variance
\paragraph{Refinements of a relational refinement type}
Relational refinement type $\tau$ is a subtype of relational
refinement type $\tau'$ if it corresponds to a stronger property over
program values then the property to which $\tau'$ corresponds.
% define variance of type positions
The variance of a data position denotes if it
%
\BH{connect to this some known FP idiom}
%
\begin{defn}
  \label{defn:variance}
  The \emph{co-variance} and \emph{contra-variance} of type positions
  is defined inductively on the structure of type positions as
  follows:
  %
  \begin{itemize}
  \item % base case:
    $\epsilon \in \typos$ is \emph{covariant};
  \item % case that doesn't change variance:
    For each $p \in \typos$ and
    $f \not= \typaramfield \in \typosfields$, if $p$ is co-variant then
    $f \cons p$ is \emph{co-variant};
    %
    if $p$ is contra-variant, then $f \cons p$ is
    \emph{contra-variant}.
  \item % abstraction case:
    For each $p \in \typos$, if $p$ is covariant, then
    $\typaramfield \cons p$ is contra-variant, and if $p$ is
    contra-variant, then $\typaramfield \cons p$ is \emph{co-variant}.
  \end{itemize}
\end{defn}

% lift variance to refinement predicates
If some indexed position in $\vocab(\varphi)$ is co-variant, then
$\varphi$ is co-variant;
%
if some indexed position in $\vocab(\varphi)$ is contra-variant, then
$\varphi$ is contra-variant;
%
if $\varphi$ is both co-variant and contra-variant, then $\varphi$ is
bi-variant.

% define refinement
A refinement of relational type $\tau$ is $\tau$ extended to model
information about an index not in $\tau$.
%
Let the space of \emph{base refinement terms} consist of constants and
operations applied to indexed positions or variables.
%
For indices $I$, $\tau \in \reltypes{I}$, indexed position $p$, and
base term $t$, the \emph{refinement} of $\tau$ that equates $p$ with
$t$ is $\tau$ the relational refinement type with indices and fixpoint
structure identical to $\tau$, and with each refinement predicate
$\varphi$ replaced with the following predicate:
%
\begin{itemize}
\item % co-variant:
  If $\varphi$ is covariant, then $p = t \land \varphi$;
\item % contra-variant:
  If $\varphi$ is contravariant, then $p = t \implies \varphi$;
\item % bi-variant:
  If $\varphi$ is bi-variant, then $\varphi$.
\end{itemize}
%
For each $y \in \vars$, the refinement of $\tau$ that equates $x$ and
$y$ is the relational type with indices and fixpoint structure
identical to $\tau$, and with reach refinement predicate $\varphi$ of
$\tau$ replaced with the following predicate:
%
\begin{itemize}
\item % co-variant:
  If $\varphi$ is co-variant, then
  $(\bigland_{(x, p) \in \vocab(\varphi)} (x, p) = (y, p)) \land \varphi$.
\item % contra-variant:
  If $\varphi$ is contra-variant, then
  $(\bigland_{(x, p) \in \vocab(\varphi)} (x, p) = (y, p)) \implies \varphi$.
\item % bi-variant:
  If $\varphi$ is bi-variant, then $\varphi$.
\end{itemize}

\paragraph{Relational refinement subtypes}
%
\BH{complete}

\subsubsection{A relational type system}
\label{sec:rel-type-sys}
%
The typing relation from tuples of expressions to relational types is
defined as an instance of a typing relation from sub-expressions to
relational types.
% define context:
A \emph{contextual relational type} is a relational type with program
variables as indices.
%
I.e., the space of contextual relational types is $\reltypes{\vars}$.
%
A \emph{fixpoint relational context} is a map from fixpoint variables
to contextual relational types.
%
I.e., the space of contexts is
$\ctxs = \fixvars \partto \ctxreltypes$.

% define expression positions:
An \emph{expression position} partially identifies the position of an
expression within a larger expression, or within a tuple of
expressions.
%
The space of \emph{expression-position fields} is
$\expposfields = \elts{ \leftchild, \rightchild }$.
%
The space of \emph{expression positions} is
$\exppos = \expposfields^{*}$.
% 
The space of \emph{positioned relational types} is
$\reltypes{\vars \union \exppos}$.

% define typing relation over expressions in terms of positioned
% expressions
For $\Gamma \in \ctxs$, $\gamma \in \ctxreltypes$,
$E : \exppos \partto \expr$, and $\tau \in \posreltypes$, the fact
that $E$ have relational type $\tau$ under $\Gamma$ and $\gamma$ is
denoted $\Gamma, \gamma \judges E : \tau$;
%
the typing relation is defined below.
%
The typing relation over expressions is defined in terms of the typing
relation over positioned expressions.
%
In particular, for each $n \in \nats$, let the expression-position
encoding of $n$ be $\pos{n} = \leftchild \cons \rightchild^{n}$, and
let $\gamma_{\emptyset}$ denote the unique contextual relational type
over the empty set of variables.
%
Then for all $e_0, \ldots, e_{n - 1} \in \expr$ and
$\tau \in \reltypes{ e_0, \ldots, e_{n - 1} }$,
\[ e_0, \ldots, e_{n - 1} : \tau \equiv \cdot, \gamma_{\emptyset}
  \judges [ \pos{0} \mapsto e_0, \ldots, \pos{n - 1} \mapsto e_{n - 1}
  ] : \replace{ \tau }{ e_0, \ldots, e_{n - 1} }{ \pos{0}, \ldots,
    \pos{n - 1} } \]

% rules for determining if expression sequences have a relational type:
\begin{figure}
  \centering
  \begin{gather*}
    % empty:
    \inference[ EMPTY ]{ }{
      % the empty map of expressions has relational type true
      \Gamma, \gamma \judges \cdot : \gamma } 
    % unit:
    \inference[ UNIT ]{
      % get types for remainder,
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ \unit } : \tau %
    } 
    % constant:
    \inference[ CONST ]{ %
      % remainder has type tau,
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ c } : %
      \tau \joinctr p \equiv c } \\
    % vars:
    \inference[ VAR ]{ %
      \Gamma, \gamma \judges E : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ a } : %
      \tau \joinctr p \equiv a } 
    % base operation:
    \inference[ OP ]{ %
      % remainder has type tau,
      \Gamma, \gamma \judges %
      E[ \leftchild \cons p \mapsto e_0, %
        \rightchild \cons p \mapsto e_1 ] : \tau }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ e_0 \oplus e_1 } : %
      \tau \joinctr %
      p \equiv \leftchild \cons p \oplus \rightchild \cons p } \\
    % abstraction:
    \inference[ ABS ]{ 
      % extend the context and typecheck the body,
      \Gamma, \gamma \judges \upd{ E }{ p }{ e } : \tau }{ %
      % type of abstraction is
      \Gamma, \gamma' \judges \upd{ E }{ p }{ \lambda x. e } : %
      \gamma \to_p \tau } 
    % application:
    \inference[ APP ]{ %
      % get type of abstraction,
      \Gamma, \gamma \judges \upd{E}{p}{e_0} : \tau \to_p \tau' \\
      % get type of argument that is the parameter type,
      \Gamma, \gamma \judges \upd{E}{p}{e_1} : \tau }{
      % return the result type
      \Gamma, \gamma \judges \upd{ E }{ p }{e_0\ e_1} : \tau' } \\
    % pairing:
    \inference[ PAIR ]{
      % get type of both expressions,
      \Gamma, \gamma \judges %
      E[ \leftchild \cons p \mapsto e_0, %
      \rightchild \cons p \mapsto e_1 ] : \tau }{
      % then type of pair is
      \Gamma, \gamma \judges \upd{E}{p}{ \pair{e_0}{e_1} } :
      \times_{\leftchild \cons p, \rightchild \cons p}^p \tau } 
    % let:
    \inference[ LET ]{
      % get type of bound expression,
      \Gamma, \gamma \judges \epsilon \mapsto e_0 : %
      \times_{x, y}^{\epsilon} \gamma' \\
      % get type of result under context that binds to x and y,
      \Gamma, \gamma' \judges \upd{ E }{ p }{ e_1 } : \tau }{
      % then complete let expression has type
      \Gamma, \gamma \judges \upd{E}{p}{ \letexp{x}{y}{e_0}{e_1} } : %
      \tau } \\
    % left injection:
    \inference[ LEFT ]{
      % get type of the nested exp,
      \Gamma, \gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma, \gamma \judges \upd{E}{p}{ \injl\ e} : %
      \tau +_{p, p}^p \tau' } 
    % right injection:
    \inference[ RIGHT ]{
      % get type of the nested exp,
      \Gamma, \gamma \judges \upd{E}{p}{ e } : \tau }{
      % lift type at the left to sum,
      \Gamma, \gamma \judges \upd{E}{p}{ \injr\ e} : %
      \tau' +_{p, p}^p \tau } \\
    % match:
    \inference[ MATCH ]{
      % get type of matched exp,
      \Gamma, \gamma \judges \epsilon \mapsto e_0 : %
      \gamma' +_{x, y}^\epsilon \gamma'' \\
      % get type of left branch under context that binds x to left op,
      \Gamma, \gamma' \judges \upd{E}{p}{e_1} : \tau &
      % get type of right branch under context that binds y to right op,
      \Gamma, \gamma'' \judges \upd{E}{p}{e_2} : \tau }{
      % then type of match exp is type of both branches,
      \Gamma, \gamma \judges %
      \upd{E}{p}{ \matchexp{e_0}{ x }{e_1}{ y }{e_2} } : \tau } 
    % fixpoint:
    \inference[ FIX ]{
      % get type of body under context that binds symbol to tau,
      \upd{ \Gamma }{ f }{ \gamma' }, \gamma \judges %
      \upd{ E }{ p }{ e } : \tau \\
      % constrain that tau' with result renamed to f is subtype of tau,
      \replace{ \tau }{ p }{ f } \subtype \gamma' }{ %
      \Gamma, \gamma \judges \upd{ E }{ p }{ \fix{f}{e} }: \tau } \\
    % fixpoint variable:
    \inference[ FVAR ]{ }{
      % the empty map of expressions has relational type true
      \Gamma, \gamma \judges p \mapsto f : %
      \Gamma(f) \joinctr p \equiv f} 
    % unfold:
    \inference[ UNFOLD ]{
      % if expressions have tau unfolded at p,
      \Gamma, \gamma \judges E : \unfold{\tau} }{ 
      % then expressions have folded type
      \Gamma, \gamma \judges E : \tau } 
    % subtype:
    \inference[ SUB ]{
      % if expressions have tau,
      \Gamma, \gamma \judges E : \tau &
      % and tau subtypes tau',
      \tau \subtype \tau' }{ %
      % then expressions have type tau'
      \Gamma, \gamma \judges E : \tau' }
  \end{gather*}
  \caption{A typing system for relational types.
    %
    Metavariable %
    $\gamma$ ranges over contexual relational types, %
    $\Gamma$ ranges over contexts, %
    $E$ ranges over positioned expressions, %
    $p$ ranges over expression positions, %
    $e$ ranges over expressions, %
    $\tau$ ranges over relational types, %
    $c$ ranges over constants, %
    $x$ and $y$ range over abstraction variables, %
    $f$ ranges over fixpoint variables, and %
    $a$ ranges over variables. }
  \label{fig:reltypes-rules}
\end{figure}

% define judgment:
The typing relation over positioned expressions is defined by the
inductive inference rules given in \autoref{fig:reltypes-rules}.
%
The inference rules consist of syntax-directed rules that define the
typing relation for arbitrary expressions in a collection of
positioned expressions, along with rules that define the typing
relation for special cases of positioned expressions and for assigning
relational least-fixed-point types and using the subtype relation.
% empty:
Rule~EMPTY establishes that under contextual relational type $\gamma$,
the empty positioned expressions (denoted $\cdot$) have type $\gamma$.

% unit:
Rule~UNIT establishes that if positioned expressions $E$ have type
$\tau$, then $E$ extended to bind position $p$ to the unit have type
$\tau$.
% const:
Rule~CONST establishes that if $E$ have type $\tau$, then $E$ extended
to bind $p$ to constant $c$ have type $\tau$ refined to equate $p$
with $c$.
% variables:
Rule~VAR establishes that if $E$ have type $\tau$, then $E$ extended
to bind $p$ to variable $a$ have type $\tau$ refined to equate $p$
with $a$.
% op:
Rule~OP establishes that if $E$ extended to bind positions
$\leftchild \cons p$ and $\rightchild \cons p$ to expressions $e_0$
and $e_1$ have type $\tau$, then $E$ extended to bind $p$ to
$e_0 \oplus e_1$ have type $\tau$ refined to set $p$ to
$\leftchild \cons p \oplus \rightchild \cons p$.

% abs:
Rules~ABS and APP are defined using the relational function type
operator.
%
Rule~ABS establishes that if, under contextual relational type
$\gamma$, $E$ extended to bind $p$ to expression $e$ have type $\tau$,
then under contextual relational type $\gamma'$, $E$ extended to bind
$p$ to $\lambda x. e$ is a relational function from $\gamma$ to
$\tau'$ at $p$.
% app:
Rule~APP establishes that if %
\textbf{(1)} $E$ extended to bind $p$ to $e_0$ is a relational
function from $\tau$ to $\tau'$ at $p$ and %
\textbf{(2)} $E$ extended to bind $p$ to $e_1$ has type $\tau$, then
$E$ extended to bind $p$ to $e_0$ applied to $e_1$ has type $\tau'$.

% relational prod:
Rules~PAIR and LET are defined using the relational product type
operator.
% pair:
Rule~PAIR establishes that if $E$ extended to bind
$\leftchild \cons p$ and $\rightchild \cons p$ to $e_0$ and $e_1$ has
type $\tau$, then $E$ extended to bind $p$ to $\pair{ e_0 }{ e_1 }$ is
the relational product of $\tau$ from $\leftchild \cons p$ and
$\rightchild \cons p$ to $p$.
% let:
Rule~LET establishes that if %
\textbf{(1)} under $\gamma$, the $e_0$ is the relational product of
$\gamma'$ from variables $x$ and $y$;
%
\textbf{(2)} under $\gamma'$, $e_1$ has type $\tau$, then under
$\gamma$, $E$ extended to bind $p$ to $\letexp{x}{y}{e_0}{e_1}$ has
type $\tau$.

% relational sum:
Rules~LEFT, RIGHT, and MATCH are defined using the relational sum type
operator.
% left:
Rule~LEFT establishes that if $E$ extended to bind $p$ to $e$ has type
$\tau$, then $E$ extended to bind $p$ to the left injection of $e$ is
a relational sum of from $p$ and $p$ to $p$ of $\tau$ and any
relational type $\tau'$.
%
Rule~RIGHT is defined symmetrically to Rule~LEFT.
% match:
Rule~MATCH establishes that if %
\textbf{(1)} under $\gamma$, $e_0$ is the relational sum of $\gamma'$
and $\gamma''$ from variables $x$ and $y$;
% 
\textbf{(2)} under $\gamma'$, $E$ extended to bind $p$ to $e_1$ has
type $\tau''$; and
%
\textbf{(3)} under $\gamma''$, $E$ extended to bind $p$ to $e_2$ also
has type $\tau''$, then under $\gamma$, $E$ extended to bind $p$ to
$\matchexp{e_0}{x}{e_1}{y}{e_2}$ has type $\tau''$.

% fix:
Rule~FIX establishes that if %
\textbf{(1)} under $\Gamma$ extended to bind $f$ to $\gamma'$ and
$\gamma$, $E$ extended to bind $p$ to $e$ has type $\tau$; and %
\textbf{(2)} $\tau'$ with $p$ renamed to $f$ is a subtype of
$\gamma'$, then under $\Gamma$ and $\gamma$, $E$ extended to bind $p$
to $\fix{f}{e}$ has type $\tau$.
% fixpoint var:
Rule~FVAR establishes that under context $\Gamma$, the positioned
expression that maps only position $p$ to fixpoint variable $f$ has
type $\Gamma(f)$ refined to equate $p$ with $f$.

% unfold:
Rule~UNFOLD establishes that if $E$ has type $\tau$ unfolded,
then $E$ has type $\tau$.
% sub:
Rule~SUB establishes that if $E$ has type $\tau$ a subtype of $\tau'$,
then $E$ has type $\tau'$.

% main lemma of the typing system:
The typing relation is preserved by the evaluation relation.
%
\begin{lemma}
  \label{lemma:preservation}
  For all $e_0, \ldots, e_n$, $v_0, \ldots, v_n \in \values$ such that
  $v_0 \evalsto v_0, \ldots, e_n \evalsto v_n$, and
  $\tau \in \reltypes{e_0, \ldots, e_n}$ such that
  $e_0, \ldots, e_n : \tau$, it holds that $v_0, \ldots, v_n : \tau$.
\end{lemma}
%
One proof of \autoref{lemma:preservation} uses proof by induction on
%
\BH{complete}

\subsection{Inferring relational refinement types}
\label{sec:infer}
%
A key contribution of our work is a type-inference algorithm for
relational refinement types, named \sys.
%
\sys, given expressions $e_0, \ldots, e_n$ and relational refinement
type $\tau$, attempts to determine if $e_0, \ldots, e_n : \tau$.
%
This section defines bounded unfoldings of expressions, which are
maintained by \sys (\autoref{sec:bnd-unfoldings}).

\subsubsection{Bounded unfoldings of expressions}
\label{sec:bnd-unfoldings}

% types as proving equivalence:
\BH{deprecated}

% structures maintained by inference algorithm. Unfoldings:
\sys attempts to extract a proof that $P_0, P_1 : \tau_{\equiv}$ from
a map from sets of \emph{unfoldings} of sub-expressions of $P_0$
and $P_1$ to candidate relational types.
%
\begin{defn}
  \label{defn:unfoldings}
  For each $f \in \vars$ and $e \in \expr$, the \emph{unfoldings} of
  $\fix{f}{e}$, denoted $\unfoldings{ \fix{f}{e} }$

 are the smallest set of expressions such that:
  %
  \begin{enumerate}
  \item $f \in \unfoldings{ \fix{f}{e} }$;
  \item For each $e' \in \unfoldings{ \fix{f}{e} }$, $\replace{
      \fix{f}{e} }{ f }{ e' } \in \unfoldings{ \fix{f}{e} }$.
  \end{enumerate}
\end{defn}
%
\BH{fix defn of unfoldings above to allow the unfolded expressions to
  occur as subexpressions of the main expressions}
%
\BH{give examples}

% invariant structure:
\BH{rename this}
%
Partial relational invariants assign sets of subexpressions to
relational types.
%
\begin{defn}
  \label{defn:inferred-invs}
  Let
  \begin{itemize}
  \item 
    % subexpressions of unfoldings:
    $\mathcal{E} \subseteq \pset(\subexps{ \unfoldings{P_0} } \union
      \subexps{\unfoldings{P_1} })$;
  \item
    % context types:
    \BH{update}
  \item
    % relational types of subexpressions:
    \BH{update}
  \end{itemize}
  %
  be such that 
  \begin{itemize}
  \item 
    % set of programs has the equivalence type:
    $T( \elts{ P_0, P_1 } ) \entails \tau_{ \equiv }$; 
  \item 
    % type of set is subtype of type of extension with fixpoint
    % symbol
    For all $E \in \mathcal{E}$ and each $f \in \vars$, $T(E) \subtype
    T(\add{ f }{ E })$.
  \item 
    % relational types are consistent under tiling:
    For each $E \in \mathcal{E}$ and $E_0, E_1 \subseteq E$ such that
    $E = E_0 \union E_1$, it holds that $T(E_0) \land T(E_1) \subtype
    T(E)$.
  \item 
    % relational types are consistent under subtypes:
    For all $e \in \expr$, $E \subseteq \expr$ such that $\add{ e }{ E
    } \in \mathcal{ E }$, $\Gamma(\subexps{e} \union E) \judges
    \subexps{ e } \union E : T( \subexps{e} \union E)$ supports that
    $\Gamma(\add{ e }{ E }) \judges \add{ e }{ E } : T(\add{ e }{ E
    })$.
  \end{itemize}
\end{defn}
%
\BH{patch to account for how predecessors actually work in typing
  rules}
%
\BH{add choice conditions that make invariants evidence}

% define when invariants are inductive:
Unfolded invariants are inductive if they define a proof of the fact
that $P_0$ and $P_1$ have type $\tau_{\equiv}$.
% 
\begin{defn}
  \label{defn:ind-unfolded}
  \BH{complete}
\end{defn}

% evidence is a valid proof of partial equivalence:
If $P_0$ and $P_1$ have relational invariants, then $P_0 \equiv P_1$.
%
\begin{lemma}
  \label{lemma:equiv-evidence}
  If there are $R \in \relinvs{P_0}{P_1}$, then $P_0 \equiv P_1$.
\end{lemma}
%
\sys, given programs $P_0$ and $P_1$, attempts to determine their
partial equivalence by synthesizing inductive unfolded relational
types.

\subsubsection{A relational type-inference algorithm}
\label{sec:infer-alg}

\begin{figure}
  \centering
\begin{algorithm}[H]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  %
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{Programs $\cc{P}_0, \cc{P}_1 \in \stlc$.}
  % Output: decision for safety
  \Output{A decision as to whether $\cc{P}_0 \equiv \cc{P}_1$.}
  % verify: main procedure
  \myproc{$\verify(\cc{P}_0, \cc{P}_1)$ \label{line:core-begin}} %
  { \myproc{$\verifyaux(\cc{P}_0' \in \unfoldings{ \cc{P}_0 }, %
      \cc{P}_1' \in \unfoldings{ \cc{P}_1 })$}{ %
      % try to verify the unfoldings:
      \Switch{$\verifybnd(\cc{P}_0', \cc{P}_1')$ \label{line:ver-bnd} }{
        % if the verifier returns that the unfoldings aren't equivalent
        \lCase{$\nonequiv$}{ 
          % then the top-level returns that the programs aren't
          % equivalent
          \Return{$\false$} \label{line:ret-non-eq} }
        % if the verifier returns relational types of the unfoldings:
        \Case{$T \in \subexptypes{ \cc{P}_0' }{ \cc{P}_1' }$ %
          \label{line:subexp-types} }{ %
          % then check if they're inductive:
          \Switch{$\chkinductive(T)$ \label{line:chk-ind} }{ 
            \lCase{$\isind$}{ \Return{$\true$} \label{line:ret-eq} }
            \lCase{ %
              $\cc{P}_0'' \in \unfoldings{ \cc{P}_0 }, %
              \cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$}{
              \Return{$\verifyaux(\cc{P}_0'', \cc{P}_1'')$ %
                \label{line:ret-rec} }
            }
          }
        }
      }
    }
    \Return{$\verifyaux(\folded(\cc{P}_0), \folded(\cc{P}_1))$ %
      \label{line:core-base} }
  }
  %
  \caption{% interface of verify:
    \verify: an equivalence verifier, which uses procedures
    \verifybnd (\autoref{sec:verify-ders}) and %
    \chkinductive (\autoref{sec:chk-ind}).  }
  \label{alg:infer}
\end{algorithm}
\end{figure}

% verifier top-level:
The equivalence verifier \verify is given in \autoref{alg:infer}.
%
\verify, given $P_0, P_1 \in \stlc$ (\autoref{line:core-begin}),
defines a procedure $\verifyaux$ that, given $\cc{P}_0' \in
\unfoldings{ \cc{P}_0 }$ and $\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$,
attempts to determine if $P_0 \equiv P_1$ by typed subexpressions of
an unfolding 
%
\BH{fix}
%
of $\cc{P}_0'$ and $\cc{P}_1'$, or determines that $\cc{P}_0
\not\equiv \cc{P}_1$
(\autoref{line:core-aux-begin}---\autoref{line:core-aux-end}).
%
\verify calls \verifyaux on the complete folding of $\cc{P}_0$ and
$\cc{P}_1$ and returns the result (\autoref{line:core-base}).

% verify auxiliary procedure:
\verifyaux, given $\cc{P}_0 \in \unfoldings{\cc{P}_0}$ and $\cc{P}_1
\in \unfoldings{ \cc{P}_1 }$, runs procedure \verifybnd on $\cc{P}_0'$
and $\cc{P}_1'$ (\autoref{line:ver-bnd}).
%
If \verifybnd returns $\nonequiv$, then \verify returns that $\cc{P}_0
\not\equiv \cc{P}_1$ (\autoref{line:ret-non-eq}).

%
Otherwise, if \verifybnd returns $T \in \subexptypes{ \cc{P}_0' }{
  \cc{P}_1' }$,
%
\BH{define sub-expression types}
%
then \verify runs procedure \verifyaux on $T$
(\autoref{line:subexp-types}), then \verifybnd runs procedure
\chkinductive on $T$ (\autoref{line:chk-ind}).
%
If \chkinductive returns $\isind$, then \verify returns that $\cc{P}_0
\equiv \cc{P}_1$ (\autoref{line:ret-eq}).
% subcase: invariants are not inductive:
Otherwise, if \chkinductive returns $\cc{P}_0'' \in \unfoldings{
  \cc{P}_0 }$ and $\cc{P}_1'' \in \unfoldings{ \cc{P}_1 }$, then
\verifyaux runs \verifyaux on $\cc{P}_0''$ and $\cc{P}_1''$ and
returns the result (\autoref{line:ret-rec}).

% overview the rest of the section
\autoref{sec:type-unfoldings} gives an implementation of
\autoref{sec:type-unfoldings};
%
\autoref{sec:chk-ind} gives an implementation of \chkinductive.

\subsubsection{Typing subexpressions of unfoldings}
\label{sec:type-unfoldings}
% give an overview:
\verifybnd, given $\cc{P}_0' \in \unfoldings{ \cc{P}_0 }$ and
$\cc{P}_1' \in \unfoldings{ \cc{P}_1 }$, either returns types of the
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$ or returns $\nonequiv$
to denote that $\cc{P}_0' \not\equiv \cc{P}_1'$.
%
\verifybnd reduces this problem to solving a CHC system
(\autoref{sec:chcs}).
%
Each solution of the system defines types and contexts of
subexpressions of $\cc{P}_0'$ and $\cc{P}_1'$.
%
The clauses of the system correspond to rules for establishing types
of expressions (\autoref{fig:reltypes-rules}).

% give the construction in detail:
\BH{update}
%
\verifybnd generates the following CHC system $\mathcal{C}_{
  \cc{P}_0', \cc{P}_1' }$.
% define the space of relational predicates
Let $E \subseteq \subexps{ \cc{P}_0' } \union \subexps{ \cc{P}_1' }$.
% define relational predicates of a set of types:
For typed symbols $T$, let the set of relational predicates
$\symrelpreds{ T }$ be defined as follows.
% base case: T is the empty set of types:
If $T = \emptyset$, then $R_T = \emptyset$.
% inductive case: T is a non-empty set
Otherwise, let $R$ be such that for all $\tau_0, \ldots, \tau_n, \tau'
\in \reftypes$ such that $\tau = \tau_0 \rightarrow \ldots \rightarrow
\tau_n \rightarrow \tau'$, $R$ has variables corresponding to
$\tau_0$, \ldots, $\tau_n$, and $\tau'$.
%
Let $T'$ be collection of typed symbols in which each symbol is a pair
of a typed symbol $f \in T$ and the position of a higher-order
argument type in the type of $f$ in $T$.
%
Then $\symrelpreds{ T } = \add{ \symrelpreds{ T' } }{ R }$.

% define type of a context:
Let $\Gamma : E \times \vars \to \types$ map each $e \in E$ and each
$x \in \freevars(e)$ to its type in $e$, and let $R_E^{\Gamma} =
\symrelpreds( \Gamma )$.
%
Let $T : E \to \types$ map each $e \in E$ to its type under its
context in $\cc{P}_0$ or $\cc{P}_1$.
%
\BH{define all notions of base types in programs correctly}
%
Let $R_E = \symrelpreds(\Gamma \union T)$.
%
The relational predicates of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$
are $\bigunion \setformer{ R_E^{\Gamma} \union R_E }{ E \in
  \antichains{ \cc{P}_0' }{ \cc{P}_1' }}$.

% define clauses
The clauses of $\mathcal{C}_{ \cc{P}_0', \cc{P}_1' }$ are defined as
follows.
%
\BH{define clauses for each relational type}

% define join of relational predicates:
For $\mathcal{R}, \mathcal{R}', \mathcal{R}''$,
%
\BH{patch}
%
, the clauses $\mathcal{R}\andsub(E_0, E_1, E')$ and $\orsub(E_0, E_1,
E')$ constrain that the conjunction (and similarly, disjunction) of
the relational types defined by interpretations of $\symrelpreds(E_0)$
and the interpretations of $\symrelpreds(E_1)$ is a subtype of the
interpretation of the $\symrelpreds(E')$.
%
I.e., if $R$
%
\BH{define clauses for subtype of conjunction (and
  disjunction). Maybe need to structure relational predicates in
  sequences.}
%
Such clauses are denoted $\mathcal{R} \joinctr \mathcal{R}' \subtype
\mathcal{R}''$.

\BH{remove indices}

% enumerate clauses per form of expression:
\verifybnd generates clauses that model each of the syntax-directed
typing rules given in (\autoref{fig:reltype-rules}).
% sets of atomic expressions:
For all $E_0 \subseteq \subexps{ P_0 }$ and $E_1 \subseteq \subexps{
  P_1 }$ such that $E_0$ and $E_1$ contain only atomic expressions,
\verifybnd generates the following clauses:
%
$\mathcal{R} \joinctr %
\bigland \setformer{ c = (c, i) }{ c \in \consts, i \in I, (c, i) \in E
} \subtype \mathcal{R}'$.

% clauses for op:
Let $e_0, e_1 \in \subexps{ \cc{P}_0 }$ such that $e_0 \oplus e_1
\in \subexps{ P_0 }$, %
$E_0 \subseteq \subexps{ P_0 }$, and %
$E_1 \subseteq \subexps{ P_1 }$.
%
\verifybnd generates the clauses
\begin{align*}
  % constrain contexts,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % subtyping of expression types:
  \mathcal{R}, %
  \resvar{e_0 \oplus e_1} = \resvar{e_0} \oplus \resvar{e_1} &
  \subtype \mathcal{R}'
\end{align*}
%
\BH{define subtyping constraint syntax over ops}
%
Similar clauses are included for all subexpressions of $P_1$ that are
constructed from binary operations.

% clauses for if-then-else:
For all $e_0, e_1, e_2 \in \subexps{ P_0' }$ and $E \subseteq
\subexps{ P_0 } \union \subexps{ P_1 }$, let $\mathcal{R} =
\symrelpreds(\elts{ e_0, e_1, e_2 } \union E)$ and $\mathcal{R}' =
\symrelpreds(\elts{ \ite{ e_0 }{ e_1 }{ e_2 } } \union E)$.
%
Then \verifybnd generates relational predicates $R_0$ and $R_1$ and
clauses
%
\BH{fix this defn}
\begin{align*}
  % context subtyping,
  \mathcal{R}'_{\Gamma} & \subtype \mathcal{R}_{\Gamma} &
  % copy the then expression to the whole expression:
  \mathcal{R}, \resvar{e_0} = \true & \subtype \mathcal{R}_T &
  % case where guard is true: define the copy predicates:
  \resvar{ e_1 } \equiv \resvar{ e } & \subtype \mathcal{COPY}_T &
  % copy value from the then expression to the whole expression:
  \mathcal{R}_T \joinctr \mathcal{COPY}_T & \subtype \mathcal{R}' &
  % assume that 
  \mathcal{R}_T, \resvar{ e_0 } = \true & \subtype \mathcal{R}'
  % case where guard is false:
\end{align*}
%
\BH{renamesub: remove use}
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_0 }{ \mathcal{ R }' }{ \resvar{ (e_1, i_1) }
}{ \resvar{(e, i)} }$,
%
\BH{define updated sets of relational predicates}
% add constraint for case where the guard is false,
$\ctrclause{ R }{ R_1 }{ \resvar{ (e_0, i) } = \false}$, and
%
% add constraints that relate this case to final result,
$\renamesub{ \mathcal{R}_1 }{ \mathcal{ R }' }{ \resvar{ (e_2, i_2) }
}{ \resvar{ (e, i) } }$.
%
Similar clauses are included for all \cc{if}-\cc{then}-\cc{else}
subexpressions of $P_1$.

% clause for abs
For all $x \in \vars$, %
$e \in \subexps{ P_0' }$ such that $\lambda x. e \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \subseteq \subexps{P_1}'$, \verifybnd adds clauses that solve
for a relational type of $x$, use it to strengthen the context for
typechecking the $e$.
%
I.e., \verifybnd generates a collection of relational predicates
$\mathcal{R}_x$ for $x$ grouped with $E_0$ and $E_1$, %
adds the clauses
% context for typechecking body is strengthen
$\mathcal{R}'_{\Gamma} \joinctr \mathcal{R}_x \subtype
\mathcal{R}_{\Gamma}$, %
% type of body is type of abstraction, after renaming:
$\renamesub{ \mathcal{R} }{ \mathcal{R}' }{ x }{ \argnum{e} }$.
%
Similar clauses are included for all abstraction subexpressions of
$P_1$.

% clause for app
For all $e_0, e_1 \in \subexps{P_0'}$ such that $e_0\ e_1 \in
\subexps{P_0'}$, %
$E_0 \subseteq \subexps{P_0'}$, and %
$E_1 \in \subexps{P_1'}$, let $E = E_0 \union \elts{ e_0, e_1 }
\union E_1$, %
let $E' = E_0 \union \elts{ e_0\ e_1 } \union E_1$, and %
let $f$ be a fresh variable with the same type as $x$.
%
\verifybnd adds the clauses 
% type of context is subtype of context over components:
$E_{\Gamma} \subtype E'_{\Gamma}$ and %
$\replace{ E }{ \firstarg{e_0} }{ f } \subtype \replace{ E }{ e_1 }{ f
}$.
%
\BH{define firstarg symbolic variable per expression}
%
Similar clauses are included for all application subexpressions of
$P_1$.

% define clauses for subsets of expressions
For all $E_0, E_0', E_0'' \in \antichains{ P_0' }$ and %
$E_1, E_1', E_1'' \in \antichains{ P_1' }$ such that $E_1 \union E_1'
= E_1''$, \verifybnd generates clauses $(E_0 \union E_1) \joinctr
(E_0' \union E_1') \subtype E_0'' \union E_1''$.

\BH{define the query of the system}

% walk through the other typing rules that aren't used.
\verifybnd does not generate clauses that model the typing rule
\textsc{Fix}, because an unfolding cannot contain a fixpoint
expression.
%
\verifybnd does not explicitly add clauses that model uses of the
\textsc{Sub} rule, given that a CHC solution may choose types for any
set of expressions that satisfy a subtyping relationship.
%
Sets of fixpoint variables are unconstrained, and in particular may be
interpreted as $\false$.

\subsubsection{Determining inductiveness of unfolded relational types}
\label{sec:chk-ind}
% algorithm for checking inductiveness:
\begin{algorithm}[t]
  % Declare IO markers.
  \SetKwInOut{Input}{Input}
  % 
  \SetKwInOut{Output}{Output}
  % Declare sub-program (procedure) markers.
  \SetKwProg{myproc}{Procedure}{}{}
  % Inputs: a program
  \Input{$T \in \unfoldreltypes{ P_0 }{ P_1 }$.}
  % Output: decision for safety
  \Output{$\isind$ to denote that some restriction of $T$ is
    inductive, or $d_0 \in \progders{P_0}$ and %
    $d_1 \in \progders{P_1}$ that evaluate sub-expressions without
    types in $T$.}
  % verify: main procedure
  \myproc{$\mathcal{E} \subseteq T \in \unfoldreltypes{ P_0 }{ P_1 }$ %
    \label{line:chkind-begin} } %
  { \myproc{ 
      % given obligation sets of unfolded expressions,
      $\chkindaux(E$, %
      % and a map from sets of fixpoint expressions to relational
      % types,
      $F : \mathcal{E} \to )$ %
      \label{line:chkind-aux-begin} } %
    { % if all of the expressions are atomic,
      \lIf{$E \subseteq \atomics$}{ %
        % then whatever invariants that we have are inductive:
        \Return{$\isind$} \label{line:ret-isind} }
      % if E contains a fixpoint symbol, 
      \lIf{$f \in \fixvars, E$}{ %
        % then return E grouped with the unfolding of f
        \Return{ $\replace{ E }{ f }{ \fix{ f }{ \fixexpr{ f } } }$ 
        } }  %
      % for each expression that is a fixpoint, 
      \ForEach{$\fix{ f }{ e } \in E$}{ 
        % if the maintained type for the core expressions is stronger,
        \lIf{$T'(\orgexprs(E)) \entails T(E)$}{
          % then return that this part is inductive
          \Return{$\isind$} } 
        \lElse{ 
          % otherwise, strengthen the maintained invariants
          $T' \assign \upd{ T' }{ \orgexprs(E) }{ T(E) }$ } }
      % for each tiling of E,
      \ForEach{$E_0 \union E_1 = E$}{ 
        % if the results are both inductive,
        \lIf{$\chkindaux(E_0, T') = %
          \chkindaux( E_1, T' ) = %
          \isind$}{
          % then this set is inductive:
          \Return{$\isind$}
        } }
      % otherwise,
      \Return{$\unwind(E, T')$}
    } }
  \Return{$\chkindaux(\elts{ P_0, P_1 }, \lambda x.\ \true)$} %
  \label{line:chkind-base} 
  % 
\caption{ % interface of chkinductive:
  \chkinductive: determines the inductiveness of derivation
  relational invariants. }
\label{alg:chk-ind}
\end{algorithm}
%
\BH{define map from each fixpoint variable to its expression}

%
The algorithm \chkinductive for checking the inductiveness of
derivation relational invariants is given in
\autoref{alg:chk-ind}.
%
\chkinductive, given $P_0, P_1 \in \stlc$ and $I \in
\unfoldreltypes{P_0}{P_1}$ (\autoref{line:chkind-begin}), defines a
procedure \chkindaux that, given $\Gamma_0 \in \derctxs{P_0}^{*}$,
$\Gamma_1 \in \derctxs{P_1}^{*}$, and $I: \subexpseqs \to
\symrels{P_0}{P_1}$, returns either %
\textbf{(1)} $\isind$ to denote that if $I_{\Gamma}$ restricted to
extensions of $\Gamma$ is inductive under $I_E$
%
\BH{define}
%
or
%
\BH{update, clarify}
%
\textbf{(2)} derivations of $P_0$ and $P_1$ whose contexts do not have
relational invariants in $I$
(\autoref{line:chkind-aux-begin}---\autoref{line:chkind-aux-end}).
%
If case \textbf{(1)} holds, we say that $(\Gamma_0, \Gamma_1)$ is
inductive in $D$ under $I$.
%
\chkinductive calls \chkindaux on the empty derivation contexts of
$P_0$ and $P_1$ and a map from each element in $\subexpseqs$ to
$\true$, and returns the result (\autoref{line:chkind-base}).

% aux function: contexts have no invariant:
\chkindaux collects the pair $E$ of sequences of expressions of the
derivation contexts in $\Gamma_0$ and $\Gamma_1$
(\autoref{line:chkind-bind-exps}), and then determines if $(\Gamma_0,
\Gamma_1)$ has relational invariants defined in $D$.
%
If not, then \chkindaux returns a sequence of derivations of all
expressions in $E$ (\autoref{line:chkind-counters}).

% aux function: subcase: invariants are entailed by invariants in I:
Otherwise, \chkindaux collects the relational invariants $\varphi_E$
bound to $E$ in $I_E$ (\autoref{line:bind-exp-invs}), %
collects the symbolic relation $\varphi_{\Gamma}$ bound to $\Gamma_0$
and $\Gamma_1$ in $I_{\Gamma}$ (\autoref{line:bind-der-invs}), and %
determines if $\varphi_E$ entails $\varphi_{\Gamma}$.
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive in $I_{\Gamma}$ under $I_E$ (\autoref{line:ret-isind}).

% aux fn: subcase: some tiling is inductive
Otherwise, \chkindaux constructs relational invariants $I_E'$ that
strengthen $I_E$ at $E$ with $\varphi_{\Gamma}$
(\autoref{line:str-invs}).
%
\chkindaux determines if either there is some tiling of $\Gamma_0$
such that each tile paired with $\Gamma_1$ is inductive in
$I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind0}), or there is
some tiling of $\Gamma_1$ such that $\Gamma_0$ paired with each tile
is inductive in $I_{\Gamma}$ under $I_E'$ (\autoref{line:tile-isind1}).
%
If so, then \chkindaux returns that $\Gamma_0$ and $\Gamma_1$ are
inductive under $I_E'$ (\autoref{line:tile-isind}).

% aux fn: subcase: unwind
Otherwise, \chkindaux runs the procedure $\unwind$...


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
