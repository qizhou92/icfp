\section{Background}
\label{sec:background}
%
In this section, we define as our target language an extension of the
simply-typed $\lambda$-calculus (STLC) (\autoref{sec:stlc}).
%
We then define partial equivalence of STLC programs
(\autoref{sec:peq}).

\subsection{The Simply-Typed $\lambda$-calculus}
\label{sec:stlc}
\begin{figure}[t]
  \begin{minipage}{0.48\linewidth}
    \begin{align*}
      % expression is a constant,
      e \rightarrow &\ c \\
      % or a variable,
      | &\ x \\
      % or a binary operation,
      | &\ e \oplus e \\
      % or an if-then-else, 
      | &\ \ite{ e }{ e }{ e } \\
      % or an abstraction,
      | &\ \lambda x.\ e \\
      % or a fixpoint,
      | &\ \fix{ f }{ e } \\
      % or an application,
      | &\ e\ e 
    \end{align*}
    \caption{The space of program expressions, $\expr$.
      %
      Metavariable $e$ ranges over $\expr$.} %
    \label{fig:exprs}
  \end{minipage}
  %
  \begin{minipage}{0.48\linewidth}
    \begin{align*} %
      \tau \rightarrow &\ \base\ %
      |\ \tau \to \tau \\
      \base \rightarrow &\ \bools\ %
      |\ \ints
    \end{align*}
    \caption{The space of types, $\types$.
      % 
      Metavariable $\tau$ ranges over $\types$.} %
    \label{fig:types}
  \end{minipage}
\end{figure}

% define STLC syntax:
\paragraph{Syntax} \autoref{fig:exprs} defines the space of
simply-typed $\lambda$-calculus expressions, $\expr$.
%
For the remainder of this paper, metavariable $e$ ranges over
$\expr$, %
$c$ ranges over constants, %
$\oplus$ ranges over binary operators, and $x$ and $f$ range over
program variables.
%
An expression is a Boolean or integer constant, %
a variable (drawn from space of variables $\vars$), %
an application of an fixed operator to a pair of expressions, %
an \cc{if}-\cc{then}-\cc{else} expression, %
a $\lambda$-abstraction, %
an application, or %
a fixpoint expression.
%
For each $e \in \expr$, the \emph{free-variables} of $e$ are denoted
$\freevars(e)$.
%
A STLC \emph{program} is a closed expression---i.e., an expression $e$
such that $\freevars(e) = \emptyset$.
%
The space of STLC programs is denoted $\stlc$.
%
For $P \in \stlc$, the set of all subexpressions of $P$ is denoted
$\subexps(P)$.
%
Let $P$ be fixed for the rest of this section.

% define semantics:
\paragraph{Semantics}
%
\begin{figure}
  \centering
  \begin{gather*}
  % evaluate const:
  \inference[ CONST ]{ }{ \Gamma \judges c \evalsto c } 
  % evaluate variable:
  \inference[ VAR ]{ }{ \Gamma \judges x \evalsto \Gamma(x) }
  % evaluate binary operations:
  \inference[ OP ]{ %
    \Gamma \judges e_0 \evalsto v_0 & %
    \Gamma \judges e_1 \evalsto v_1 } %
  { \Gamma \judges e_0 \oplus e_1 \evalsto v_0 \oplus v_1 } \\
  \\
  % evaluate if-then-else by then branch
  \inference[ ITE-T ]{ %
    \Gamma \judges e_0 \evalsto \true & %
    \Gamma \judges e_1 \evalsto v_1 } %
  { \Gamma \judges \ite{ e_0 }{ e_1 }{ e_2 } \evalsto v_1 }
  % evaluate if-then-else by else branch
  \inference[ ITE-F ]{ %
    \Gamma \judges e_0 \evalsto \false & %
    \Gamma \judges e_2 \evalsto v_2 } %
  { \Gamma \judges \ite{ e_0 }{ e_1 }{ e_2 } \evalsto v_2 } \\
  \\
  % evaluate an abstraction:
  \inference[ ABS ]{ } %
  { \Gamma \judges \lambda x.\ e \evalsto \lambda x.\ e }
  % evaluate a fix:
  \inference[ FIX ]{ } %
  { \Gamma \judges \fix{ f }{ e } \evalsto \fix{ f }{ e } } \\
  \\
  % apply a lambda:
  \inference[ APP-$\lambda$ ]{ %
    \Gamma \judges e_0 \evalsto \lambda x.\ e_0' & %
    \Gamma \judges e_1 \evalsto v_1 & %
    \upd{\Gamma}{x}{v_1} \judges e_0' \evalsto v }
  { \Gamma \judges e_0\ e_1 \evalsto v } \\
  \\
  % apply a fixpoint:
  \inference[ APP-FIX ]{ %
    \Gamma \judges e_0 \evalsto \fix{ f }{ e_0' } & %
    \upd{ \Gamma }{ f }{ \fix{ f }{ e_0' } } \judges %
    e_0'\ e_1 \evalsto v }
  { \Gamma \judges e_0\ e_1 \evalsto v } 
  \end{gather*}
  \caption{The natural semantics of $\stlc$.}
  \label{fig:nat-sem}
\end{figure}
%
A value is a Boolean, an integer, a $\lambda$ abstraction, or a
fixpoint abstraction;
%
the space of values is denoted $\values$.
%
The semantics of $\stlc$ is defined by a natural semantics that
relates expressions to values under contexts, given in
\autoref{fig:nat-sem}.
%
The space of program contexts is denoted $\ctxs$.
%
The space of rules used to define the $\stlc$ semantics is denoted
$\evalrules$.
%
For $e \in \expr$ and $v \in \values$, the fact that $e$
\emph{evaluates} to $v$ under an empty context is denoted $e \evalsto
v$.

% define instantiated rules:
Each evaluation rules defines evaluations of a given expression in a
program in terms of evaluations of other expressions that occur in the
program.
%
For each $r \in \evalrules$ and $P \in \stlc$, an instantiation of $r$
in $P$ is $r$ paired with a successor expression for which it defines
an evaluation, and a sequence of predecessor expressions whose
evaluations determine the evaluation of the successor expression.
%
The number predecessor expressions that may occur in an instantiation
of $r$ (i.e., $r$'s predecessor arity) is determined by $r$;
%
the arity is immediate from the definition of $r$, and we do not give
the arities explicitly.
%
The space of instantiations of $\evalrules$ on subexpressions of $P$
is denoted $\instrules{P}$.
%
For each $r \in \instrules{P}$, the sequence of predecessor
expressions of $r$ is denoted $\rulepreds{r} \in \subexps{P}$.

% define derivations:
A derivation is a tree that defines rules applied in order prove that
a particular expression has a particular value.
%
\begin{defn}
  For $e \in \subexps{P}$, the \emph{derivation trees} of $e$ in $P$,
  denoted $\dertrees{P}{e}$, is the smallest space such that for each
  $r \in \instrules{P}$ with predecessors $\rulepreds{r} = e_0,
  \ldots, e_n \in \subexps{P}$, and derivation trees $D_0 \in
  \dertrees{P}{e_0}, \ldots, D_n \in \dertrees{P}{e_n}$, it holds that
  $(D_0, \ldots, D_n, r) \in \dertrees{P}{\rulesucc{r}}$.
\end{defn}
%
For each $P \in \stlc$, the derivations of $P$ are denoted as simply
$\progders{P} = \dertrees{P}{P}$.

% define evaluation under derivations:
For each $e \in \subexps{P}$, $\Gamma \in \ctxs$, and $v \in \values$
such that $\Gamma \judges e \evalsto v$, there is some $D \in
\dertrees{P}{e}$ that is evidence of evaluation.
%
This fact is denoted $\Gamma \judges_D e \evalsto v$.

% define equivalence of derivations:
For all $P_0, P_1 \in \stlc$, $D_0 \in \dertrees{P_0}{P_0}$, $D_1 \in
\dertrees{P_0}{P_0}$, $\Gamma \in \ctxs$, and $v_0, v_1 \in \values$
such that $\Gamma \judges_{D_0} P_0 \evalsto v_0$ and $\Gamma
\judges{D_1} P-1 \evalsto v_1$ it holds that $v_0 = v_1$, then $D_0$
is \emph{equivalent} to $D_1$, denoted $D_0 \equiv D_1$.

% define derivation contexts:
For each $d \in \dertrees{P_0}{P_0}$ and $d' \in \subders{d}$, the
position of $d'$ within $d$ is defined by the sequence of rules paired
with indices of premises in the rules under which $d'$ occurs in $d$.
%
The space of derivation contexts of all sub-derivations of $d$ is
denoted $\derctxs{d} = (\instrules{P} \times \nats)^{*}$.
%
The derivation contexts of all derivations of $P$ is denoted
$\derctxs{P} = \bigunion_{ d \in \dertrees{P} } \derctxs{ d }$.
%
For each $\gamma \in \derctxs{d}$, the last instantiated rule applied
in $d$ to build the sub-derivation at context $\gamma$ is denoted
$\prevrule{ \gamma } \in \instrules{P}$.
%
For $r \in \instrules{ P }$, the contexts formed by extending $\gamma$
with each pair of $r$ with an index of a predecessor of $r$ are
denoted $\rulexts(\gamma, r) \in \derctxs{d}^{*}$.
%
The extensions of $\gamma$ in $d$, ordered by index of predecessor
from which their first item is constructed, is denoted $\derexts{ d
}(\gamma) \in \derctxs{ d }^{*}$.

\paragraph{Typing}
%
Each expression has a type that describe the spaces of values that it
takes as input and the spaces of values to which it evaluates.
%
The space of types is given in \autoref{fig:types}.
%
A type is either a base type or a function from a type to a type.
%
The definition of types in \autoref{fig:types} thus does not include
higher-order expressions.
%
We will relax this restriction in future work.
%
\BH{It's probably reasonable to relax this assumption before a first
  paper}

% introduce has-type symbol:
For expression $e \in \expr$ and type $\tau \in \types$, the fact that
$e$ has type $\tau$ is denoted $e \hastype \tau$.
%
The definition of the has-type relation is standard.

% standard defns for logic:
\paragraph{Logic}
%
\sys uses formal logic to model the semantics of programs.
%
The quantifier-free fragment of the theory of linear arithmetic is
denoted $\lia$.
%
For each space of logical variables $X$, the space of $\lia$ formulas
over $X$ is denoted $\formulas{X}$.
%
For each formula $\varphi \in \formulas{X}$, the set of variables that
occur in $\varphi$ (i.e., the \emph{vocabulary} of $\varphi$) is
denoted $\vocab(\varphi)$.
% define models, satisfaction, entailment
A \lia \emph{model} $m$ over $X$ is an assignment from each variable
in $X$ to an integer.
%
The fact that model $m$ \emph{satisfies} a formula $\varphi$ is
denoted $m \sats \varphi$.
%
For formulas $\varphi_0, \ldots, \varphi_n, \varphi \in \formulas{X}$,
the fact that $\varphi_0, \ldots, \varphi_n$ \emph{entail} $\varphi$
is denoted $\varphi_0, \ldots, \varphi_n \entails \varphi$.

% Define replacement and substitution:
For all vectors of variables $X = [ x_0, \ldots, x_n ]$ and $Y = [
y_0, \ldots, y_n ]$, the \lia formula constraining the equality of
each element in $X$ with its corresponding element in $Y$, i.e., the
formula $\bigland_{0 \leq i \leq n} x_i = y_i$, is denoted $X = Y$.
%
The repeated replacement of variables $\varphi[ y_0 / x_0 \ldots y_{n}
/ x_{n} ]$ is denoted $\replace{\varphi}{Y}{X}$.
%
For each formula $\varphi$ defined over free variables $X$,
$\replace{\varphi}{X}{Y}$ is denoted alternatively as $\varphi[Y]$.
%
The number of free variables in formula $\varphi$ is denoted
$\degreeof(\varphi)$.

% Introduce decision procedure:
Although determining the satisfiability of a \lia formula is
NP-complete in general, decision procedures for \lia have been
proposed that often determine the satisfiability of formulas that
arise from practical verification problems
efficiently~\cite{demoura08}.
%
\sys assumes access to a decision procedure for \lia, denoted \issat.

\paragraph{Symbolic encoding of semantics}
%
The semantics of $\stlc$ is represented symbolically using \lia
formulas.
%
For $e \in \expr$, let $\symvars{e}$ denote a disjoint copy of
$\freevars(e)$, extended with one symbol $\alpha_i$ for each of the
$i$ parameters in the type of $e$, and a symbol $\nu_e$ that
models the result of fully applying $e$. 
%
For expressions $E \subseteq \expr$, let $\symvars{E} = \bigunion_{e
  \in E} \symvars{e}$.

% rule constraint:
For each $r \in \instrules{ P }$, there is a formula $\psi \in
\formulas{ \symvars{ \rulepreds{r} }, \symvars{ \rulesucc{r} } }$ that
satisfy the following condition.
%
Let $\Gamma_0, \ldots, \Gamma_n \in \ctxs$, $A_0, \ldots, A_n, A \in
\values^{*}$, and $\nu_0, \ldots, \nu_n, \nu \in \values$ be such that
for each $0 \leq i \leq n$, $\Gamma_i \judges e_i\ A_i \evalsto
\nu_i$, and $\Gamma \judges e\ A \evalsto \nu$.
%
Then $\Gamma_0, A_0, \nu_0, \ldots, \Gamma_n, A_n, \nu_n, \Gamma, A,
\nu \sats \psi$.
%
In such a case, $\psi$ is denoted $\symstep{ r }$.

\subsection{Partial equivalence of STLC programs}
\label{sec:peq}
%
If STLC programs $P_0$ and $P_1$, applied to the same input, evaluate
to the same value, then $P_0$ and $P_1$ are partially equivalent.
%
\begin{defn}
  \label{defn:peq}
  For $P_0, P_1 \in \stlc$, if for all $v, v_0, v_1 \in \values$ such
  that $P_0\ v \evalsto v_0$ and $P_1\ v \evalsto v_1$, it holds that
  $v_0 = v_1$, then $P_0$ and $P_1$ are \emph{partially equivalent}.
\end{defn}
%
The fact that $P_0$ and $P_1$ are partially equivalent is denoted $P_0
\equiv P_1$.
%
The main problem that we address in this work is, given STLC programs
$P_0$ and $P_1$, to determine if $P_0 \equiv P_1$.

% disclaimer: we're keeping it simple, it doesn't matter:
\autoref{defn:peq} only allows programs to be partially equivalent if
they take exactly one argument.
%
The definition can be directly generalized to include pairs of
programs over tuples of arguments of arbitrary length.

\subsection{Constrained Horn Clauses}
\label{sec:chcs}

\subsubsection{Structure}
% definition of CHC
A Constrained Horn Clause is a body, consisting of a conjunctive set
of uninterpreted relational predicates and a constraint, and a head
relational predicate.
%
Relational predicates are predicate symbols paired with a map from
each symbol to its arity.
%
\begin{defn}
  \label{defn:rel-preds}
  For each space of symbols $\mathcal{R}$ and function $a: \mathcal{R}
  \to \nats$, $(\mathcal{R}, a)$ is a space of \emph{relational
    predicates}.
\end{defn}
%
The space of all relational predicates is denoted $\relpreds$.
%
For each space of relational predicates $\mathcal{R} \in \relpreds$,
we denote the predicate symbols and arity of $\mathcal{R}$ as
$\relsof{\mathcal{R}}$ and $\arityof{\mathcal{R}}$, respectively.
%
For relational predicates $\mathcal{R} \in \relpreds$ and symbol $R$,
we denote $R \in \relsof{ \mathcal{R} }$ alternatively as $R \in
\mathcal{R}$.
%
All definitions introduced in this section are given over a fixed,
arbitrary set of relational-predicate symbols $\mathcal{R}$.

% define applications of relational predicates:
An application of a relational predicate is a relational-predicate
symbol $R$ paired with a sequence of variables of length equal to the
arity of $R$.
%
\begin{defn}
  \label{defn:pred-apps}
  For $R \in \mathcal{R}$ and sequence of variables $Y \in X^{*}$ such
  that $|Y| = \arityof{\mathcal{R}}(R)$, $(R, Y)$ is an
  \emph{application}.
\end{defn}
%
The space of applications is denoted $\apps{\mathcal{R}}$.
%
For each application $A \in \apps{\mathcal{R}}$, the predicate symbol
and argument sequence of $A$ are denoted $\relof{A}$ and $\argsof{A}$
respectively.

% define CHC:
A Constrained Horn Clause is a body of applications, a constraint, and
a head application.
%
\begin{defn}
  \label{defn:chcs-structure}
  For $\mathcal{A} \subseteq \apps{\mathcal{R}}$ and %
  $\varphi \in \formulas{X}$, $\mathcal{B} = (\mathcal{A}, \varphi)$
  is a \emph{clause body}.
  % 
  For $H \in \apps{\mathcal{R}}$, $(\mathcal{B}, H)$ is a
  \emph{Constrained Horn Clause}.
\end{defn}
% define space of bodies:
The space of clause bodies is denoted $\bodies{ \mathcal{R} } =
\pset(\apps{\mathcal{R}}) \times \formulas{X}$.
%
For each $\mathcal{B} \in \bodies{ \mathcal{R} }$, the constraint of
$\mathcal{B}$ is denoted $\ctrof{ \mathcal{B} }$.
% define space, projection:
The space of Constrained Horn Clauses is denoted $\chc{ \mathcal{R} }
= \bodies{ \mathcal{R} } \times \apps{ \mathcal{R} }$.
%
For each clause $\mathcal{C} \in \chc{\mathcal{R}}$, the body and head
of $\mathcal{C}$ are denoted $\bodyof{ \mathcal{C} }$ and $\headof{
  \mathcal{C} }$, respectively.
% define siblings:
For each $\mathcal{S} \subseteq \chc{ \mathcal{R} }$, $\mathcal{C} \in
\mathcal{S}$, and all applications $A_0, A_1 \in \appsof{ \bodyof{
    \mathcal{C} } }$, $\relof{A_0}$ and $\relof{A_1}$ are
\emph{siblings} in $\mathcal{S}$.

% give conditions on normalization:
Let $\mathcal{S} \subseteq \chc{ \mathcal{R} }$ that is recursion-free
be such that there is exactly one relational predicate $\queryof{
  \mathcal{S} }$ that is the dependency of no relational predicate.
%
Then $\mathcal{S}$ is a \emph{normalized} recursion-free system.
%
For the remainder of this paper, we consider only normalized
recursion-free sets of CHCs, and denote the space of such sets as
$\chcs{ \mathcal{R} }$.

\subsubsection{Solutions}
\label{sec:chc-solns}
%
A solution to a CHC system $\mathcal{S}$ is an interpretation of each
relational predicate $R$ of arity $n$ as a formula over $n$ free
variables such that for each clause $\mathcal{C} \in \mathcal{S}$, the
conjunction of interpretations of all relational predicates in the
body of $\mathcal{C}$ and the constraint of $\mathcal{C}$ entail the
interpretation of the head of $\mathcal{C}$.
%
Let a map from each $R \in \relsof{ \mathcal{R} }$ to a formula over
an ordered vector of $\arityof{ \mathcal{R} }(R)$ free variables be an
\emph{interpretation} of $\mathcal{R}$;
%
let the space of interpretations of $\mathcal{R}$ be denoted
$\interps{ \mathcal{R} }$.
%
\begin{defn}
  \label{defn:chc-soln}
  For $\mathcal{B} \in \bodies{ \mathcal{R} }$ and $H \in \apps{
    \mathcal{R} }$, %
  let $\sigma \in \interps{ \mathcal{R} }$ be such that for each $R
  \in \mathcal{R}$, $\arityof{\mathcal{R}}(R) = \degreeof{\sigma(R)}$
  and %
  %
  \[ \elts{ \sigma(\relof{ A })[ \argsof{ A } ] }_{ A \in \appsof{
      \mathcal{B} } }, %
  \ctrof{ \mathcal{B} } \entails %
  \sigma( \relof{H} )[ \argsof{ H } ]
  \]
  Then $\sigma$ is a \emph{solution} of $(\mathcal{B}, H)$.
\end{defn}
% define partial solution 
For $\mathcal{S} \in \chcs{ \mathcal{R} }$, if %
\textbf{(1)} for each $\mathcal{C} \in \mathcal{S}$, $\sigma$ is a
solution of $\mathcal{C}$ and %
\textbf{(2)} $\sigma(\queryof{ \mathcal{S} }) \entails \false$, then
$\sigma$ is a \emph{solution} of $\mathcal{S}$.
%
The space of solutions of $\mathcal{S}$ is denoted $\solutions{
  \mathcal{S} }$.

% introduce solver:
A procedure that, given a recursion-free system $\mathcal{S}$ returns
either a solution of $\mathcal{S}$ or a value that denotes that
$\mathcal{S}$ has no solution is a CHC \emph{solver}.
%
\sys is defined as using a CHC solver, named $\solvechc$.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "p"
%%% End: 
