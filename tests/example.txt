sum_1(n_1,c_1) : int->int -> int
   sumAdd_1(0, n_1,c_1)  (constrains1)

sumAdd_1(i_1,n_1,c_1): int -> int -> int -> int
 | i_1 < n_1 => sumAdd_1(b_1+1,n_1,c_1) + sumAux(0,n_1,c_1)  (constrains2)
 | otherwise => 0 (constrains3)

sumAux(i_1,n_1,c_1): int->int -> int
 | i_1< n_1 => c_1+sumAux(i_1+1,n_1,c_1) (constrains4)
 | otherwise => 0 (constrains5)


sum_2(n_2,c_2) : int-> int -> int
  sumAdd_2(0,0,n_2,c_2) (constrains6)

sumAdd_2 (i_2,j_2,n_2,c_2): int->int->int-> int
 | i_2< n_2 && j_2< n_2 => c+sumAdd_2 (i_2+1,j_2,n_2,c_2) (constrains7)
 | i_2 >= n_2 && j_2<n_2 => sumAdd_2 (0,j_2+1,n_2,c_2) (constrains8)
 | otherwise => 0  (constrains9)

one valid proof path: 
 
 g(sum_1, sum_2) =>  ((n_1 = n_2 /\ c_1 = c_2) = > output_1 = output_2 )

 g(sumAdd_1, sum_2) /\ constrains1 => g(sum_1,sum_2)

 g(sumAdd_1, sumAdd_2 ) /\ constrains6 => g(sumAdd_1, sum_2)

 g(sumAdd_1, sumAux, sumAdd_2 ) /\ constrains2 => g(sumAdd_1, sumAdd_2 )

 g(sumAdd_2) /\ constrains3 => g(sumAdd_1, sumAdd_2)

 g(sumAdd_2) /\ cosntrains7  => g(sumAdd_2 )

 g(sumAdd_2) /\ cosntrains8  => g(sumAdd_2 )
 
 cosntrains9  => g(sumAdd_2 )

 g(sumAux,sumAdd_2) /\ constrains3  => g(sumAdd_1, sumAux, sumAdd_2 )

 g(sumAdd_1, sumAux,sumAdd_2) /\ constrains2  => g(sumAdd_1, sumAux, sumAdd_2 )

 g(sumAux,sumAdd_2 ) /\ constrains4 => g(sumAux,sumAdd_2)

 g(sumAdd_2 ) /\ constrains5 => g(sumAux,sumAdd_2)            
